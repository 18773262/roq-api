/* Copyright (c) 2017-2019, Hans Erik Thrane */

#pragma once

#include <cstring>

#include <chrono>
#include <map>
#include <set>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#define ROQ_VERSION "@ROQ_VERSION_MAJOR@.@ROQ_VERSION_MINOR@.@ROQ_VERSION_PATCH@"

#if defined(__GNUC__) || defined(__clang__)
#define ROQ_PUBLIC __attribute__ ((visibility("default")))
#endif

namespace roq {

// limits

constexpr auto ACCOUNT_NAME_MAX_LENGTH = size_t{31};
constexpr auto USER_NAME_MAX_LENGTH = size_t{31};

// common error messages

constexpr std::string_view LOGOUT_RESPONSE("LOGOUT_RESPONSE");
constexpr std::string_view RESEND_NOT_SUPPORTED("RESEND_NOT_SUPPORTED");
constexpr std::string_view GATEWAY_NOT_READY("GATEWAY_NOT_READY");
constexpr std::string_view INVALID_ACCOUNT("INVALID_ACCOUNT");
constexpr std::string_view INVALID_EXCHANGE("INVALID_EXCHANGE");
constexpr std::string_view INVALID_POSITION_EFFECT("INVALID_POSITION_EFFECT");
constexpr std::string_view INVALID_ORDER_TEMPLATE("INVALID_ORDER_TEMPLATE");
constexpr std::string_view NETWORK_ERROR("NETWORK_ERROR");
constexpr std::string_view UNKNOWN_ORDER_ID("UNKNOWN_ORDER_ID");
constexpr std::string_view UNKNOWN_EXCHANGE_ORDER_ID("UNKNOWN_EXCHANGE_ORDER_ID");
constexpr std::string_view MODIFY_ORDER_NOT_SUPPORTED("MODIFY_ORDER_NOT_SUPPORTED");
constexpr std::string_view INVALID_ORDER_ID("INVALID_ORDER_ID");

// enums

enum class ConnectionStatus : int8_t {
  DISCONNECTED = 0,
  CONNECTED = 1,
  MIN = DISCONNECTED,
  MAX = CONNECTED
};

inline const char * const *EnumNamesConnectionStatus() {
  static const char * const names[] = {
    "DISCONNECTED",
    "CONNECTED",
  };
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionStatus()[index];
}

enum class GatewayStatus : int8_t {
  DISCONNECTED = 0,
  CONNECTING = 1,
  LOGIN_SENT = 2,
  DOWNLOADING = 3,
  READY = 4,
  LOGGED_OUT = 5,
  MIN = DISCONNECTED,
  MAX = LOGGED_OUT
};

inline const char * const *EnumNamesGatewayStatus() {
  static const char * const names[] = {
    "DISCONNECTED",
    "CONNECTING",
    "LOGIN_SENT",
    "DOWNLOADING",
    "READY",
    "LOGGED_OUT",
  };
  return names;
}

inline const char *EnumNameGatewayStatus(GatewayStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGatewayStatus()[index];
}

enum class TradingStatus : int8_t {
  UNDEFINED = 0,
  CLOSED = 1,
  OPEN = 2,
  MIN = UNDEFINED,
  MAX = OPEN
};

inline const char * const *EnumNamesTradingStatus() {
  static const char * const names[] = {
    "UNDEFINED",
    "CLOSED",
    "OPEN",
  };
  return names;
}

inline const char *EnumNameTradingStatus(TradingStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTradingStatus()[index];
}

enum class Side : int8_t {
  UNDEFINED = 0,
  BUY = 1,
  SELL = 2,
  MIN = UNDEFINED,
  MAX = SELL
};

inline const char * const *EnumNamesSide() {
  static const char * const names[] = {
    "UNDEFINED",
    "BUY",
    "SELL",
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSide()[index];
}

enum class OrderType : int8_t {
  UNDEFINED = 0,
  MARKET = 1,
  LIMIT = 2,
  MIN = UNDEFINED,
  MAX = LIMIT
};

inline const char * const *EnumNamesOrderType() {
  static const char * const names[] = {
    "UNDEFINED",
    "MARKET",
    "LIMIT",
  };
  return names;
}

inline const char *EnumNameOrderType(OrderType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOrderType()[index];
}

enum class TimeInForce : int8_t {
  UNDEFINED = 0,
  FOK = 1,
  IOC = 2,
  GFD = 3,
  GTC = 4,
  MIN = UNDEFINED,
  MAX = GTC
};

inline const char * const *EnumNamesTimeInForce() {
  static const char * const names[] = {
    "UNDEFINED",
    "FOK",
    "IOC",
    "GFD",
    "GTC",
  };
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTimeInForce()[index];
}

enum class PositionEffect : int8_t {
  UNDEFINED = 0,
  OPEN = 1,
  CLOSE = 2,
  MIN = UNDEFINED,
  MAX = CLOSE
};

inline const char * const *EnumNamesPositionEffect() {
  static const char * const names[] = {
    "UNDEFINED",
    "OPEN",
    "CLOSE",
  };
  return names;
}

inline const char *EnumNamePositionEffect(PositionEffect e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPositionEffect()[index];
}

enum class OrderStatus : int8_t {
  UNDEFINED = 0,
  SENT = 1,
  REJECTED = 2,
  ACCEPTED = 3,
  PENDING = 4,
  WORKING = 5,
  COMPLETED = 6,
  CANCELED = 7,
  MIN = UNDEFINED,
  MAX = CANCELED
};

inline const char * const *EnumNamesOrderStatus() {
  static const char * const names[] = {
    "UNDEFINED",
    "SENT",
    "REJECTED",
    "ACCEPTED",
    "PENDING",
    "WORKING",
    "COMPLETED",
    "CANCELED",
  };
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOrderStatus()[index];
}

enum class RequestStatus : int8_t {
  CLIENT_TIMEOUT = 0,
  GATEWAY_TIMEOUT = 1,
  GATEWAY_FORWARDED = 2,
  GATEWAY_REJECTED = 3,
  BROKER_TIMEOUT = 4,
  BROKER_FORWARDED = 5,
  BROKER_REJECTED = 6,
  EXCHANGE_ACCEPTED = 7,
  EXCHANGE_REJECTED = 8,
  MIN = CLIENT_TIMEOUT,
  MAX = EXCHANGE_REJECTED
};

inline const char * const *EnumNamesRequestStatus() {
  static const char * const names[] = {
    "CLIENT_TIMEOUT",
    "GATEWAY_TIMEOUT",
    "GATEWAY_FORWARDED",
    "GATEWAY_REJECTED",
    "BROKER_TIMEOUT",
    "BROKER_FORWARDED",
    "BROKER_REJECTED",
    "EXCHANGE_ACCEPTED",
    "EXCHANGE_REJECTED",
  };
  return names;
}

inline const char *EnumNameRequestStatus(RequestStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRequestStatus()[index];
}

// transport

struct ROQ_PUBLIC MessageInfo final {
  uint8_t source;
  std::string_view source_name;
  uint64_t source_seqno;
  std::chrono::nanoseconds receive_time_utc;
  std::chrono::nanoseconds receive_time;  // monotonic clock
  std::chrono::nanoseconds source_send_time;  // monotonic clock
  std::chrono::nanoseconds source_receive_time;  // monotonic clock
  std::chrono::nanoseconds origin_create_time;  // monotonic clock
  bool is_last;
  uint64_t opaque;
};

// messages

struct ROQ_PUBLIC DownloadBegin final {
  std::string_view account;
};

struct ROQ_PUBLIC DownloadEnd final {
  std::string_view account;
  uint32_t max_order_id;
};

struct ROQ_PUBLIC MarketDataStatus final {
  GatewayStatus status;
};

struct ROQ_PUBLIC OrderManagerStatus final {
  std::string_view account;
  GatewayStatus status;
};

struct ROQ_PUBLIC SessionStatistics final {
  std::string_view exchange;
  std::string_view symbol;
  double pre_open_interest;
  double pre_settlement_price;
  double pre_close_price;
  double highest_traded_price;
  double lowest_traded_price;
  double upper_limit_price;
  double lower_limit_price;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC DailyStatistics final {
  std::string_view exchange;
  std::string_view symbol;
  double open_price;
  double settlement_price;
  double close_price;
  double open_interest;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC MBPUpdate final {
  double price;
  double quantity;
};

static_assert(sizeof(MBPUpdate) == 16);

struct ROQ_PUBLIC MarketByPrice final {
  std::string_view exchange;
  std::string_view symbol;
  size_t bid_length;
  const MBPUpdate *bid;
  size_t ask_length;
  const MBPUpdate *ask;
  bool snapshot;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC Trade final {
  Side side;
  double price;
  double quantity;
  char trade_id[40];
};

static_assert(sizeof(Trade) == 64);

struct ROQ_PUBLIC TradeSummary final {
  std::string_view exchange;
  std::string_view symbol;
  size_t trade_length;
  const Trade *trade;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC ReferenceData final {
  std::string_view exchange;
  std::string_view symbol;
  double tick_size;
  double limit_up;
  double limit_down;
  double multiplier;
  double min_trade_vol;
};

struct ROQ_PUBLIC MarketStatus final {
  std::string_view exchange;
  std::string_view symbol;
  TradingStatus trading_status;
};

struct ROQ_PUBLIC PositionUpdate final {
  std::string_view account;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  uint32_t last_trade_id;
  double position;
  double position_cost;
  double position_yesterday;
  double position_cost_yesterday;
};

struct ROQ_PUBLIC OrderUpdate final {
  std::string_view account;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  OrderStatus order_status;
  Side side;
  double price;
  double remaining_quantity;
  double traded_quantity;
  PositionEffect position_effect;
  std::string_view order_template;
  std::chrono::nanoseconds create_time_utc;
  std::chrono::nanoseconds update_time_utc;
  // debug info
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC TradeUpdate final {
  std::string_view account;
  uint32_t trade_id;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  double quantity;
  double price;
  PositionEffect position_effect;
  std::string_view order_template;
  std::chrono::nanoseconds create_time_utc;
  std::chrono::nanoseconds update_time_utc;
  // debug info
  uint32_t gateway_order_id;
  uint32_t gateway_trade_id;
  std::string_view external_order_id;
  std::string_view external_trade_id;
};

struct ROQ_PUBLIC Subscribe final {
  std::set<std::string> accounts;
  std::map<std::string, std::set<std::string> > symbols_by_exchange;
};

struct ROQ_PUBLIC CreateOrder final {
  std::string_view account;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  double quantity;
  OrderType order_type;
  double price;
  TimeInForce time_in_force;
  PositionEffect position_effect;
  std::string_view order_template;
};

struct ROQ_PUBLIC ModifyOrder final {
  std::string_view account;
  uint32_t order_id;
  double quantity;  // total target quantity
  double price;
};

struct ROQ_PUBLIC CancelOrder final {
  std::string_view account;
  uint32_t order_id;
};

struct ROQ_PUBLIC RequestUpdate final {
  std::string_view account;
  uint32_t order_id;
  RequestStatus status;
  std::string_view text;
  // debug info
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC CreateOrderAck final {
  std::string_view account;
  uint32_t order_id;
  bool failure;
  std::string_view reason;
  // debug info
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC ModifyOrderAck final {
  std::string_view account;
  uint32_t order_id;
  bool failure;
  std::string_view reason;
  // debug info
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC CancelOrderAck final {
  std::string_view account;
  uint32_t order_id;
  bool failure;
  std::string_view reason;
  // debug info
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC CustomMessage final {
  const void *message;
  size_t length;
};

// events

struct ROQ_PUBLIC StartEvent final {
};

struct ROQ_PUBLIC StopEvent final {
};

struct ROQ_PUBLIC TimerEvent final {
  std::chrono::nanoseconds now;  // monotonic clock
};

struct ROQ_PUBLIC ConnectionStatusEvent final {
  const MessageInfo& message_info;
  ConnectionStatus connection_status;
};

struct ROQ_PUBLIC BatchBeginEvent final {
  const MessageInfo& message_info;
};

struct ROQ_PUBLIC BatchEndEvent final {
  const MessageInfo& message_info;
};

struct ROQ_PUBLIC DownloadBeginEvent final {
  const MessageInfo& message_info;
  const DownloadBegin& download_begin;
};

struct ROQ_PUBLIC DownloadEndEvent final {
  const MessageInfo& message_info;
  const DownloadEnd& download_end;
};

struct ROQ_PUBLIC MarketDataStatusEvent final {
  const MessageInfo& message_info;
  const MarketDataStatus& market_data_status;
};

struct ROQ_PUBLIC OrderManagerStatusEvent final {
  const MessageInfo& message_info;
  const OrderManagerStatus& order_manager_status;
};

struct ROQ_PUBLIC ReferenceDataEvent final {
  const MessageInfo& message_info;
  const ReferenceData& reference_data;
};

struct ROQ_PUBLIC MarketStatusEvent final {
  const MessageInfo& message_info;
  const MarketStatus& market_status;
};

struct ROQ_PUBLIC SessionStatisticsEvent final {
  const MessageInfo& message_info;
  const SessionStatistics& session_statistics;
};

struct ROQ_PUBLIC DailyStatisticsEvent final {
  const MessageInfo& message_info;
  const DailyStatistics& daily_statistics;
};

struct ROQ_PUBLIC MarketByPriceEvent final {
  const MessageInfo& message_info;
  const MarketByPrice& market_by_price;
};

struct ROQ_PUBLIC TradeSummaryEvent final {
  const MessageInfo& message_info;
  const TradeSummary& trade_summary;
};

struct ROQ_PUBLIC PositionUpdateEvent final {
  const MessageInfo& message_info;
  const PositionUpdate& position_update;
};

struct ROQ_PUBLIC OrderUpdateEvent final {
  const MessageInfo& message_info;
  const OrderUpdate& order_update;
};

struct ROQ_PUBLIC TradeUpdateEvent final {
  const MessageInfo& message_info;
  const TradeUpdate& trade_update;
};

struct ROQ_PUBLIC SubscribeEvent final {
  const MessageInfo& message_info;
  const Subscribe& subscribe;
};

struct ROQ_PUBLIC CreateOrderEvent final {
  const MessageInfo& message_info;
  const CreateOrder& create_order;
};

struct ROQ_PUBLIC ModifyOrderEvent final {
  const MessageInfo& message_info;
  const ModifyOrder& modify_order;
};

struct ROQ_PUBLIC CancelOrderEvent final {
  const MessageInfo& message_info;
  const CancelOrder& cancel_order;
};

struct ROQ_PUBLIC RequestUpdateEvent final {
  const MessageInfo& message_info;
  const RequestUpdate& request_update;
};

struct ROQ_PUBLIC CreateOrderAckEvent final {
  const MessageInfo& message_info;
  const CreateOrderAck& create_order_ack;
};

struct ROQ_PUBLIC ModifyOrderAckEvent final {
  const MessageInfo& message_info;
  const ModifyOrderAck& modify_order_ack;
};

struct ROQ_PUBLIC CancelOrderAckEvent final {
  const MessageInfo& message_info;
  const CancelOrderAck& cancel_order_ack;
};

struct ROQ_PUBLIC CustomMessageEvent final {
  const MessageInfo& message_info;
  const CustomMessage& custom_message;
};

// exceptions

class ROQ_PUBLIC Exception : public std::exception {
};

class ROQ_PUBLIC RuntimeError : public Exception {
 public:
  explicit RuntimeError(const char *what)
      : _what(what) {
  }
  explicit RuntimeError(std::string&& what)
      : _what(std::move(what)) {
  }
  explicit RuntimeError(const std::string& what)
      : _what(what) {
  }
  const char *what() const noexcept override {
    return _what.c_str();
  }

 private:
  std::string _what;
};

class ROQ_PUBLIC Fatal final : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC PermissionDenied : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC ConnectionRefused : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC FileDoesNotExist : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC NotReady : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC NotConnected : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC OrderNotLive : public RuntimeError {
  using RuntimeError::RuntimeError;
};

// utilities

struct ROQ_PUBLIC Layer final {
  double bid_price;
  double bid_quantity;
  double ask_price;
  double ask_quantity;
};

/* Interface used to implement an event generator.
 */
class ROQ_PUBLIC Generator {
 public:
  class ROQ_PUBLIC Dispatcher {
   public:
    virtual void operator()(const MarketDataStatusEvent&) = 0;
    virtual void operator()(const OrderManagerStatusEvent&) = 0;
    virtual void operator()(const SessionStatisticsEvent&) = 0;
    virtual void operator()(const DailyStatisticsEvent&) = 0;
    virtual void operator()(const MarketByPriceEvent&) = 0;
    virtual void operator()(const TradeSummaryEvent&) = 0;
    virtual void operator()(const ReferenceDataEvent&) = 0;
    virtual void operator()(const MarketStatusEvent&) = 0;
    virtual void operator()(const PositionUpdateEvent&) = 0;
  };

  virtual ~Generator() {}
  virtual std::pair<bool, std::chrono::nanoseconds> fetch() = 0;
  virtual void dispatch(Dispatcher& dispatcher) = 0;
};

/* Interface used to implement order matching
 */
class ROQ_PUBLIC Matcher {
 public:
  class ROQ_PUBLIC Dispatcher {
   public:
    virtual void operator()(const DownloadBeginEvent&) = 0;
    virtual void operator()(const DownloadEndEvent&) = 0;
    virtual void operator()(const MarketDataStatusEvent&) = 0;
    virtual void operator()(const OrderManagerStatusEvent&) = 0;
    virtual void operator()(const ReferenceDataEvent&) = 0;
    virtual void operator()(const MarketStatusEvent&) = 0;
    virtual void operator()(const SessionStatisticsEvent&) = 0;
    virtual void operator()(const DailyStatisticsEvent&) = 0;
    virtual void operator()(const MarketByPriceEvent&) = 0;
    virtual void operator()(const TradeSummaryEvent&) = 0;
    virtual void operator()(const PositionUpdateEvent&) = 0;
    virtual void operator()(const OrderUpdateEvent&) = 0;
    virtual void operator()(const TradeUpdateEvent&) = 0;
    virtual void operator()(const RequestUpdateEvent&) = 0;
    virtual void operator()(const CreateOrderAckEvent&) = 0;
    virtual void operator()(const ModifyOrderAckEvent&) = 0;
    virtual void operator()(const CancelOrderAckEvent&) = 0;
  };

  virtual ~Matcher() {}

  virtual void dispatch(
      Dispatcher& dispatcher,
      std::chrono::nanoseconds next) = 0;

  virtual void operator()(const MarketDataStatusEvent&) = 0;
  virtual void operator()(const OrderManagerStatusEvent&) = 0;
  virtual void operator()(const ReferenceDataEvent&) = 0;
  virtual void operator()(const MarketStatusEvent&) = 0;
  virtual void operator()(const SessionStatisticsEvent&) = 0;
  virtual void operator()(const DailyStatisticsEvent&) = 0;
  virtual void operator()(const MarketByPriceEvent&) = 0;
  virtual void operator()(const TradeSummaryEvent&) = 0;
  virtual void operator()(const PositionUpdateEvent&) = 0;
  virtual void operator()(const CreateOrderEvent&) = 0;
  virtual void operator()(const ModifyOrderEvent&) = 0;
  virtual void operator()(const CancelOrderEvent&) = 0;
};

struct ROQ_PUBLIC Account {
  uint8_t id;
  std::string name;
  std::string login;
  std::string password;
  std::string secret;
  std::unordered_map<
    std::string,
    std::unordered_set<std::string> > symbols;
};

struct ROQ_PUBLIC User {
  uint8_t id;
  std::string name;
  std::string password;
  std::unordered_set<std::string> accounts;
  std::unordered_map<
    std::string,
    std::unordered_set<std::string> > symbols;
  struct Limits final {
    struct CreateOrder final {
      uint32_t max;
      std::chrono::seconds monitor_period;
      std::chrono::seconds ban_period;
    } create_order;
  } limits;
};

// utilities

inline bool is_complete(const RequestStatus& status) {
  switch (status) {
    case RequestStatus::GATEWAY_FORWARDED:
    case RequestStatus::BROKER_FORWARDED:
      return false;
    case RequestStatus::CLIENT_TIMEOUT:
    case RequestStatus::GATEWAY_TIMEOUT:
    case RequestStatus::GATEWAY_REJECTED:
    case RequestStatus::BROKER_TIMEOUT:
    case RequestStatus::BROKER_REJECTED:
    case RequestStatus::EXCHANGE_ACCEPTED:
    case RequestStatus::EXCHANGE_REJECTED:
      return true;
    default:
      // TODO(thraneh): should throw
      return true;
  }
}

inline Side invert(Side side) {
  switch (side) {
    case Side::BUY: return Side::SELL;
    case Side::SELL: return Side::BUY;
    default: return side;
  }
}

inline int sign(Side side) {
  switch (side) {
    case Side::BUY: return 1;
    case Side::SELL: return -1;
    default: return 0;
  }
}

inline std::string_view get_trade_id_as_string_view(
    const Trade& trade) {
  auto null_ptr = std::memchr(
      trade.trade_id,
      '\0',
      sizeof(trade.trade_id));
  auto length = null_ptr
    ? static_cast<size_t>(
          reinterpret_cast<const char *>(null_ptr) - trade.trade_id)
    : sizeof(trade.trade_id);
  return std::string_view(trade.trade_id, length);
}

}  // namespace roq
