/* Copyright (c) 2017-2019, Hans Erik Thrane */

#pragma once

#include <cstring>

#include <chrono>
#include <map>
#include <set>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#define ROQ_VERSION "@ROQ_VERSION_MAJOR@.@ROQ_VERSION_MINOR@.@ROQ_VERSION_PATCH@"

#if defined(__GNUC__) || defined(__clang__)
#define ROQ_PUBLIC __attribute__ ((visibility("default")))
#endif

namespace roq {

// limits

constexpr auto MAX_ACCOUNT_NAME_LENGTH = size_t{31};
constexpr auto MAX_USER_NAME_LENGTH = size_t{31};
constexpr auto MAX_TRADE_ID_LENGTH = size_t{39};

// enums

enum class ConnectionStatus : int8_t {
  DISCONNECTED = 0,
  CONNECTED = 1,
  MIN = DISCONNECTED,
  MAX = CONNECTED
};

inline const char * const *EnumNamesConnectionStatus() {
  static const char * const names[] = {
    "DISCONNECTED",
    "CONNECTED",
  };
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionStatus()[index];
}

enum class GatewayStatus : int8_t {
  DISCONNECTED = 0,
  CONNECTING = 1,
  LOGIN_SENT = 2,
  DOWNLOADING = 3,
  READY = 4,
  LOGGED_OUT = 5,
  MIN = DISCONNECTED,
  MAX = LOGGED_OUT
};

inline const char * const *EnumNamesGatewayStatus() {
  static const char * const names[] = {
    "DISCONNECTED",
    "CONNECTING",
    "LOGIN_SENT",
    "DOWNLOADING",
    "READY",
    "LOGGED_OUT",
  };
  return names;
}

inline const char *EnumNameGatewayStatus(GatewayStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGatewayStatus()[index];
}

enum class TradingStatus : int8_t {
  UNDEFINED = 0,
  CLOSED = 1,
  OPEN = 2,
  MIN = UNDEFINED,
  MAX = OPEN
};

inline const char * const *EnumNamesTradingStatus() {
  static const char * const names[] = {
    "UNDEFINED",
    "CLOSED",
    "OPEN",
  };
  return names;
}

inline const char *EnumNameTradingStatus(TradingStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTradingStatus()[index];
}

enum class Side : int8_t {
  UNDEFINED = 0,
  BUY = 1,
  SELL = 2,
  MIN = UNDEFINED,
  MAX = SELL
};

inline const char * const *EnumNamesSide() {
  static const char * const names[] = {
    "UNDEFINED",
    "BUY",
    "SELL",
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSide()[index];
}

enum class OrderType : int8_t {
  UNDEFINED = 0,
  MARKET = 1,
  LIMIT = 2,
  MIN = UNDEFINED,
  MAX = LIMIT
};

inline const char * const *EnumNamesOrderType() {
  static const char * const names[] = {
    "UNDEFINED",
    "MARKET",
    "LIMIT",
  };
  return names;
}

inline const char *EnumNameOrderType(OrderType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOrderType()[index];
}

enum class TimeInForce : int8_t {
  UNDEFINED = 0,
  FOK = 1,
  IOC = 2,
  GFD = 3,
  GTC = 4,
  MIN = UNDEFINED,
  MAX = GTC
};

inline const char * const *EnumNamesTimeInForce() {
  static const char * const names[] = {
    "UNDEFINED",
    "FOK",
    "IOC",
    "GFD",
    "GTC",
  };
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTimeInForce()[index];
}

enum class PositionEffect : int8_t {
  UNDEFINED = 0,
  OPEN = 1,
  CLOSE = 2,
  MIN = UNDEFINED,
  MAX = CLOSE
};

inline const char * const *EnumNamesPositionEffect() {
  static const char * const names[] = {
    "UNDEFINED",
    "OPEN",
    "CLOSE",
  };
  return names;
}

inline const char *EnumNamePositionEffect(PositionEffect e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPositionEffect()[index];
}

enum class OrderStatus : int8_t {
  UNDEFINED = 0,
  SENT = 1,
  REJECTED = 2,
  ACCEPTED = 3,
  PENDING = 4,
  WORKING = 5,
  COMPLETED = 6,
  CANCELED = 7,
  MIN = UNDEFINED,
  MAX = CANCELED
};

inline const char * const *EnumNamesOrderStatus() {
  static const char * const names[] = {
    "UNDEFINED",
    "SENT",
    "REJECTED",
    "ACCEPTED",
    "PENDING",
    "WORKING",
    "COMPLETED",
    "CANCELED",
  };
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOrderStatus()[index];
}

enum class RequestType : int8_t {
  CREATE_ORDER = 0,
  MODIFY_ORDER = 1,
  CANCEL_ORDER = 2,
  MIN = CREATE_ORDER,
  MAX = CANCEL_ORDER
};

inline const char * const *EnumNamesRequestType() {
  static const char * const names[] = {
    "CREATE_ORDER",
    "MODIFY_ORDER",
    "CANCEL_ORDER",
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRequestType()[index];
}

enum class RequestStatus : int8_t {
  FORWARDED = 0,
  ACCEPTED = 1,
  REJECTED = 2,
  TIMEOUT = 3,
  MIN = FORWARDED,
  MAX = TIMEOUT
};

inline const char * const *EnumNamesRequestStatus() {
  static const char * const names[] = {
    "FORWARDED",
    "ACCEPTED",
    "REJECTED",
    "TIMEOUT",
  };
  return names;
}

inline const char *EnumNameRequestStatus(RequestStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRequestStatus()[index];
}

enum class Origin : int8_t {
  CLIENT = 0,
  GATEWAY = 1,
  BROKER = 2,
  EXCHANGE = 3,
  MIN = CLIENT,
  MAX = EXCHANGE
};

inline const char * const *EnumNamesOrigin() {
  static const char * const names[] = {
    "CLIENT",
    "GATEWAY",
    "BROKER",
    "EXCHANGE",
  };
  return names;
}

inline const char *EnumNameOrigin(Origin e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOrigin()[index];
}

enum class SecurityType : int8_t {
  UNDEFINED = 0,
  FX_SPOT = 1,
  FUTURES = 2,
  OPTION = 3,
  MIN = UNDEFINED,
  MAX = OPTION
};

inline const char * const *EnumNamesSecurityType() {
  static const char * const names[] = {
    "UNDEFINED",
    "FX_SPOT",
    "FUTURES",
    "OPTION",
  };
  return names;
}

inline const char *EnumNameSecurityType(SecurityType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSecurityType()[index];
}
enum class OptionType : int8_t {
  UNDEFINED = 0,
  CALL = 1,
  PUT = 2,
  MIN = UNDEFINED,
  MAX = PUT
};

inline const char * const *EnumNamesOptionType() {
  static const char * const names[] = {
    "UNDEFINED",
    "CALL",
    "PUT",
  };
  return names;
}

inline const char *EnumNameOptionType(OptionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOptionType()[index];
}

enum class Error : int8_t {
  NONE = 0,
  UNKNOWN = 1,
  GATEWAY_NOT_READY = 1,
  INVALID_ACCOUNT = 2,
  INVALID_EXCHANGE = 3,
  INVALID_SYMBOL = 4,
  INVALID_ORDER_TYPE = 5,
  INVALID_TIME_IN_FORCE = 6,
  INVALID_POSITION_EFFECT = 7,
  INVALID_ORDER_TEMPLATE = 8,
  NETWORK_ERROR = 9,
  UNKNOWN_ORDER_ID = 10,
  UNKNOWN_EXCHANGE_ORDER_ID = 11,
  MODIFY_ORDER_NOT_SUPPORTED = 12,
  INVALID_ORDER_ID = 13,
  MIN = NONE,
  MAX = INVALID_ORDER_ID
};

inline const char * const *EnumNamesError() {
  static const char * const names[] = {
    "NONE",
    "UNKNOWN",
    "GATEWAY_NOT_READY",
    "INVALID_ACCOUNT",
    "INVALID_EXCHANGE",
    "INVALID_SYMBOL",
    "INVALID_ORDER_TYPE",
    "INVALID_TIME_IN_FORCE",
    "INVALID_POSITION_EFFECT",
    "INVALID_ORDER_TEMPLATE",
    "NETWORK_ERROR",
    "UNKNOWN_ORDER_ID",
    "UNKNOWN_EXCHANGE_ORDER_ID",
    "MODIFY_ORDER_NOT_SUPPORTED",
    "INVALID_ORDER_ID",
  };
  return names;
}

inline const char *EnumNameError(Error e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesError()[index];
}

// transport

struct ROQ_PUBLIC MessageInfo final {
  uint8_t source;
  std::string_view source_name;
  uint64_t source_seqno;
  std::chrono::nanoseconds receive_time_utc;     // realtime clock
  std::chrono::nanoseconds receive_time;         // system clock
  std::chrono::nanoseconds source_send_time;     // system clock
  std::chrono::nanoseconds source_receive_time;  // system clock
  std::chrono::nanoseconds origin_create_time;   // system clock
  bool is_last;
  uint64_t opaque;
};

// messages

struct ROQ_PUBLIC Subscribe final {
  std::set<std::string> accounts;
  std::map<std::string, std::set<std::string> > symbols_by_exchange;
};

struct ROQ_PUBLIC DownloadBegin final {
  std::string_view account;
};

struct ROQ_PUBLIC DownloadEnd final {
  std::string_view account;
  uint32_t max_order_id;
};

struct ROQ_PUBLIC MarketDataStatus final {
  GatewayStatus status;
};

struct ROQ_PUBLIC OrderManagerStatus final {
  std::string_view account;
  GatewayStatus status;
};

struct ROQ_PUBLIC ReferenceData final {
  std::string_view exchange;
  std::string_view symbol;
  SecurityType security_type;
  std::string_view currency;
  std::string_view settlement_currency;
  std::string_view commission_currency;
  double tick_size;
  double limit_up;
  double limit_down;
  double multiplier;
  double min_trade_vol;
  OptionType option_type;
  std::string_view strike_currency;
  double strike_price;
};

struct ROQ_PUBLIC MarketStatus final {
  std::string_view exchange;
  std::string_view symbol;
  TradingStatus trading_status;
};

struct ROQ_PUBLIC MBPUpdate final {
  double price;
  double quantity;
};

static_assert(sizeof(MBPUpdate) == 16);

struct ROQ_PUBLIC MarketByPrice final {
  std::string_view exchange;
  std::string_view symbol;
  size_t bid_length;
  const MBPUpdate *bid;
  size_t ask_length;
  const MBPUpdate *ask;
  bool snapshot;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC Trade final {
  Side side;
  double price;
  double quantity;
  char trade_id[MAX_TRADE_ID_LENGTH + 1];
};

static_assert(sizeof(Trade) == 64);

struct ROQ_PUBLIC TradeSummary final {
  std::string_view exchange;
  std::string_view symbol;
  size_t trade_length;
  const Trade *trade;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC SessionStatistics final {
  std::string_view exchange;
  std::string_view symbol;
  double pre_open_interest;
  double pre_settlement_price;
  double pre_close_price;
  double highest_traded_price;
  double lowest_traded_price;
  double upper_limit_price;
  double lower_limit_price;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC DailyStatistics final {
  std::string_view exchange;
  std::string_view symbol;
  double open_price;
  double settlement_price;
  double close_price;
  double open_interest;
  std::chrono::nanoseconds exchange_time_utc;
};

struct ROQ_PUBLIC CreateOrder final {
  std::string_view account;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  double quantity;
  OrderType order_type;
  double price;
  TimeInForce time_in_force;
  PositionEffect position_effect;
  std::string_view order_template;
};

struct ROQ_PUBLIC ModifyOrder final {
  std::string_view account;
  uint32_t order_id;
  double quantity;  // total target quantity
  double price;
};

struct ROQ_PUBLIC CancelOrder final {
  std::string_view account;
  uint32_t order_id;
};

struct ROQ_PUBLIC OrderAck final {
  std::string_view account;
  uint32_t order_id;
  RequestType type;
  RequestStatus status;
  Origin origin;
  Error error;
  std::string_view text;
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC OrderUpdate final {
  std::string_view account;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  OrderStatus order_status;
  Side side;
  double price;
  double remaining_quantity;
  double traded_quantity;
  PositionEffect position_effect;
  std::string_view order_template;
  std::chrono::nanoseconds create_time_utc;
  std::chrono::nanoseconds update_time_utc;
  double commissions;
  uint32_t gateway_order_id;
  std::string_view external_order_id;
};

struct ROQ_PUBLIC TradeUpdate final {
  std::string_view account;
  uint32_t trade_id;
  uint32_t order_id;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  double quantity;
  double price;
  PositionEffect position_effect;
  std::string_view order_template;
  std::chrono::nanoseconds create_time_utc;
  std::chrono::nanoseconds update_time_utc;
  uint32_t gateway_order_id;
  uint32_t gateway_trade_id;
  std::string_view external_order_id;
  std::string_view external_trade_id;
};

struct ROQ_PUBLIC PositionUpdate final {
  std::string_view account;
  std::string_view exchange;
  std::string_view symbol;
  Side side;
  double position;
  // note! experimental
  uint32_t last_trade_id;
  double position_cost;
  double position_yesterday;
  double position_cost_yesterday;
};

struct ROQ_PUBLIC FundsUpdate final {
  std::string_view account;
  std::string_view currency;
  // note! experimental
  double balance;  // current available balance
  double hold;     // balance on hold due to clearing and/or settlement
};

struct ROQ_PUBLIC CustomMessage final {
  const void *message;
  size_t length;
};

// events

struct ROQ_PUBLIC StartEvent final {
};

struct ROQ_PUBLIC StopEvent final {
};

struct ROQ_PUBLIC TimerEvent final {
  std::chrono::nanoseconds now;  // monotonic clock
};

struct ROQ_PUBLIC ConnectionStatusEvent final {
  const MessageInfo& message_info;
  ConnectionStatus connection_status;
};

struct ROQ_PUBLIC BatchBeginEvent final {
  const MessageInfo& message_info;
};

struct ROQ_PUBLIC BatchEndEvent final {
  const MessageInfo& message_info;
};

struct ROQ_PUBLIC DownloadBeginEvent final {
  const MessageInfo& message_info;
  const DownloadBegin& download_begin;
};

struct ROQ_PUBLIC DownloadEndEvent final {
  const MessageInfo& message_info;
  const DownloadEnd& download_end;
};

struct ROQ_PUBLIC MarketDataStatusEvent final {
  const MessageInfo& message_info;
  const MarketDataStatus& market_data_status;
};

struct ROQ_PUBLIC OrderManagerStatusEvent final {
  const MessageInfo& message_info;
  const OrderManagerStatus& order_manager_status;
};

struct ROQ_PUBLIC ReferenceDataEvent final {
  const MessageInfo& message_info;
  const ReferenceData& reference_data;
};

struct ROQ_PUBLIC MarketStatusEvent final {
  const MessageInfo& message_info;
  const MarketStatus& market_status;
};

struct ROQ_PUBLIC MarketByPriceEvent final {
  const MessageInfo& message_info;
  const MarketByPrice& market_by_price;
};

struct ROQ_PUBLIC TradeSummaryEvent final {
  const MessageInfo& message_info;
  const TradeSummary& trade_summary;
};

struct ROQ_PUBLIC SessionStatisticsEvent final {
  const MessageInfo& message_info;
  const SessionStatistics& session_statistics;
};

struct ROQ_PUBLIC DailyStatisticsEvent final {
  const MessageInfo& message_info;
  const DailyStatistics& daily_statistics;
};

struct ROQ_PUBLIC PositionUpdateEvent final {
  const MessageInfo& message_info;
  const PositionUpdate& position_update;
};

struct ROQ_PUBLIC OrderUpdateEvent final {
  const MessageInfo& message_info;
  const OrderUpdate& order_update;
};

struct ROQ_PUBLIC TradeUpdateEvent final {
  const MessageInfo& message_info;
  const TradeUpdate& trade_update;
};

struct ROQ_PUBLIC SubscribeEvent final {
  const MessageInfo& message_info;
  const Subscribe& subscribe;
};

struct ROQ_PUBLIC CreateOrderEvent final {
  const MessageInfo& message_info;
  const CreateOrder& create_order;
};

struct ROQ_PUBLIC ModifyOrderEvent final {
  const MessageInfo& message_info;
  const ModifyOrder& modify_order;
};

struct ROQ_PUBLIC CancelOrderEvent final {
  const MessageInfo& message_info;
  const CancelOrder& cancel_order;
};

struct ROQ_PUBLIC OrderAckEvent final {
  const MessageInfo& message_info;
  const OrderAck& order_ack;
};

struct ROQ_PUBLIC FundsUpdateEvent final {
  const MessageInfo& message_info;
  const FundsUpdate& funds_update;
};

struct ROQ_PUBLIC CustomMessageEvent final {
  const MessageInfo& message_info;
  const CustomMessage& custom_message;
};

// exceptions

class ROQ_PUBLIC Exception : public std::exception {
};

class ROQ_PUBLIC RuntimeError : public Exception {
 public:
  explicit RuntimeError(const std::string_view& what)
      : _what(what) {
  }
  const char *what() const noexcept override {
    return _what.c_str();
  }

 private:
  std::string _what;
};

class ROQ_PUBLIC Fatal final : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC PermissionDenied : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC ConnectionRefused : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC FileDoesNotExist : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC NotReady : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC NotConnected : public RuntimeError {
  using RuntimeError::RuntimeError;
};

class ROQ_PUBLIC OrderNotLive : public RuntimeError {
  using RuntimeError::RuntimeError;
};

// utilities

struct ROQ_PUBLIC Layer final {
  double bid_price;
  double bid_quantity;
  double ask_price;
  double ask_quantity;
};

/* Interface used to implement an event generator.
 */
class ROQ_PUBLIC Generator {
 public:
  class ROQ_PUBLIC Dispatcher {
   public:
    virtual void operator()(const MarketDataStatusEvent&) = 0;
    virtual void operator()(const OrderManagerStatusEvent&) = 0;
    virtual void operator()(const ReferenceDataEvent&) = 0;
    virtual void operator()(const MarketStatusEvent&) = 0;
    virtual void operator()(const MarketByPriceEvent&) = 0;
    virtual void operator()(const TradeSummaryEvent&) = 0;
    virtual void operator()(const SessionStatisticsEvent&) = 0;
    virtual void operator()(const DailyStatisticsEvent&) = 0;
    virtual void operator()(const PositionUpdateEvent&) = 0;
    virtual void operator()(const FundsUpdateEvent&) = 0;
  };

  virtual ~Generator() {}
  virtual std::pair<bool, std::chrono::nanoseconds> fetch() = 0;
  virtual void dispatch(Dispatcher& dispatcher) = 0;
};

/* Interface used to implement order matching
 */
class ROQ_PUBLIC Matcher {
 public:
  class ROQ_PUBLIC Dispatcher {
   public:
    virtual void operator()(const DownloadBeginEvent&) = 0;
    virtual void operator()(const DownloadEndEvent&) = 0;
    virtual void operator()(const MarketDataStatusEvent&) = 0;
    virtual void operator()(const OrderManagerStatusEvent&) = 0;
    virtual void operator()(const ReferenceDataEvent&) = 0;
    virtual void operator()(const MarketStatusEvent&) = 0;
    virtual void operator()(const MarketByPriceEvent&) = 0;
    virtual void operator()(const TradeSummaryEvent&) = 0;
    virtual void operator()(const SessionStatisticsEvent&) = 0;
    virtual void operator()(const DailyStatisticsEvent&) = 0;
    virtual void operator()(const OrderAckEvent&) = 0;
    virtual void operator()(const OrderUpdateEvent&) = 0;
    virtual void operator()(const TradeUpdateEvent&) = 0;
    virtual void operator()(const PositionUpdateEvent&) = 0;
    virtual void operator()(const FundsUpdateEvent&) = 0;
  };

  virtual ~Matcher() {}

  virtual void dispatch(
      Dispatcher& dispatcher,
      std::chrono::nanoseconds next) = 0;

  virtual void operator()(const MarketDataStatusEvent&) = 0;
  virtual void operator()(const OrderManagerStatusEvent&) = 0;
  virtual void operator()(const ReferenceDataEvent&) = 0;
  virtual void operator()(const MarketStatusEvent&) = 0;
  virtual void operator()(const SessionStatisticsEvent&) = 0;
  virtual void operator()(const DailyStatisticsEvent&) = 0;
  virtual void operator()(const MarketByPriceEvent&) = 0;
  virtual void operator()(const TradeSummaryEvent&) = 0;
  virtual void operator()(const CreateOrderEvent&) = 0;
  virtual void operator()(const ModifyOrderEvent&) = 0;
  virtual void operator()(const CancelOrderEvent&) = 0;
  virtual void operator()(const PositionUpdateEvent&) = 0;
  virtual void operator()(const FundsUpdateEvent&) = 0;
};

struct ROQ_PUBLIC Account {
  uint8_t id;
  std::string name;
  std::string login;
  std::string password;
  std::string secret;
  std::unordered_map<
    std::string,
    std::unordered_set<std::string> > symbols;
};

struct ROQ_PUBLIC User {
  uint8_t id;
  std::string name;
  std::string password;
  std::unordered_set<std::string> accounts;
  std::unordered_map<
    std::string,
    std::unordered_set<std::string> > symbols;
  struct Limits final {
    struct CreateOrder final {
      uint32_t max;
      std::chrono::seconds monitor_period;
      std::chrono::seconds ban_period;
    } create_order;
  } limits;
};

// utilities

inline bool is_complete(const RequestStatus& status) {
  switch (status) {
    case RequestStatus::FORWARDED:
      return false;
    case RequestStatus::ACCEPTED:
    case RequestStatus::REJECTED:
    case RequestStatus::TIMEOUT:
      return true;
    default:
      // TODO(thraneh): should throw
      return true;
  }
}

inline Side invert(Side side) {
  switch (side) {
    case Side::BUY: return Side::SELL;
    case Side::SELL: return Side::BUY;
    default: return side;
  }
}

inline int sign(Side side) {
  switch (side) {
    case Side::BUY: return 1;
    case Side::SELL: return -1;
    default: return 0;
  }
}

inline std::string_view get_trade_id_as_string_view(
    const Trade& trade) {
  auto null_ptr = std::memchr(
      trade.trade_id,
      '\0',
      sizeof(trade.trade_id));
  auto length = null_ptr
    ? static_cast<size_t>(
          reinterpret_cast<const char *>(null_ptr) - trade.trade_id)
    : sizeof(trade.trade_id);
  return std::string_view(trade.trade_id, length);
}

}  // namespace roq
