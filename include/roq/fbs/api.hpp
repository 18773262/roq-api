// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
#define FLATBUFFERS_GENERATED_API_ROQ_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace roq {
namespace fbs {

struct Fill;
struct FillBuilder;

struct Layer;
struct LayerBuilder;

struct MBOUpdate;
struct MBOUpdateBuilder;

struct MBPUpdate;
struct MBPUpdateBuilder;

struct Measurement;
struct MeasurementBuilder;

struct Parameter;
struct ParameterBuilder;

struct Statistics;
struct StatisticsBuilder;

struct Trade;
struct TradeBuilder;

struct CancelAllOrders;
struct CancelAllOrdersBuilder;

struct CancelOrder;
struct CancelOrderBuilder;

struct CreateOrder;
struct CreateOrderBuilder;

struct CustomMetrics;
struct CustomMetricsBuilder;

struct CustomMetricsUpdate;
struct CustomMetricsUpdateBuilder;

struct DownloadBegin;
struct DownloadBeginBuilder;

struct DownloadEnd;
struct DownloadEndBuilder;

struct ExternalLatency;
struct ExternalLatencyBuilder;

struct FundsUpdate;
struct FundsUpdateBuilder;

struct GatewaySettings;
struct GatewaySettingsBuilder;

struct GatewayStatus;
struct GatewayStatusBuilder;

struct MarketByOrderUpdate;
struct MarketByOrderUpdateBuilder;

struct MarketByPriceUpdate;
struct MarketByPriceUpdateBuilder;

struct MarketStatus;
struct MarketStatusBuilder;

struct ModifyOrder;
struct ModifyOrderBuilder;

struct OrderAck;
struct OrderAckBuilder;

struct OrderUpdate;
struct OrderUpdateBuilder;

struct ParametersUpdate;
struct ParametersUpdateBuilder;

struct PositionUpdate;
struct PositionUpdateBuilder;

struct RateLimitTrigger;
struct RateLimitTriggerBuilder;

struct ReferenceData;
struct ReferenceDataBuilder;

struct StatisticsUpdate;
struct StatisticsUpdateBuilder;

struct StreamStatus;
struct StreamStatusBuilder;

struct TopOfBook;
struct TopOfBookBuilder;

struct TradeSummary;
struct TradeSummaryBuilder;

struct TradeUpdate;
struct TradeUpdateBuilder;

struct Handshake;
struct HandshakeBuilder;

struct HandshakeAck;
struct HandshakeAckBuilder;

struct Subscribe;
struct SubscribeBuilder;

struct BatchBegin;
struct BatchBeginBuilder;

struct BatchEnd;
struct BatchEndBuilder;

struct SourceInfo;
struct SourceInfoBuilder;

struct Event;
struct EventBuilder;

enum class BufferCapacity : uint8_t {
  Undefined = 0,
  Empty = 1,
  LowWaterMark = 2,
  HighWaterMark = 3,
  Full = 4,
  MIN = Undefined,
  MAX = Full
};

inline const BufferCapacity (&EnumValuesBufferCapacity())[5] {
  static const BufferCapacity values[] = {
    BufferCapacity::Undefined,
    BufferCapacity::Empty,
    BufferCapacity::LowWaterMark,
    BufferCapacity::HighWaterMark,
    BufferCapacity::Full
  };
  return values;
}

inline const char * const *EnumNamesBufferCapacity() {
  static const char * const names[6] = {
    "Undefined",
    "Empty",
    "LowWaterMark",
    "HighWaterMark",
    "Full",
    nullptr
  };
  return names;
}

inline const char *EnumNameBufferCapacity(BufferCapacity e) {
  if (flatbuffers::IsOutRange(e, BufferCapacity::Undefined, BufferCapacity::Full)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBufferCapacity()[index];
}

enum class Category : uint8_t {
  Undefined = 0,
  Public = 1,
  Private = 2,
  MIN = Undefined,
  MAX = Private
};

inline const Category (&EnumValuesCategory())[3] {
  static const Category values[] = {
    Category::Undefined,
    Category::Public,
    Category::Private
  };
  return values;
}

inline const char * const *EnumNamesCategory() {
  static const char * const names[4] = {
    "Undefined",
    "Public",
    "Private",
    nullptr
  };
  return names;
}

inline const char *EnumNameCategory(Category e) {
  if (flatbuffers::IsOutRange(e, Category::Undefined, Category::Private)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCategory()[index];
}

enum class ConnectionStatus : uint8_t {
  Undefined = 0,
  Disconnected = 1,
  Connecting = 2,
  LoginSent = 3,
  Downloading = 4,
  Ready = 5,
  LoggedOut = 6,
  MIN = Undefined,
  MAX = LoggedOut
};

inline const ConnectionStatus (&EnumValuesConnectionStatus())[7] {
  static const ConnectionStatus values[] = {
    ConnectionStatus::Undefined,
    ConnectionStatus::Disconnected,
    ConnectionStatus::Connecting,
    ConnectionStatus::LoginSent,
    ConnectionStatus::Downloading,
    ConnectionStatus::Ready,
    ConnectionStatus::LoggedOut
  };
  return values;
}

inline const char * const *EnumNamesConnectionStatus() {
  static const char * const names[8] = {
    "Undefined",
    "Disconnected",
    "Connecting",
    "LoginSent",
    "Downloading",
    "Ready",
    "LoggedOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  if (flatbuffers::IsOutRange(e, ConnectionStatus::Undefined, ConnectionStatus::LoggedOut)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionStatus()[index];
}

enum class Decimals : uint8_t {
  Undefined = 0,
  _0 = 1,
  _1 = 2,
  _2 = 3,
  _3 = 4,
  _4 = 5,
  _5 = 6,
  _6 = 7,
  _7 = 8,
  _8 = 9,
  _9 = 10,
  _10 = 11,
  _11 = 12,
  _12 = 13,
  _13 = 14,
  _14 = 15,
  _15 = 16,
  MIN = Undefined,
  MAX = _15
};

inline const Decimals (&EnumValuesDecimals())[17] {
  static const Decimals values[] = {
    Decimals::Undefined,
    Decimals::_0,
    Decimals::_1,
    Decimals::_2,
    Decimals::_3,
    Decimals::_4,
    Decimals::_5,
    Decimals::_6,
    Decimals::_7,
    Decimals::_8,
    Decimals::_9,
    Decimals::_10,
    Decimals::_11,
    Decimals::_12,
    Decimals::_13,
    Decimals::_14,
    Decimals::_15
  };
  return values;
}

inline const char * const *EnumNamesDecimals() {
  static const char * const names[18] = {
    "Undefined",
    "_0",
    "_1",
    "_2",
    "_3",
    "_4",
    "_5",
    "_6",
    "_7",
    "_8",
    "_9",
    "_10",
    "_11",
    "_12",
    "_13",
    "_14",
    "_15",
    nullptr
  };
  return names;
}

inline const char *EnumNameDecimals(Decimals e) {
  if (flatbuffers::IsOutRange(e, Decimals::Undefined, Decimals::_15)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDecimals()[index];
}

enum class Encoding : uint32_t {
  Undefined = 0,
  FIX = 1,
  JSON = 2,
  SBE = 4,
  FBS = 8,
  MIN = Undefined,
  MAX = FBS
};

inline const Encoding (&EnumValuesEncoding())[5] {
  static const Encoding values[] = {
    Encoding::Undefined,
    Encoding::FIX,
    Encoding::JSON,
    Encoding::SBE,
    Encoding::FBS
  };
  return values;
}

inline const char * const *EnumNamesEncoding() {
  static const char * const names[10] = {
    "Undefined",
    "FIX",
    "JSON",
    "",
    "SBE",
    "",
    "",
    "",
    "FBS",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncoding(Encoding e) {
  if (flatbuffers::IsOutRange(e, Encoding::Undefined, Encoding::FBS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncoding()[index];
}

enum class Error : uint8_t {
  Undefined = 0,
  Unknown = 1,
  NotSupported = 2,
  InvalidAccount = 3,
  InvalidOrderId = 4,
  InvalidExchange = 5,
  InvalidSymbol = 6,
  InvalidSide = 7,
  InvalidPositionEffect = 8,
  InvalidQuantity = 9,
  InvalidMaxShowQuantity = 10,
  InvalidOrderType = 11,
  InvalidTimeInForce = 12,
  InvalidExecutionInstruction = 13,
  InvalidOrderTemplate = 14,
  InvalidPrice = 15,
  InvalidStopPrice = 16,
  InvalidRoutingId = 17,
  InvalidRequestVersion = 18,
  InvalidRequestId = 19,
  InvalidRequestType = 20,
  InvalidRequestStatus = 21,
  InvalidRequestArgs = 22,
  UnknownExternalOrderId = 23,
  NotAuthorized = 24,
  RequestRateLimitReached = 25,
  GatewayNotReady = 26,
  NetworkError = 27,
  Timeout = 28,
  ParseError = 29,
  ModifyHasNoEffect = 30,
  TooLateToModifyOrCancel = 31,
  ConditionalRequestHasFailed = 32,
  UnknownOrderId = 33,
  InsufficientFunds = 34,
  MIN = Undefined,
  MAX = InsufficientFunds
};

inline const Error (&EnumValuesError())[35] {
  static const Error values[] = {
    Error::Undefined,
    Error::Unknown,
    Error::NotSupported,
    Error::InvalidAccount,
    Error::InvalidOrderId,
    Error::InvalidExchange,
    Error::InvalidSymbol,
    Error::InvalidSide,
    Error::InvalidPositionEffect,
    Error::InvalidQuantity,
    Error::InvalidMaxShowQuantity,
    Error::InvalidOrderType,
    Error::InvalidTimeInForce,
    Error::InvalidExecutionInstruction,
    Error::InvalidOrderTemplate,
    Error::InvalidPrice,
    Error::InvalidStopPrice,
    Error::InvalidRoutingId,
    Error::InvalidRequestVersion,
    Error::InvalidRequestId,
    Error::InvalidRequestType,
    Error::InvalidRequestStatus,
    Error::InvalidRequestArgs,
    Error::UnknownExternalOrderId,
    Error::NotAuthorized,
    Error::RequestRateLimitReached,
    Error::GatewayNotReady,
    Error::NetworkError,
    Error::Timeout,
    Error::ParseError,
    Error::ModifyHasNoEffect,
    Error::TooLateToModifyOrCancel,
    Error::ConditionalRequestHasFailed,
    Error::UnknownOrderId,
    Error::InsufficientFunds
  };
  return values;
}

inline const char * const *EnumNamesError() {
  static const char * const names[36] = {
    "Undefined",
    "Unknown",
    "NotSupported",
    "InvalidAccount",
    "InvalidOrderId",
    "InvalidExchange",
    "InvalidSymbol",
    "InvalidSide",
    "InvalidPositionEffect",
    "InvalidQuantity",
    "InvalidMaxShowQuantity",
    "InvalidOrderType",
    "InvalidTimeInForce",
    "InvalidExecutionInstruction",
    "InvalidOrderTemplate",
    "InvalidPrice",
    "InvalidStopPrice",
    "InvalidRoutingId",
    "InvalidRequestVersion",
    "InvalidRequestId",
    "InvalidRequestType",
    "InvalidRequestStatus",
    "InvalidRequestArgs",
    "UnknownExternalOrderId",
    "NotAuthorized",
    "RequestRateLimitReached",
    "GatewayNotReady",
    "NetworkError",
    "Timeout",
    "ParseError",
    "ModifyHasNoEffect",
    "TooLateToModifyOrCancel",
    "ConditionalRequestHasFailed",
    "UnknownOrderId",
    "InsufficientFunds",
    nullptr
  };
  return names;
}

inline const char *EnumNameError(Error e) {
  if (flatbuffers::IsOutRange(e, Error::Undefined, Error::InsufficientFunds)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesError()[index];
}

enum class ExecutionInstruction : uint8_t {
  Undefined = 0,
  ParticipateDoNotInitiate = 1,
  CancelIfNotBest = 2,
  DoNotIncrease = 4,
  DoNotReduce = 8,
  MIN = Undefined,
  MAX = DoNotReduce
};

inline const ExecutionInstruction (&EnumValuesExecutionInstruction())[5] {
  static const ExecutionInstruction values[] = {
    ExecutionInstruction::Undefined,
    ExecutionInstruction::ParticipateDoNotInitiate,
    ExecutionInstruction::CancelIfNotBest,
    ExecutionInstruction::DoNotIncrease,
    ExecutionInstruction::DoNotReduce
  };
  return values;
}

inline const char * const *EnumNamesExecutionInstruction() {
  static const char * const names[10] = {
    "Undefined",
    "ParticipateDoNotInitiate",
    "CancelIfNotBest",
    "",
    "DoNotIncrease",
    "",
    "",
    "",
    "DoNotReduce",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutionInstruction(ExecutionInstruction e) {
  if (flatbuffers::IsOutRange(e, ExecutionInstruction::Undefined, ExecutionInstruction::DoNotReduce)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutionInstruction()[index];
}

enum class Liquidity : uint8_t {
  Undefined = 0,
  Maker = 1,
  Taker = 2,
  MIN = Undefined,
  MAX = Taker
};

inline const Liquidity (&EnumValuesLiquidity())[3] {
  static const Liquidity values[] = {
    Liquidity::Undefined,
    Liquidity::Maker,
    Liquidity::Taker
  };
  return values;
}

inline const char * const *EnumNamesLiquidity() {
  static const char * const names[4] = {
    "Undefined",
    "Maker",
    "Taker",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiquidity(Liquidity e) {
  if (flatbuffers::IsOutRange(e, Liquidity::Undefined, Liquidity::Taker)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLiquidity()[index];
}

enum class OptionType : uint8_t {
  Undefined = 0,
  Call = 1,
  Put = 2,
  MIN = Undefined,
  MAX = Put
};

inline const OptionType (&EnumValuesOptionType())[3] {
  static const OptionType values[] = {
    OptionType::Undefined,
    OptionType::Call,
    OptionType::Put
  };
  return values;
}

inline const char * const *EnumNamesOptionType() {
  static const char * const names[4] = {
    "Undefined",
    "Call",
    "Put",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionType(OptionType e) {
  if (flatbuffers::IsOutRange(e, OptionType::Undefined, OptionType::Put)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionType()[index];
}

enum class OrderStatus : uint8_t {
  Undefined = 0,
  Sent = 1,
  Accepted = 2,
  Suspended = 3,
  Working = 4,
  Stopped = 5,
  Completed = 6,
  Expired = 7,
  Canceled = 8,
  Rejected = 9,
  MIN = Undefined,
  MAX = Rejected
};

inline const OrderStatus (&EnumValuesOrderStatus())[10] {
  static const OrderStatus values[] = {
    OrderStatus::Undefined,
    OrderStatus::Sent,
    OrderStatus::Accepted,
    OrderStatus::Suspended,
    OrderStatus::Working,
    OrderStatus::Stopped,
    OrderStatus::Completed,
    OrderStatus::Expired,
    OrderStatus::Canceled,
    OrderStatus::Rejected
  };
  return values;
}

inline const char * const *EnumNamesOrderStatus() {
  static const char * const names[11] = {
    "Undefined",
    "Sent",
    "Accepted",
    "Suspended",
    "Working",
    "Stopped",
    "Completed",
    "Expired",
    "Canceled",
    "Rejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  if (flatbuffers::IsOutRange(e, OrderStatus::Undefined, OrderStatus::Rejected)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderStatus()[index];
}

enum class OrderType : uint8_t {
  Undefined = 0,
  Market = 1,
  Limit = 2,
  MIN = Undefined,
  MAX = Limit
};

inline const OrderType (&EnumValuesOrderType())[3] {
  static const OrderType values[] = {
    OrderType::Undefined,
    OrderType::Market,
    OrderType::Limit
  };
  return values;
}

inline const char * const *EnumNamesOrderType() {
  static const char * const names[4] = {
    "Undefined",
    "Market",
    "Limit",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderType(OrderType e) {
  if (flatbuffers::IsOutRange(e, OrderType::Undefined, OrderType::Limit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderType()[index];
}

enum class Origin : uint8_t {
  Undefined = 0,
  Client = 1,
  Gateway = 2,
  Broker = 3,
  Exchange = 4,
  MIN = Undefined,
  MAX = Exchange
};

inline const Origin (&EnumValuesOrigin())[5] {
  static const Origin values[] = {
    Origin::Undefined,
    Origin::Client,
    Origin::Gateway,
    Origin::Broker,
    Origin::Exchange
  };
  return values;
}

inline const char * const *EnumNamesOrigin() {
  static const char * const names[6] = {
    "Undefined",
    "Client",
    "Gateway",
    "Broker",
    "Exchange",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrigin(Origin e) {
  if (flatbuffers::IsOutRange(e, Origin::Undefined, Origin::Exchange)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrigin()[index];
}

enum class PositionEffect : uint8_t {
  Undefined = 0,
  Open = 1,
  Close = 2,
  MIN = Undefined,
  MAX = Close
};

inline const PositionEffect (&EnumValuesPositionEffect())[3] {
  static const PositionEffect values[] = {
    PositionEffect::Undefined,
    PositionEffect::Open,
    PositionEffect::Close
  };
  return values;
}

inline const char * const *EnumNamesPositionEffect() {
  static const char * const names[4] = {
    "Undefined",
    "Open",
    "Close",
    nullptr
  };
  return names;
}

inline const char *EnumNamePositionEffect(PositionEffect e) {
  if (flatbuffers::IsOutRange(e, PositionEffect::Undefined, PositionEffect::Close)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionEffect()[index];
}

enum class Protocol : uint8_t {
  Undefined = 0,
  FIX = 1,
  WS = 2,
  HTTP = 3,
  SBE = 4,
  ROQ = 5,
  MIN = Undefined,
  MAX = ROQ
};

inline const Protocol (&EnumValuesProtocol())[6] {
  static const Protocol values[] = {
    Protocol::Undefined,
    Protocol::FIX,
    Protocol::WS,
    Protocol::HTTP,
    Protocol::SBE,
    Protocol::ROQ
  };
  return values;
}

inline const char * const *EnumNamesProtocol() {
  static const char * const names[7] = {
    "Undefined",
    "FIX",
    "WS",
    "HTTP",
    "SBE",
    "ROQ",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtocol(Protocol e) {
  if (flatbuffers::IsOutRange(e, Protocol::Undefined, Protocol::ROQ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtocol()[index];
}

enum class RequestIdType : uint8_t {
  Undefined = 0,
  Base64 = 1,
  Base32 = 2,
  Simple = 3,
  UUID = 4,
  MIN = Undefined,
  MAX = UUID
};

inline const RequestIdType (&EnumValuesRequestIdType())[5] {
  static const RequestIdType values[] = {
    RequestIdType::Undefined,
    RequestIdType::Base64,
    RequestIdType::Base32,
    RequestIdType::Simple,
    RequestIdType::UUID
  };
  return values;
}

inline const char * const *EnumNamesRequestIdType() {
  static const char * const names[6] = {
    "Undefined",
    "Base64",
    "Base32",
    "Simple",
    "UUID",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestIdType(RequestIdType e) {
  if (flatbuffers::IsOutRange(e, RequestIdType::Undefined, RequestIdType::UUID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestIdType()[index];
}

enum class RequestStatus : uint8_t {
  Undefined = 0,
  Forwarded = 1,
  Accepted = 2,
  Rejected = 3,
  Disconnected = 4,
  Timeout = 5,
  Failed = 6,
  Error = 7,
  MIN = Undefined,
  MAX = Error
};

inline const RequestStatus (&EnumValuesRequestStatus())[8] {
  static const RequestStatus values[] = {
    RequestStatus::Undefined,
    RequestStatus::Forwarded,
    RequestStatus::Accepted,
    RequestStatus::Rejected,
    RequestStatus::Disconnected,
    RequestStatus::Timeout,
    RequestStatus::Failed,
    RequestStatus::Error
  };
  return values;
}

inline const char * const *EnumNamesRequestStatus() {
  static const char * const names[9] = {
    "Undefined",
    "Forwarded",
    "Accepted",
    "Rejected",
    "Disconnected",
    "Timeout",
    "Failed",
    "Error",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestStatus(RequestStatus e) {
  if (flatbuffers::IsOutRange(e, RequestStatus::Undefined, RequestStatus::Error)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestStatus()[index];
}

enum class RequestType : uint8_t {
  Undefined = 0,
  CreateOrder = 1,
  ModifyOrder = 2,
  CancelOrder = 3,
  MIN = Undefined,
  MAX = CancelOrder
};

inline const RequestType (&EnumValuesRequestType())[4] {
  static const RequestType values[] = {
    RequestType::Undefined,
    RequestType::CreateOrder,
    RequestType::ModifyOrder,
    RequestType::CancelOrder
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[5] = {
    "Undefined",
    "CreateOrder",
    "ModifyOrder",
    "CancelOrder",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType::Undefined, RequestType::CancelOrder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum class SecurityType : uint8_t {
  Undefined = 0,
  Spot = 1,
  Futures = 2,
  Option = 3,
  Swap = 4,
  MIN = Undefined,
  MAX = Swap
};

inline const SecurityType (&EnumValuesSecurityType())[5] {
  static const SecurityType values[] = {
    SecurityType::Undefined,
    SecurityType::Spot,
    SecurityType::Futures,
    SecurityType::Option,
    SecurityType::Swap
  };
  return values;
}

inline const char * const *EnumNamesSecurityType() {
  static const char * const names[6] = {
    "Undefined",
    "Spot",
    "Futures",
    "Option",
    "Swap",
    nullptr
  };
  return names;
}

inline const char *EnumNameSecurityType(SecurityType e) {
  if (flatbuffers::IsOutRange(e, SecurityType::Undefined, SecurityType::Swap)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSecurityType()[index];
}

enum class Side : uint8_t {
  Undefined = 0,
  Buy = 1,
  Sell = 2,
  MIN = Undefined,
  MAX = Sell
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {
    Side::Undefined,
    Side::Buy,
    Side::Sell
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[4] = {
    "Undefined",
    "Buy",
    "Sell",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (flatbuffers::IsOutRange(e, Side::Undefined, Side::Sell)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum class StatisticsType : uint8_t {
  Undefined = 0,
  OpenPrice = 1,
  SettlementPrice = 2,
  ClosePrice = 3,
  OpenInterest = 4,
  PreOpenInterest = 5,
  PreSettlementPrice = 6,
  PreClosePrice = 7,
  HighestTradedPrice = 8,
  LowestTradedPrice = 9,
  UpperLimitPrice = 10,
  LowerLimitPrice = 11,
  IndexValue = 12,
  MarginRate = 13,
  FundingRate = 14,
  FundingRatePrediction = 15,
  TradeVolume = 16,
  MIN = Undefined,
  MAX = TradeVolume
};

inline const StatisticsType (&EnumValuesStatisticsType())[17] {
  static const StatisticsType values[] = {
    StatisticsType::Undefined,
    StatisticsType::OpenPrice,
    StatisticsType::SettlementPrice,
    StatisticsType::ClosePrice,
    StatisticsType::OpenInterest,
    StatisticsType::PreOpenInterest,
    StatisticsType::PreSettlementPrice,
    StatisticsType::PreClosePrice,
    StatisticsType::HighestTradedPrice,
    StatisticsType::LowestTradedPrice,
    StatisticsType::UpperLimitPrice,
    StatisticsType::LowerLimitPrice,
    StatisticsType::IndexValue,
    StatisticsType::MarginRate,
    StatisticsType::FundingRate,
    StatisticsType::FundingRatePrediction,
    StatisticsType::TradeVolume
  };
  return values;
}

inline const char * const *EnumNamesStatisticsType() {
  static const char * const names[18] = {
    "Undefined",
    "OpenPrice",
    "SettlementPrice",
    "ClosePrice",
    "OpenInterest",
    "PreOpenInterest",
    "PreSettlementPrice",
    "PreClosePrice",
    "HighestTradedPrice",
    "LowestTradedPrice",
    "UpperLimitPrice",
    "LowerLimitPrice",
    "IndexValue",
    "MarginRate",
    "FundingRate",
    "FundingRatePrediction",
    "TradeVolume",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatisticsType(StatisticsType e) {
  if (flatbuffers::IsOutRange(e, StatisticsType::Undefined, StatisticsType::TradeVolume)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatisticsType()[index];
}

enum class SupportType : uint32_t {
  Undefined = 0,
  ReferenceData = 1,
  MarketStatus = 2,
  TopOfBook = 4,
  MarketByPrice = 8,
  MarketByOrder = 16,
  TradeSummary = 32,
  Statistics = 64,
  CreateOrder = 65536,
  ModifyOrder = 131072,
  CancelOrder = 262144,
  OrderAck = 524288,
  Order = 1048576,
  Trade = 2097152,
  Position = 4194304,
  OrderState = 8388608,
  Funds = 268435456,
  MIN = Undefined,
  MAX = Funds
};

inline const SupportType (&EnumValuesSupportType())[17] {
  static const SupportType values[] = {
    SupportType::Undefined,
    SupportType::ReferenceData,
    SupportType::MarketStatus,
    SupportType::TopOfBook,
    SupportType::MarketByPrice,
    SupportType::MarketByOrder,
    SupportType::TradeSummary,
    SupportType::Statistics,
    SupportType::CreateOrder,
    SupportType::ModifyOrder,
    SupportType::CancelOrder,
    SupportType::OrderAck,
    SupportType::Order,
    SupportType::Trade,
    SupportType::Position,
    SupportType::OrderState,
    SupportType::Funds
  };
  return values;
}

inline const char *EnumNameSupportType(SupportType e) {
  switch (e) {
    case SupportType::Undefined: return "Undefined";
    case SupportType::ReferenceData: return "ReferenceData";
    case SupportType::MarketStatus: return "MarketStatus";
    case SupportType::TopOfBook: return "TopOfBook";
    case SupportType::MarketByPrice: return "MarketByPrice";
    case SupportType::MarketByOrder: return "MarketByOrder";
    case SupportType::TradeSummary: return "TradeSummary";
    case SupportType::Statistics: return "Statistics";
    case SupportType::CreateOrder: return "CreateOrder";
    case SupportType::ModifyOrder: return "ModifyOrder";
    case SupportType::CancelOrder: return "CancelOrder";
    case SupportType::OrderAck: return "OrderAck";
    case SupportType::Order: return "Order";
    case SupportType::Trade: return "Trade";
    case SupportType::Position: return "Position";
    case SupportType::OrderState: return "OrderState";
    case SupportType::Funds: return "Funds";
    default: return "";
  }
}

enum class TimeInForce : uint8_t {
  Undefined = 0,
  GFD = 1,
  GTC = 2,
  OPG = 3,
  IOC = 4,
  FOK = 5,
  GTX = 6,
  GTD = 7,
  AT_THE_CLOSE = 8,
  GOOD_THROUGH_CROSSING = 9,
  AT_CROSSING = 10,
  GOOD_FOR_TIME = 11,
  GFA = 12,
  GFM = 13,
  MIN = Undefined,
  MAX = GFM
};

inline const TimeInForce (&EnumValuesTimeInForce())[14] {
  static const TimeInForce values[] = {
    TimeInForce::Undefined,
    TimeInForce::GFD,
    TimeInForce::GTC,
    TimeInForce::OPG,
    TimeInForce::IOC,
    TimeInForce::FOK,
    TimeInForce::GTX,
    TimeInForce::GTD,
    TimeInForce::AT_THE_CLOSE,
    TimeInForce::GOOD_THROUGH_CROSSING,
    TimeInForce::AT_CROSSING,
    TimeInForce::GOOD_FOR_TIME,
    TimeInForce::GFA,
    TimeInForce::GFM
  };
  return values;
}

inline const char * const *EnumNamesTimeInForce() {
  static const char * const names[15] = {
    "Undefined",
    "GFD",
    "GTC",
    "OPG",
    "IOC",
    "FOK",
    "GTX",
    "GTD",
    "AT_THE_CLOSE",
    "GOOD_THROUGH_CROSSING",
    "AT_CROSSING",
    "GOOD_FOR_TIME",
    "GFA",
    "GFM",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  if (flatbuffers::IsOutRange(e, TimeInForce::Undefined, TimeInForce::GFM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeInForce()[index];
}

enum class TradingStatus : uint8_t {
  Undefined = 0,
  StartOfDay = 1,
  PreOpen = 2,
  PreOpenNoCancel = 3,
  PreOpenFreeze = 4,
  Open = 5,
  FastMarket = 6,
  Halt = 7,
  CloseNotFinal = 8,
  PreClose = 9,
  PreCloseNoCancel = 10,
  PreCloseFreeze = 11,
  Close = 12,
  PostClose = 13,
  EndOfDay = 14,
  MIN = Undefined,
  MAX = EndOfDay
};

inline const TradingStatus (&EnumValuesTradingStatus())[15] {
  static const TradingStatus values[] = {
    TradingStatus::Undefined,
    TradingStatus::StartOfDay,
    TradingStatus::PreOpen,
    TradingStatus::PreOpenNoCancel,
    TradingStatus::PreOpenFreeze,
    TradingStatus::Open,
    TradingStatus::FastMarket,
    TradingStatus::Halt,
    TradingStatus::CloseNotFinal,
    TradingStatus::PreClose,
    TradingStatus::PreCloseNoCancel,
    TradingStatus::PreCloseFreeze,
    TradingStatus::Close,
    TradingStatus::PostClose,
    TradingStatus::EndOfDay
  };
  return values;
}

inline const char * const *EnumNamesTradingStatus() {
  static const char * const names[16] = {
    "Undefined",
    "StartOfDay",
    "PreOpen",
    "PreOpenNoCancel",
    "PreOpenFreeze",
    "Open",
    "FastMarket",
    "Halt",
    "CloseNotFinal",
    "PreClose",
    "PreCloseNoCancel",
    "PreCloseFreeze",
    "Close",
    "PostClose",
    "EndOfDay",
    nullptr
  };
  return names;
}

inline const char *EnumNameTradingStatus(TradingStatus e) {
  if (flatbuffers::IsOutRange(e, TradingStatus::Undefined, TradingStatus::EndOfDay)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTradingStatus()[index];
}

enum class Transport : uint8_t {
  Undefined = 0,
  TCP = 1,
  UDP = 2,
  MIN = Undefined,
  MAX = UDP
};

inline const Transport (&EnumValuesTransport())[3] {
  static const Transport values[] = {
    Transport::Undefined,
    Transport::TCP,
    Transport::UDP
  };
  return values;
}

inline const char * const *EnumNamesTransport() {
  static const char * const names[4] = {
    "Undefined",
    "TCP",
    "UDP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTransport(Transport e) {
  if (flatbuffers::IsOutRange(e, Transport::Undefined, Transport::UDP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTransport()[index];
}

enum class UpdateAction : uint8_t {
  Undefined = 0,
  New = 1,
  Change = 2,
  Delete = 3,
  MIN = Undefined,
  MAX = Delete
};

inline const UpdateAction (&EnumValuesUpdateAction())[4] {
  static const UpdateAction values[] = {
    UpdateAction::Undefined,
    UpdateAction::New,
    UpdateAction::Change,
    UpdateAction::Delete
  };
  return values;
}

inline const char * const *EnumNamesUpdateAction() {
  static const char * const names[5] = {
    "Undefined",
    "New",
    "Change",
    "Delete",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateAction(UpdateAction e) {
  if (flatbuffers::IsOutRange(e, UpdateAction::Undefined, UpdateAction::Delete)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateAction()[index];
}

enum class UpdateReason : uint8_t {
  Undefined = 0,
  Created = 1,
  Modified = 2,
  Canceled = 3,
  Filled = 4,
  MIN = Undefined,
  MAX = Filled
};

inline const UpdateReason (&EnumValuesUpdateReason())[5] {
  static const UpdateReason values[] = {
    UpdateReason::Undefined,
    UpdateReason::Created,
    UpdateReason::Modified,
    UpdateReason::Canceled,
    UpdateReason::Filled
  };
  return values;
}

inline const char * const *EnumNamesUpdateReason() {
  static const char * const names[6] = {
    "Undefined",
    "Created",
    "Modified",
    "Canceled",
    "Filled",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateReason(UpdateReason e) {
  if (flatbuffers::IsOutRange(e, UpdateReason::Undefined, UpdateReason::Filled)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateReason()[index];
}

enum class UpdateType : uint8_t {
  Undefined = 0,
  Snapshot = 1,
  Incremental = 2,
  Stale = 3,
  MIN = Undefined,
  MAX = Stale
};

inline const UpdateType (&EnumValuesUpdateType())[4] {
  static const UpdateType values[] = {
    UpdateType::Undefined,
    UpdateType::Snapshot,
    UpdateType::Incremental,
    UpdateType::Stale
  };
  return values;
}

inline const char * const *EnumNamesUpdateType() {
  static const char * const names[5] = {
    "Undefined",
    "Snapshot",
    "Incremental",
    "Stale",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateType(UpdateType e) {
  if (flatbuffers::IsOutRange(e, UpdateType::Undefined, UpdateType::Stale)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateType()[index];
}

enum class RateLimitType : uint8_t {
  Undefined = 0,
  OrderAction = 1,
  CreateOrder = 2,
  MIN = Undefined,
  MAX = CreateOrder
};

inline const RateLimitType (&EnumValuesRateLimitType())[3] {
  static const RateLimitType values[] = {
    RateLimitType::Undefined,
    RateLimitType::OrderAction,
    RateLimitType::CreateOrder
  };
  return values;
}

inline const char * const *EnumNamesRateLimitType() {
  static const char * const names[4] = {
    "Undefined",
    "OrderAction",
    "CreateOrder",
    nullptr
  };
  return names;
}

inline const char *EnumNameRateLimitType(RateLimitType e) {
  if (flatbuffers::IsOutRange(e, RateLimitType::Undefined, RateLimitType::CreateOrder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRateLimitType()[index];
}

enum class Priority : uint32_t {
  Undefined = 0,
  Primary = 1,
  Secondary = 2,
  MIN = Undefined,
  MAX = Secondary
};

inline const Priority (&EnumValuesPriority())[3] {
  static const Priority values[] = {
    Priority::Undefined,
    Priority::Primary,
    Priority::Secondary
  };
  return values;
}

inline const char * const *EnumNamesPriority() {
  static const char * const names[4] = {
    "Undefined",
    "Primary",
    "Secondary",
    nullptr
  };
  return names;
}

inline const char *EnumNamePriority(Priority e) {
  if (flatbuffers::IsOutRange(e, Priority::Undefined, Priority::Secondary)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPriority()[index];
}

enum class Message : uint8_t {
  NONE = 0,
  Handshake = 1,
  HandshakeAck = 2,
  Subscribe = 3,
  BatchBegin = 4,
  BatchEnd = 5,
  DownloadBegin = 6,
  DownloadEnd = 7,
  GatewaySettings = 8,
  StreamStatus = 9,
  ExternalLatency = 10,
  RateLimitTrigger = 11,
  GatewayStatus = 12,
  ReferenceData = 13,
  MarketStatus = 14,
  TopOfBook = 15,
  MarketByPriceUpdate = 16,
  MarketByOrderUpdate = 17,
  TradeSummary = 18,
  StatisticsUpdate = 19,
  CreateOrder = 20,
  ModifyOrder = 21,
  CancelOrder = 22,
  CancelAllOrders = 23,
  OrderAck = 24,
  OrderUpdate = 25,
  TradeUpdate = 26,
  PositionUpdate = 27,
  FundsUpdate = 28,
  CustomMetrics = 29,
  CustomMetricsUpdate = 30,
  ParametersUpdate = 31,
  MIN = NONE,
  MAX = ParametersUpdate
};

inline const Message (&EnumValuesMessage())[32] {
  static const Message values[] = {
    Message::NONE,
    Message::Handshake,
    Message::HandshakeAck,
    Message::Subscribe,
    Message::BatchBegin,
    Message::BatchEnd,
    Message::DownloadBegin,
    Message::DownloadEnd,
    Message::GatewaySettings,
    Message::StreamStatus,
    Message::ExternalLatency,
    Message::RateLimitTrigger,
    Message::GatewayStatus,
    Message::ReferenceData,
    Message::MarketStatus,
    Message::TopOfBook,
    Message::MarketByPriceUpdate,
    Message::MarketByOrderUpdate,
    Message::TradeSummary,
    Message::StatisticsUpdate,
    Message::CreateOrder,
    Message::ModifyOrder,
    Message::CancelOrder,
    Message::CancelAllOrders,
    Message::OrderAck,
    Message::OrderUpdate,
    Message::TradeUpdate,
    Message::PositionUpdate,
    Message::FundsUpdate,
    Message::CustomMetrics,
    Message::CustomMetricsUpdate,
    Message::ParametersUpdate
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[33] = {
    "NONE",
    "Handshake",
    "HandshakeAck",
    "Subscribe",
    "BatchBegin",
    "BatchEnd",
    "DownloadBegin",
    "DownloadEnd",
    "GatewaySettings",
    "StreamStatus",
    "ExternalLatency",
    "RateLimitTrigger",
    "GatewayStatus",
    "ReferenceData",
    "MarketStatus",
    "TopOfBook",
    "MarketByPriceUpdate",
    "MarketByOrderUpdate",
    "TradeSummary",
    "StatisticsUpdate",
    "CreateOrder",
    "ModifyOrder",
    "CancelOrder",
    "CancelAllOrders",
    "OrderAck",
    "OrderUpdate",
    "TradeUpdate",
    "PositionUpdate",
    "FundsUpdate",
    "CustomMetrics",
    "CustomMetricsUpdate",
    "ParametersUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message::NONE, Message::ParametersUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message::NONE;
};

template<> struct MessageTraits<roq::fbs::Handshake> {
  static const Message enum_value = Message::Handshake;
};

template<> struct MessageTraits<roq::fbs::HandshakeAck> {
  static const Message enum_value = Message::HandshakeAck;
};

template<> struct MessageTraits<roq::fbs::Subscribe> {
  static const Message enum_value = Message::Subscribe;
};

template<> struct MessageTraits<roq::fbs::BatchBegin> {
  static const Message enum_value = Message::BatchBegin;
};

template<> struct MessageTraits<roq::fbs::BatchEnd> {
  static const Message enum_value = Message::BatchEnd;
};

template<> struct MessageTraits<roq::fbs::DownloadBegin> {
  static const Message enum_value = Message::DownloadBegin;
};

template<> struct MessageTraits<roq::fbs::DownloadEnd> {
  static const Message enum_value = Message::DownloadEnd;
};

template<> struct MessageTraits<roq::fbs::GatewaySettings> {
  static const Message enum_value = Message::GatewaySettings;
};

template<> struct MessageTraits<roq::fbs::StreamStatus> {
  static const Message enum_value = Message::StreamStatus;
};

template<> struct MessageTraits<roq::fbs::ExternalLatency> {
  static const Message enum_value = Message::ExternalLatency;
};

template<> struct MessageTraits<roq::fbs::RateLimitTrigger> {
  static const Message enum_value = Message::RateLimitTrigger;
};

template<> struct MessageTraits<roq::fbs::GatewayStatus> {
  static const Message enum_value = Message::GatewayStatus;
};

template<> struct MessageTraits<roq::fbs::ReferenceData> {
  static const Message enum_value = Message::ReferenceData;
};

template<> struct MessageTraits<roq::fbs::MarketStatus> {
  static const Message enum_value = Message::MarketStatus;
};

template<> struct MessageTraits<roq::fbs::TopOfBook> {
  static const Message enum_value = Message::TopOfBook;
};

template<> struct MessageTraits<roq::fbs::MarketByPriceUpdate> {
  static const Message enum_value = Message::MarketByPriceUpdate;
};

template<> struct MessageTraits<roq::fbs::MarketByOrderUpdate> {
  static const Message enum_value = Message::MarketByOrderUpdate;
};

template<> struct MessageTraits<roq::fbs::TradeSummary> {
  static const Message enum_value = Message::TradeSummary;
};

template<> struct MessageTraits<roq::fbs::StatisticsUpdate> {
  static const Message enum_value = Message::StatisticsUpdate;
};

template<> struct MessageTraits<roq::fbs::CreateOrder> {
  static const Message enum_value = Message::CreateOrder;
};

template<> struct MessageTraits<roq::fbs::ModifyOrder> {
  static const Message enum_value = Message::ModifyOrder;
};

template<> struct MessageTraits<roq::fbs::CancelOrder> {
  static const Message enum_value = Message::CancelOrder;
};

template<> struct MessageTraits<roq::fbs::CancelAllOrders> {
  static const Message enum_value = Message::CancelAllOrders;
};

template<> struct MessageTraits<roq::fbs::OrderAck> {
  static const Message enum_value = Message::OrderAck;
};

template<> struct MessageTraits<roq::fbs::OrderUpdate> {
  static const Message enum_value = Message::OrderUpdate;
};

template<> struct MessageTraits<roq::fbs::TradeUpdate> {
  static const Message enum_value = Message::TradeUpdate;
};

template<> struct MessageTraits<roq::fbs::PositionUpdate> {
  static const Message enum_value = Message::PositionUpdate;
};

template<> struct MessageTraits<roq::fbs::FundsUpdate> {
  static const Message enum_value = Message::FundsUpdate;
};

template<> struct MessageTraits<roq::fbs::CustomMetrics> {
  static const Message enum_value = Message::CustomMetrics;
};

template<> struct MessageTraits<roq::fbs::CustomMetricsUpdate> {
  static const Message enum_value = Message::CustomMetricsUpdate;
};

template<> struct MessageTraits<roq::fbs::ParametersUpdate> {
  static const Message enum_value = Message::ParametersUpdate;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Message> *types);

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTERNAL_TRADE_ID = 4,
    VT_QUANTITY = 6,
    VT_PRICE = 8,
    VT_LIQUIDITY = 10
  };
  const flatbuffers::String *external_trade_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_TRADE_ID);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  roq::fbs::Liquidity liquidity() const {
    return static_cast<roq::fbs::Liquidity>(GetField<uint8_t>(VT_LIQUIDITY, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXTERNAL_TRADE_ID) &&
           verifier.VerifyString(external_trade_id()) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<uint8_t>(verifier, VT_LIQUIDITY, 1) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_external_trade_id(flatbuffers::Offset<flatbuffers::String> external_trade_id) {
    fbb_.AddOffset(Fill::VT_EXTERNAL_TRADE_ID, external_trade_id);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(Fill::VT_QUANTITY, quantity, 0.0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(Fill::VT_PRICE, price, 0.0);
  }
  void add_liquidity(roq::fbs::Liquidity liquidity) {
    fbb_.AddElement<uint8_t>(Fill::VT_LIQUIDITY, static_cast<uint8_t>(liquidity), 0);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> external_trade_id = 0,
    double quantity = 0.0,
    double price = 0.0,
    roq::fbs::Liquidity liquidity = roq::fbs::Liquidity::Undefined) {
  FillBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_external_trade_id(external_trade_id);
  builder_.add_liquidity(liquidity);
  return builder_.Finish();
}

struct Fill::Traits {
  using type = Fill;
  static auto constexpr Create = CreateFill;
};

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *external_trade_id = nullptr,
    double quantity = 0.0,
    double price = 0.0,
    roq::fbs::Liquidity liquidity = roq::fbs::Liquidity::Undefined) {
  auto external_trade_id__ = external_trade_id ? _fbb.CreateString(external_trade_id) : 0;
  return roq::fbs::CreateFill(
      _fbb,
      external_trade_id__,
      quantity,
      price,
      liquidity);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BID_PRICE = 4,
    VT_BID_QUANTITY = 6,
    VT_ASK_PRICE = 8,
    VT_ASK_QUANTITY = 10
  };
  double bid_price() const {
    return GetField<double>(VT_BID_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double bid_quantity() const {
    return GetField<double>(VT_BID_QUANTITY, 0.0);
  }
  double ask_price() const {
    return GetField<double>(VT_ASK_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double ask_quantity() const {
    return GetField<double>(VT_ASK_QUANTITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_BID_PRICE, 8) &&
           VerifyField<double>(verifier, VT_BID_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_ASK_PRICE, 8) &&
           VerifyField<double>(verifier, VT_ASK_QUANTITY, 8) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bid_price(double bid_price) {
    fbb_.AddElement<double>(Layer::VT_BID_PRICE, bid_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_bid_quantity(double bid_quantity) {
    fbb_.AddElement<double>(Layer::VT_BID_QUANTITY, bid_quantity, 0.0);
  }
  void add_ask_price(double ask_price) {
    fbb_.AddElement<double>(Layer::VT_ASK_PRICE, ask_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_ask_quantity(double ask_quantity) {
    fbb_.AddElement<double>(Layer::VT_ASK_QUANTITY, ask_quantity, 0.0);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    double bid_price = std::numeric_limits<double>::quiet_NaN(),
    double bid_quantity = 0.0,
    double ask_price = std::numeric_limits<double>::quiet_NaN(),
    double ask_quantity = 0.0) {
  LayerBuilder builder_(_fbb);
  builder_.add_ask_quantity(ask_quantity);
  builder_.add_ask_price(ask_price);
  builder_.add_bid_quantity(bid_quantity);
  builder_.add_bid_price(bid_price);
  return builder_.Finish();
}

struct Layer::Traits {
  using type = Layer;
  static auto constexpr Create = CreateLayer;
};

struct MBOUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBOUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_QUANTITY = 6,
    VT_PRIORITY = 8,
    VT_ORDER_ID = 10,
    VT_ACTION = 12,
    VT_REASON = 14
  };
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  uint64_t priority() const {
    return GetField<uint64_t>(VT_PRIORITY, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  roq::fbs::UpdateAction action() const {
    return static_cast<roq::fbs::UpdateAction>(GetField<uint8_t>(VT_ACTION, 0));
  }
  roq::fbs::UpdateReason reason() const {
    return static_cast<roq::fbs::UpdateReason>(GetField<uint8_t>(VT_REASON, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<uint64_t>(verifier, VT_PRIORITY, 8) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_REASON, 1) &&
           verifier.EndTable();
  }
};

struct MBOUpdateBuilder {
  typedef MBOUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBOUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(MBOUpdate::VT_QUANTITY, quantity, 0.0);
  }
  void add_priority(uint64_t priority) {
    fbb_.AddElement<uint64_t>(MBOUpdate::VT_PRIORITY, priority, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(MBOUpdate::VT_ORDER_ID, order_id);
  }
  void add_action(roq::fbs::UpdateAction action) {
    fbb_.AddElement<uint8_t>(MBOUpdate::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_reason(roq::fbs::UpdateReason reason) {
    fbb_.AddElement<uint8_t>(MBOUpdate::VT_REASON, static_cast<uint8_t>(reason), 0);
  }
  explicit MBOUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MBOUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBOUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    uint64_t priority = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    roq::fbs::UpdateAction action = roq::fbs::UpdateAction::Undefined,
    roq::fbs::UpdateReason reason = roq::fbs::UpdateReason::Undefined) {
  MBOUpdateBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_order_id(order_id);
  builder_.add_reason(reason);
  builder_.add_action(action);
  return builder_.Finish();
}

struct MBOUpdate::Traits {
  using type = MBOUpdate;
  static auto constexpr Create = CreateMBOUpdate;
};

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    uint64_t priority = 0,
    const char *order_id = nullptr,
    roq::fbs::UpdateAction action = roq::fbs::UpdateAction::Undefined,
    roq::fbs::UpdateReason reason = roq::fbs::UpdateReason::Undefined) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return roq::fbs::CreateMBOUpdate(
      _fbb,
      price,
      quantity,
      priority,
      order_id__,
      action,
      reason);
}

struct MBPUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBPUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_QUANTITY = 6,
    VT_IMPLIED_QUANTITY = 8,
    VT_PRICE_LEVEL = 10,
    VT_NUMBER_OF_ORDERS = 14,
    VT_UPDATE_ACTION = 16
  };
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  double implied_quantity() const {
    return GetField<double>(VT_IMPLIED_QUANTITY, 0.0);
  }
  uint32_t price_level() const {
    return GetField<uint32_t>(VT_PRICE_LEVEL, 0);
  }
  uint16_t number_of_orders() const {
    return GetField<uint16_t>(VT_NUMBER_OF_ORDERS, 0);
  }
  roq::fbs::UpdateAction update_action() const {
    return static_cast<roq::fbs::UpdateAction>(GetField<uint8_t>(VT_UPDATE_ACTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_IMPLIED_QUANTITY, 8) &&
           VerifyField<uint32_t>(verifier, VT_PRICE_LEVEL, 4) &&
           VerifyField<uint16_t>(verifier, VT_NUMBER_OF_ORDERS, 2) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_ACTION, 1) &&
           verifier.EndTable();
  }
};

struct MBPUpdateBuilder {
  typedef MBPUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBPUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(MBPUpdate::VT_QUANTITY, quantity, 0.0);
  }
  void add_implied_quantity(double implied_quantity) {
    fbb_.AddElement<double>(MBPUpdate::VT_IMPLIED_QUANTITY, implied_quantity, 0.0);
  }
  void add_price_level(uint32_t price_level) {
    fbb_.AddElement<uint32_t>(MBPUpdate::VT_PRICE_LEVEL, price_level, 0);
  }
  void add_number_of_orders(uint16_t number_of_orders) {
    fbb_.AddElement<uint16_t>(MBPUpdate::VT_NUMBER_OF_ORDERS, number_of_orders, 0);
  }
  void add_update_action(roq::fbs::UpdateAction update_action) {
    fbb_.AddElement<uint8_t>(MBPUpdate::VT_UPDATE_ACTION, static_cast<uint8_t>(update_action), 0);
  }
  explicit MBPUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MBPUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBPUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBPUpdate> CreateMBPUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    double implied_quantity = 0.0,
    uint32_t price_level = 0,
    uint16_t number_of_orders = 0,
    roq::fbs::UpdateAction update_action = roq::fbs::UpdateAction::Undefined) {
  MBPUpdateBuilder builder_(_fbb);
  builder_.add_implied_quantity(implied_quantity);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_price_level(price_level);
  builder_.add_number_of_orders(number_of_orders);
  builder_.add_update_action(update_action);
  return builder_.Finish();
}

struct MBPUpdate::Traits {
  using type = MBPUpdate;
  static auto constexpr Create = CreateMBPUpdate;
};

struct Measurement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeasurementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  double value() const {
    return GetField<double>(VT_VALUE, std::numeric_limits<double>::quiet_NaN());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct MeasurementBuilder {
  typedef Measurement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Measurement::VT_NAME, name);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Measurement::VT_VALUE, value, std::numeric_limits<double>::quiet_NaN());
  }
  explicit MeasurementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Measurement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Measurement>(end);
    return o;
  }
};

inline flatbuffers::Offset<Measurement> CreateMeasurement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double value = std::numeric_limits<double>::quiet_NaN()) {
  MeasurementBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Measurement::Traits {
  using type = Measurement;
  static auto constexpr Create = CreateMeasurement;
};

inline flatbuffers::Offset<Measurement> CreateMeasurementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    double value = std::numeric_limits<double>::quiet_NaN()) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return roq::fbs::CreateMeasurement(
      _fbb,
      name__,
      value);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParameterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_VALUE = 12
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ParameterBuilder {
  typedef Parameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Parameter::VT_LABEL, label);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(Parameter::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(Parameter::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Parameter::VT_SYMBOL, symbol);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Parameter::VT_VALUE, value);
  }
  explicit ParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parameter> CreateParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_label(label);
  return builder_.Finish();
}

struct Parameter::Traits {
  using type = Parameter;
  static auto constexpr Create = CreateParameter;
};

inline flatbuffers::Offset<Parameter> CreateParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    const char *account = nullptr,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const char *value = nullptr) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return roq::fbs::CreateParameter(
      _fbb,
      label__,
      account__,
      exchange__,
      symbol__,
      value__);
}

struct Statistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6,
    VT_BEGIN_TIME_UTC = 8,
    VT_END_TIME_UTC = 10
  };
  roq::fbs::StatisticsType type() const {
    return static_cast<roq::fbs::StatisticsType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  double value() const {
    return GetField<double>(VT_VALUE, std::numeric_limits<double>::quiet_NaN());
  }
  int64_t begin_time_utc() const {
    return GetField<int64_t>(VT_BEGIN_TIME_UTC, 0);
  }
  int64_t end_time_utc() const {
    return GetField<int64_t>(VT_END_TIME_UTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_END_TIME_UTC, 8) &&
           verifier.EndTable();
  }
};

struct StatisticsBuilder {
  typedef Statistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(roq::fbs::StatisticsType type) {
    fbb_.AddElement<uint8_t>(Statistics::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Statistics::VT_VALUE, value, std::numeric_limits<double>::quiet_NaN());
  }
  void add_begin_time_utc(int64_t begin_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_BEGIN_TIME_UTC, begin_time_utc, 0);
  }
  void add_end_time_utc(int64_t end_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_END_TIME_UTC, end_time_utc, 0);
  }
  explicit StatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Statistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Statistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Statistics> CreateStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::StatisticsType type = roq::fbs::StatisticsType::Undefined,
    double value = std::numeric_limits<double>::quiet_NaN(),
    int64_t begin_time_utc = 0,
    int64_t end_time_utc = 0) {
  StatisticsBuilder builder_(_fbb);
  builder_.add_end_time_utc(end_time_utc);
  builder_.add_begin_time_utc(begin_time_utc);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Statistics::Traits {
  using type = Statistics;
  static auto constexpr Create = CreateStatistics;
};

struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIDE = 4,
    VT_PRICE = 6,
    VT_QUANTITY = 8,
    VT_TRADE_ID = 10,
    VT_TAKER_ORDER_ID = 12,
    VT_MAKER_ORDER_ID = 14
  };
  roq::fbs::Side side() const {
    return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, 0.0);
  }
  const flatbuffers::String *trade_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADE_ID);
  }
  const flatbuffers::String *taker_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TAKER_ORDER_ID);
  }
  const flatbuffers::String *maker_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_MAKER_ORDER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyOffset(verifier, VT_TRADE_ID) &&
           verifier.VerifyString(trade_id()) &&
           VerifyOffset(verifier, VT_TAKER_ORDER_ID) &&
           verifier.VerifyString(taker_order_id()) &&
           VerifyOffset(verifier, VT_MAKER_ORDER_ID) &&
           verifier.VerifyString(maker_order_id()) &&
           verifier.EndTable();
  }
};

struct TradeBuilder {
  typedef Trade Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(Trade::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(Trade::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(Trade::VT_QUANTITY, quantity, 0.0);
  }
  void add_trade_id(flatbuffers::Offset<flatbuffers::String> trade_id) {
    fbb_.AddOffset(Trade::VT_TRADE_ID, trade_id);
  }
  void add_taker_order_id(flatbuffers::Offset<flatbuffers::String> taker_order_id) {
    fbb_.AddOffset(Trade::VT_TAKER_ORDER_ID, taker_order_id);
  }
  void add_maker_order_id(flatbuffers::Offset<flatbuffers::String> maker_order_id) {
    fbb_.AddOffset(Trade::VT_MAKER_ORDER_ID, maker_order_id);
  }
  explicit TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    flatbuffers::Offset<flatbuffers::String> trade_id = 0,
    flatbuffers::Offset<flatbuffers::String> taker_order_id = 0,
    flatbuffers::Offset<flatbuffers::String> maker_order_id = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_maker_order_id(maker_order_id);
  builder_.add_taker_order_id(taker_order_id);
  builder_.add_trade_id(trade_id);
  builder_.add_side(side);
  return builder_.Finish();
}

struct Trade::Traits {
  using type = Trade;
  static auto constexpr Create = CreateTrade;
};

inline flatbuffers::Offset<Trade> CreateTradeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    const char *trade_id = nullptr,
    const char *taker_order_id = nullptr,
    const char *maker_order_id = nullptr) {
  auto trade_id__ = trade_id ? _fbb.CreateString(trade_id) : 0;
  auto taker_order_id__ = taker_order_id ? _fbb.CreateString(taker_order_id) : 0;
  auto maker_order_id__ = maker_order_id ? _fbb.CreateString(maker_order_id) : 0;
  return roq::fbs::CreateTrade(
      _fbb,
      side,
      price,
      quantity,
      trade_id__,
      taker_order_id__,
      maker_order_id__);
}

struct CancelAllOrders FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelAllOrdersBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct CancelAllOrdersBuilder {
  typedef CancelAllOrders Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelAllOrders::VT_ACCOUNT, account);
  }
  explicit CancelAllOrdersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CancelAllOrders> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelAllOrders>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrders(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0) {
  CancelAllOrdersBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

struct CancelAllOrders::Traits {
  using type = CancelAllOrders;
  static auto constexpr Create = CreateCancelAllOrders;
};

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrdersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateCancelAllOrders(
      _fbb,
      account__);
}

struct CancelOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelOrderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_ROUTING_ID = 8,
    VT_VERSION = 10,
    VT_CONDITIONAL_ON_VERSION = 12
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  uint32_t conditional_on_version() const {
    return GetField<uint32_t>(VT_CONDITIONAL_ON_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONDITIONAL_ON_VERSION, 4) &&
           verifier.EndTable();
  }
};

struct CancelOrderBuilder {
  typedef CancelOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(CancelOrder::VT_ORDER_ID, order_id, 0);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CancelOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(CancelOrder::VT_VERSION, version, 0);
  }
  void add_conditional_on_version(uint32_t conditional_on_version) {
    fbb_.AddElement<uint32_t>(CancelOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit CancelOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CancelOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelOrder> CreateCancelOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  CancelOrderBuilder builder_(_fbb);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

struct CancelOrder::Traits {
  using type = CancelOrder;
  static auto constexpr Create = CreateCancelOrder;
};

inline flatbuffers::Offset<CancelOrder> CreateCancelOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *routing_id = nullptr,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCancelOrder(
      _fbb,
      account__,
      order_id,
      routing_id__,
      version,
      conditional_on_version);
}

struct CreateOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateOrderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_SIDE = 12,
    VT_POSITION_EFFECT = 14,
    VT_MAX_SHOW_QUANTITY = 16,
    VT_ORDER_TYPE = 18,
    VT_TIME_IN_FORCE = 20,
    VT_ZZZ_EXECUTION_INSTRUCTIONS = 22,
    VT_ORDER_TEMPLATE = 24,
    VT_QUANTITY = 26,
    VT_PRICE = 28,
    VT_STOP_PRICE = 30,
    VT_ROUTING_ID = 32,
    VT_EXECUTION_INSTRUCTIONS = 34
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  roq::fbs::Side side() const {
    return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  uint8_t zzz_execution_instructions() const {
    return GetField<uint8_t>(VT_ZZZ_EXECUTION_INSTRUCTIONS, 0);
  }
  const flatbuffers::String *order_template() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_TEMPLATE);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double stop_price() const {
    return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  uint32_t execution_instructions() const {
    return GetField<uint32_t>(VT_EXECUTION_INSTRUCTIONS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY, 8) &&
           VerifyField<uint8_t>(verifier, VT_ORDER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZZZ_EXECUTION_INSTRUCTIONS, 1) &&
           VerifyOffset(verifier, VT_ORDER_TEMPLATE) &&
           verifier.VerifyString(order_template()) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_STOP_PRICE, 8) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint32_t>(verifier, VT_EXECUTION_INSTRUCTIONS, 4) &&
           verifier.EndTable();
  }
};

struct CreateOrderBuilder {
  typedef CreateOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CreateOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(CreateOrder::VT_ORDER_ID, order_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CreateOrder::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(CreateOrder::VT_SYMBOL, symbol);
  }
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(CreateOrder::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_zzz_execution_instructions(uint8_t zzz_execution_instructions) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_ZZZ_EXECUTION_INSTRUCTIONS, zzz_execution_instructions, 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(CreateOrder::VT_ORDER_TEMPLATE, order_template);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(CreateOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(CreateOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(CreateOrder::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CreateOrder::VT_ROUTING_ID, routing_id);
  }
  void add_execution_instructions(uint32_t execution_instructions) {
    fbb_.AddElement<uint32_t>(CreateOrder::VT_EXECUTION_INSTRUCTIONS, execution_instructions, 0);
  }
  explicit CreateOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreateOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateOrder> CreateCreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType::Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce::Undefined,
    uint8_t zzz_execution_instructions = 0,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t execution_instructions = 0) {
  CreateOrderBuilder builder_(_fbb);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_execution_instructions(execution_instructions);
  builder_.add_routing_id(routing_id);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_zzz_execution_instructions(zzz_execution_instructions);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

struct CreateOrder::Traits {
  using type = CreateOrder;
  static auto constexpr Create = CreateCreateOrder;
};

inline flatbuffers::Offset<CreateOrder> CreateCreateOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType::Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce::Undefined,
    uint8_t zzz_execution_instructions = 0,
    const char *order_template = nullptr,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    const char *routing_id = nullptr,
    uint32_t execution_instructions = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCreateOrder(
      _fbb,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      max_show_quantity,
      order_type,
      time_in_force,
      zzz_execution_instructions,
      order_template__,
      quantity,
      price,
      stop_price,
      routing_id__,
      execution_instructions);
}

struct CustomMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomMetricsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_MEASUREMENTS = 12,
    VT_UPDATE_TYPE = 14
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> *measurements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> *>(VT_MEASUREMENTS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_MEASUREMENTS) &&
           verifier.VerifyVector(measurements()) &&
           verifier.VerifyVectorOfTables(measurements()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CustomMetricsBuilder {
  typedef CustomMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(CustomMetrics::VT_LABEL, label);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CustomMetrics::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CustomMetrics::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(CustomMetrics::VT_SYMBOL, symbol);
  }
  void add_measurements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements) {
    fbb_.AddOffset(CustomMetrics::VT_MEASUREMENTS, measurements);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(CustomMetrics::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  explicit CustomMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomMetrics> CreateCustomMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined) {
  CustomMetricsBuilder builder_(_fbb);
  builder_.add_measurements(measurements);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_label(label);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct CustomMetrics::Traits {
  using type = CustomMetrics;
  static auto constexpr Create = CreateCustomMetrics;
};

inline flatbuffers::Offset<CustomMetrics> CreateCustomMetricsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    const char *account = nullptr,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Measurement>> *measurements = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto measurements__ = measurements ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Measurement>>(*measurements) : 0;
  return roq::fbs::CreateCustomMetrics(
      _fbb,
      label__,
      account__,
      exchange__,
      symbol__,
      measurements__,
      update_type);
}

struct CustomMetricsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomMetricsUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER = 4,
    VT_LABEL = 6,
    VT_ACCOUNT = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_MEASUREMENTS = 14,
    VT_UPDATE_TYPE = 16
  };
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> *measurements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> *>(VT_MEASUREMENTS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_MEASUREMENTS) &&
           verifier.VerifyVector(measurements()) &&
           verifier.VerifyVectorOfTables(measurements()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CustomMetricsUpdateBuilder {
  typedef CustomMetricsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_USER, user);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_LABEL, label);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_SYMBOL, symbol);
  }
  void add_measurements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_MEASUREMENTS, measurements);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(CustomMetricsUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  explicit CustomMetricsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomMetricsUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomMetricsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomMetricsUpdate> CreateCustomMetricsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined) {
  CustomMetricsUpdateBuilder builder_(_fbb);
  builder_.add_measurements(measurements);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_label(label);
  builder_.add_user(user);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct CustomMetricsUpdate::Traits {
  using type = CustomMetricsUpdate;
  static auto constexpr Create = CreateCustomMetricsUpdate;
};

inline flatbuffers::Offset<CustomMetricsUpdate> CreateCustomMetricsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user = nullptr,
    const char *label = nullptr,
    const char *account = nullptr,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Measurement>> *measurements = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined) {
  auto user__ = user ? _fbb.CreateString(user) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto measurements__ = measurements ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Measurement>>(*measurements) : 0;
  return roq::fbs::CreateCustomMetricsUpdate(
      _fbb,
      user__,
      label__,
      account__,
      exchange__,
      symbol__,
      measurements__,
      update_type);
}

struct DownloadBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadBeginBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct DownloadBeginBuilder {
  typedef DownloadBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadBegin::VT_ACCOUNT, account);
  }
  explicit DownloadBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DownloadBegin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBegin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0) {
  DownloadBeginBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

struct DownloadBegin::Traits {
  using type = DownloadBegin;
  static auto constexpr Create = CreateDownloadBegin;
};

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBeginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadBegin(
      _fbb,
      account__);
}

struct DownloadEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadEndBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_MAX_ORDER_ID = 6
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t max_order_id() const {
    return GetField<uint32_t>(VT_MAX_ORDER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ORDER_ID, 4) &&
           verifier.EndTable();
  }
};

struct DownloadEndBuilder {
  typedef DownloadEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadEnd::VT_ACCOUNT, account);
  }
  void add_max_order_id(uint32_t max_order_id) {
    fbb_.AddElement<uint32_t>(DownloadEnd::VT_MAX_ORDER_ID, max_order_id, 0);
  }
  explicit DownloadEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DownloadEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t max_order_id = 0) {
  DownloadEndBuilder builder_(_fbb);
  builder_.add_max_order_id(max_order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

struct DownloadEnd::Traits {
  using type = DownloadEnd;
  static auto constexpr Create = CreateDownloadEnd;
};

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEndDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t max_order_id = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadEnd(
      _fbb,
      account__,
      max_order_id);
}

struct ExternalLatency FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExternalLatencyBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_LATENCY = 6,
    VT_ACCOUNT = 8
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  int64_t latency() const {
    return GetField<int64_t>(VT_LATENCY, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyField<int64_t>(verifier, VT_LATENCY, 8) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct ExternalLatencyBuilder {
  typedef ExternalLatency Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(ExternalLatency::VT_STREAM_ID, stream_id, 0);
  }
  void add_latency(int64_t latency) {
    fbb_.AddElement<int64_t>(ExternalLatency::VT_LATENCY, latency, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ExternalLatency::VT_ACCOUNT, account);
  }
  explicit ExternalLatencyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExternalLatency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExternalLatency>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExternalLatency> CreateExternalLatency(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    int64_t latency = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0) {
  ExternalLatencyBuilder builder_(_fbb);
  builder_.add_latency(latency);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct ExternalLatency::Traits {
  using type = ExternalLatency;
  static auto constexpr Create = CreateExternalLatency;
};

inline flatbuffers::Offset<ExternalLatency> CreateExternalLatencyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    int64_t latency = 0,
    const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateExternalLatency(
      _fbb,
      stream_id,
      latency,
      account__);
}

struct FundsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FundsUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_CURRENCY = 8,
    VT_BALANCE = 10,
    VT_HOLD = 12,
    VT_EXTERNAL_ACCOUNT = 14
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *currency() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCY);
  }
  double balance() const {
    return GetField<double>(VT_BALANCE, std::numeric_limits<double>::quiet_NaN());
  }
  double hold() const {
    return GetField<double>(VT_HOLD, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_CURRENCY) &&
           verifier.VerifyString(currency()) &&
           VerifyField<double>(verifier, VT_BALANCE, 8) &&
           VerifyField<double>(verifier, VT_HOLD, 8) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) &&
           verifier.EndTable();
  }
};

struct FundsUpdateBuilder {
  typedef FundsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(FundsUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(FundsUpdate::VT_ACCOUNT, account);
  }
  void add_currency(flatbuffers::Offset<flatbuffers::String> currency) {
    fbb_.AddOffset(FundsUpdate::VT_CURRENCY, currency);
  }
  void add_balance(double balance) {
    fbb_.AddElement<double>(FundsUpdate::VT_BALANCE, balance, std::numeric_limits<double>::quiet_NaN());
  }
  void add_hold(double hold) {
    fbb_.AddElement<double>(FundsUpdate::VT_HOLD, hold, std::numeric_limits<double>::quiet_NaN());
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(FundsUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  explicit FundsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FundsUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FundsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> currency = 0,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> external_account = 0) {
  FundsUpdateBuilder builder_(_fbb);
  builder_.add_hold(hold);
  builder_.add_balance(balance);
  builder_.add_external_account(external_account);
  builder_.add_currency(currency);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct FundsUpdate::Traits {
  using type = FundsUpdate;
  static auto constexpr Create = CreateFundsUpdate;
};

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    const char *currency = nullptr,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    const char *external_account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto currency__ = currency ? _fbb.CreateString(currency) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreateFundsUpdate(
      _fbb,
      stream_id,
      account__,
      currency__,
      balance,
      hold,
      external_account__);
}

struct GatewaySettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewaySettingsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUPPORTS = 4,
    VT_MBP_MAX_DEPTH = 6,
    VT_MBP_ALLOW_PRICE_INVERSION = 8,
    VT_MBP_ALLOW_REMOVE_NON_EXISTING = 12,
    VT_OMS_DOWNLOAD_HAS_STATE = 14,
    VT_OMS_DOWNLOAD_HAS_ROUTING_ID = 16,
    VT_MBP_TICK_SIZE_MULTIPLIER = 18,
    VT_MBP_MIN_TRADE_VOL_MULTIPLIER = 20,
    VT_OMS_REQUEST_ID_TYPE = 22,
    VT_MBP_CHECKSUM = 24
  };
  uint64_t supports() const {
    return GetField<uint64_t>(VT_SUPPORTS, 0);
  }
  uint32_t mbp_max_depth() const {
    return GetField<uint32_t>(VT_MBP_MAX_DEPTH, 0);
  }
  bool mbp_allow_price_inversion() const {
    return GetField<uint8_t>(VT_MBP_ALLOW_PRICE_INVERSION, 0) != 0;
  }
  bool mbp_allow_remove_non_existing() const {
    return GetField<uint8_t>(VT_MBP_ALLOW_REMOVE_NON_EXISTING, 0) != 0;
  }
  bool oms_download_has_state() const {
    return GetField<uint8_t>(VT_OMS_DOWNLOAD_HAS_STATE, 0) != 0;
  }
  bool oms_download_has_routing_id() const {
    return GetField<uint8_t>(VT_OMS_DOWNLOAD_HAS_ROUTING_ID, 0) != 0;
  }
  double mbp_tick_size_multiplier() const {
    return GetField<double>(VT_MBP_TICK_SIZE_MULTIPLIER, std::numeric_limits<double>::quiet_NaN());
  }
  double mbp_min_trade_vol_multiplier() const {
    return GetField<double>(VT_MBP_MIN_TRADE_VOL_MULTIPLIER, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::RequestIdType oms_request_id_type() const {
    return static_cast<roq::fbs::RequestIdType>(GetField<uint8_t>(VT_OMS_REQUEST_ID_TYPE, 0));
  }
  bool mbp_checksum() const {
    return GetField<uint8_t>(VT_MBP_CHECKSUM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTS, 8) &&
           VerifyField<uint32_t>(verifier, VT_MBP_MAX_DEPTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_PRICE_INVERSION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_REMOVE_NON_EXISTING, 1) &&
           VerifyField<uint8_t>(verifier, VT_OMS_DOWNLOAD_HAS_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OMS_DOWNLOAD_HAS_ROUTING_ID, 1) &&
           VerifyField<double>(verifier, VT_MBP_TICK_SIZE_MULTIPLIER, 8) &&
           VerifyField<double>(verifier, VT_MBP_MIN_TRADE_VOL_MULTIPLIER, 8) &&
           VerifyField<uint8_t>(verifier, VT_OMS_REQUEST_ID_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MBP_CHECKSUM, 1) &&
           verifier.EndTable();
  }
};

struct GatewaySettingsBuilder {
  typedef GatewaySettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_supports(uint64_t supports) {
    fbb_.AddElement<uint64_t>(GatewaySettings::VT_SUPPORTS, supports, 0);
  }
  void add_mbp_max_depth(uint32_t mbp_max_depth) {
    fbb_.AddElement<uint32_t>(GatewaySettings::VT_MBP_MAX_DEPTH, mbp_max_depth, 0);
  }
  void add_mbp_allow_price_inversion(bool mbp_allow_price_inversion) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_MBP_ALLOW_PRICE_INVERSION, static_cast<uint8_t>(mbp_allow_price_inversion), 0);
  }
  void add_mbp_allow_remove_non_existing(bool mbp_allow_remove_non_existing) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_MBP_ALLOW_REMOVE_NON_EXISTING, static_cast<uint8_t>(mbp_allow_remove_non_existing), 0);
  }
  void add_oms_download_has_state(bool oms_download_has_state) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_OMS_DOWNLOAD_HAS_STATE, static_cast<uint8_t>(oms_download_has_state), 0);
  }
  void add_oms_download_has_routing_id(bool oms_download_has_routing_id) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_OMS_DOWNLOAD_HAS_ROUTING_ID, static_cast<uint8_t>(oms_download_has_routing_id), 0);
  }
  void add_mbp_tick_size_multiplier(double mbp_tick_size_multiplier) {
    fbb_.AddElement<double>(GatewaySettings::VT_MBP_TICK_SIZE_MULTIPLIER, mbp_tick_size_multiplier, std::numeric_limits<double>::quiet_NaN());
  }
  void add_mbp_min_trade_vol_multiplier(double mbp_min_trade_vol_multiplier) {
    fbb_.AddElement<double>(GatewaySettings::VT_MBP_MIN_TRADE_VOL_MULTIPLIER, mbp_min_trade_vol_multiplier, std::numeric_limits<double>::quiet_NaN());
  }
  void add_oms_request_id_type(roq::fbs::RequestIdType oms_request_id_type) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_OMS_REQUEST_ID_TYPE, static_cast<uint8_t>(oms_request_id_type), 0);
  }
  void add_mbp_checksum(bool mbp_checksum) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_MBP_CHECKSUM, static_cast<uint8_t>(mbp_checksum), 0);
  }
  explicit GatewaySettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatewaySettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewaySettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewaySettings> CreateGatewaySettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t supports = 0,
    uint32_t mbp_max_depth = 0,
    bool mbp_allow_price_inversion = false,
    bool mbp_allow_remove_non_existing = false,
    bool oms_download_has_state = false,
    bool oms_download_has_routing_id = false,
    double mbp_tick_size_multiplier = std::numeric_limits<double>::quiet_NaN(),
    double mbp_min_trade_vol_multiplier = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::RequestIdType oms_request_id_type = roq::fbs::RequestIdType::Undefined,
    bool mbp_checksum = false) {
  GatewaySettingsBuilder builder_(_fbb);
  builder_.add_mbp_min_trade_vol_multiplier(mbp_min_trade_vol_multiplier);
  builder_.add_mbp_tick_size_multiplier(mbp_tick_size_multiplier);
  builder_.add_supports(supports);
  builder_.add_mbp_max_depth(mbp_max_depth);
  builder_.add_mbp_checksum(mbp_checksum);
  builder_.add_oms_request_id_type(oms_request_id_type);
  builder_.add_oms_download_has_routing_id(oms_download_has_routing_id);
  builder_.add_oms_download_has_state(oms_download_has_state);
  builder_.add_mbp_allow_remove_non_existing(mbp_allow_remove_non_existing);
  builder_.add_mbp_allow_price_inversion(mbp_allow_price_inversion);
  return builder_.Finish();
}

struct GatewaySettings::Traits {
  using type = GatewaySettings;
  static auto constexpr Create = CreateGatewaySettings;
};

struct GatewayStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewayStatusBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_SUPPORTED = 6,
    VT_AVAILABLE = 8,
    VT_UNAVAILABLE = 10
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint64_t supported() const {
    return GetField<uint64_t>(VT_SUPPORTED, 0);
  }
  uint64_t available() const {
    return GetField<uint64_t>(VT_AVAILABLE, 0);
  }
  uint64_t unavailable() const {
    return GetField<uint64_t>(VT_UNAVAILABLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTED, 8) &&
           VerifyField<uint64_t>(verifier, VT_AVAILABLE, 8) &&
           VerifyField<uint64_t>(verifier, VT_UNAVAILABLE, 8) &&
           verifier.EndTable();
  }
};

struct GatewayStatusBuilder {
  typedef GatewayStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(GatewayStatus::VT_ACCOUNT, account);
  }
  void add_supported(uint64_t supported) {
    fbb_.AddElement<uint64_t>(GatewayStatus::VT_SUPPORTED, supported, 0);
  }
  void add_available(uint64_t available) {
    fbb_.AddElement<uint64_t>(GatewayStatus::VT_AVAILABLE, available, 0);
  }
  void add_unavailable(uint64_t unavailable) {
    fbb_.AddElement<uint64_t>(GatewayStatus::VT_UNAVAILABLE, unavailable, 0);
  }
  explicit GatewayStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatewayStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewayStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  GatewayStatusBuilder builder_(_fbb);
  builder_.add_unavailable(unavailable);
  builder_.add_available(available);
  builder_.add_supported(supported);
  builder_.add_account(account);
  return builder_.Finish();
}

struct GatewayStatus::Traits {
  using type = GatewayStatus;
  static auto constexpr Create = CreateGatewayStatus;
};

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateGatewayStatus(
      _fbb,
      account__,
      supported,
      available,
      unavailable);
}

struct MarketByOrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByOrderUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_UPDATE_TYPE = 14,
    VT_EXCHANGE_TIME_UTC = 16,
    VT_EXCHANGE_SEQUENCE = 18,
    VT_PRICE_DECIMALS = 20,
    VT_QUANTITY_DECIMALS = 22,
    VT_MAX_DEPTH = 24,
    VT_CHECKSUM = 26
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *bids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *>(VT_BIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *asks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *>(VT_ASKS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const {
    return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0);
  }
  int64_t exchange_sequence() const {
    return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0);
  }
  roq::fbs::Decimals price_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_PRICE_DECIMALS, 0));
  }
  roq::fbs::Decimals quantity_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_QUANTITY_DECIMALS, 0));
  }
  uint16_t max_depth() const {
    return GetField<uint16_t>(VT_MAX_DEPTH, 0);
  }
  uint32_t checksum() const {
    return GetField<uint32_t>(VT_CHECKSUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           verifier.VerifyVectorOfTables(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           VerifyField<uint8_t>(verifier, VT_PRICE_DECIMALS, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUANTITY_DECIMALS, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_DEPTH, 2) &&
           VerifyField<uint32_t>(verifier, VT_CHECKSUM, 4) &&
           verifier.EndTable();
  }
};

struct MarketByOrderUpdateBuilder {
  typedef MarketByOrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(MarketByOrderUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_ASKS, asks);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByOrderUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(MarketByOrderUpdate::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  void add_price_decimals(roq::fbs::Decimals price_decimals) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_PRICE_DECIMALS, static_cast<uint8_t>(price_decimals), 0);
  }
  void add_quantity_decimals(roq::fbs::Decimals quantity_decimals) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_QUANTITY_DECIMALS, static_cast<uint8_t>(quantity_decimals), 0);
  }
  void add_max_depth(uint16_t max_depth) {
    fbb_.AddElement<uint16_t>(MarketByOrderUpdate::VT_MAX_DEPTH, max_depth, 0);
  }
  void add_checksum(uint32_t checksum) {
    fbb_.AddElement<uint32_t>(MarketByOrderUpdate::VT_CHECKSUM, checksum, 0);
  }
  explicit MarketByOrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MarketByOrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByOrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals::Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals::Undefined,
    uint16_t max_depth = 0,
    uint32_t checksum = 0) {
  MarketByOrderUpdateBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_checksum(checksum);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_max_depth(max_depth);
  builder_.add_stream_id(stream_id);
  builder_.add_quantity_decimals(quantity_decimals);
  builder_.add_price_decimals(price_decimals);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct MarketByOrderUpdate::Traits {
  using type = MarketByOrderUpdate;
  static auto constexpr Create = CreateMarketByOrderUpdate;
};

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *bids = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *asks = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals::Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals::Undefined,
    uint16_t max_depth = 0,
    uint32_t checksum = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByOrderUpdate(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      bids__,
      asks__,
      update_type,
      exchange_time_utc,
      exchange_sequence,
      price_decimals,
      quantity_decimals,
      max_depth,
      checksum);
}

struct MarketByPriceUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByPriceUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_UPDATE_TYPE = 14,
    VT_EXCHANGE_TIME_UTC = 16,
    VT_EXCHANGE_SEQUENCE = 18,
    VT_PRICE_DECIMALS = 20,
    VT_QUANTITY_DECIMALS = 22,
    VT_MAX_DEPTH = 24
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *bids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *>(VT_BIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *asks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *>(VT_ASKS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const {
    return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0);
  }
  int64_t exchange_sequence() const {
    return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0);
  }
  roq::fbs::Decimals price_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_PRICE_DECIMALS, 0));
  }
  roq::fbs::Decimals quantity_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_QUANTITY_DECIMALS, 0));
  }
  uint16_t max_depth() const {
    return GetField<uint16_t>(VT_MAX_DEPTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           verifier.VerifyVectorOfTables(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           VerifyField<uint8_t>(verifier, VT_PRICE_DECIMALS, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUANTITY_DECIMALS, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_DEPTH, 2) &&
           verifier.EndTable();
  }
};

struct MarketByPriceUpdateBuilder {
  typedef MarketByPriceUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(MarketByPriceUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_ASKS, asks);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByPriceUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(MarketByPriceUpdate::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  void add_price_decimals(roq::fbs::Decimals price_decimals) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_PRICE_DECIMALS, static_cast<uint8_t>(price_decimals), 0);
  }
  void add_quantity_decimals(roq::fbs::Decimals quantity_decimals) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_QUANTITY_DECIMALS, static_cast<uint8_t>(quantity_decimals), 0);
  }
  void add_max_depth(uint16_t max_depth) {
    fbb_.AddElement<uint16_t>(MarketByPriceUpdate::VT_MAX_DEPTH, max_depth, 0);
  }
  explicit MarketByPriceUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MarketByPriceUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByPriceUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals::Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals::Undefined,
    uint16_t max_depth = 0) {
  MarketByPriceUpdateBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_max_depth(max_depth);
  builder_.add_stream_id(stream_id);
  builder_.add_quantity_decimals(quantity_decimals);
  builder_.add_price_decimals(price_decimals);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct MarketByPriceUpdate::Traits {
  using type = MarketByPriceUpdate;
  static auto constexpr Create = CreateMarketByPriceUpdate;
};

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *bids = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *asks = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals::Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals::Undefined,
    uint16_t max_depth = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByPriceUpdate(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      bids__,
      asks__,
      update_type,
      exchange_time_utc,
      exchange_sequence,
      price_decimals,
      quantity_decimals,
      max_depth);
}

struct MarketStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketStatusBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADING_STATUS = 10
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  roq::fbs::TradingStatus trading_status() const {
    return static_cast<roq::fbs::TradingStatus>(GetField<uint8_t>(VT_TRADING_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TRADING_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct MarketStatusBuilder {
  typedef MarketStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(MarketStatus::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketStatus::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketStatus::VT_SYMBOL, symbol);
  }
  void add_trading_status(roq::fbs::TradingStatus trading_status) {
    fbb_.AddElement<uint8_t>(MarketStatus::VT_TRADING_STATUS, static_cast<uint8_t>(trading_status), 0);
  }
  explicit MarketStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MarketStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketStatus> CreateMarketStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus::Undefined) {
  MarketStatusBuilder builder_(_fbb);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_trading_status(trading_status);
  return builder_.Finish();
}

struct MarketStatus::Traits {
  using type = MarketStatus;
  static auto constexpr Create = CreateMarketStatus;
};

inline flatbuffers::Offset<MarketStatus> CreateMarketStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus::Undefined) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateMarketStatus(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      trading_status);
}

struct ModifyOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModifyOrderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_QUANTITY = 8,
    VT_PRICE = 10,
    VT_ROUTING_ID = 12,
    VT_VERSION = 14,
    VT_CONDITIONAL_ON_VERSION = 16
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  uint32_t conditional_on_version() const {
    return GetField<uint32_t>(VT_CONDITIONAL_ON_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONDITIONAL_ON_VERSION, 4) &&
           verifier.EndTable();
  }
};

struct ModifyOrderBuilder {
  typedef ModifyOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ModifyOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(ModifyOrder::VT_ORDER_ID, order_id, 0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(ModifyOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(ModifyOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(ModifyOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ModifyOrder::VT_VERSION, version, 0);
  }
  void add_conditional_on_version(uint32_t conditional_on_version) {
    fbb_.AddElement<uint32_t>(ModifyOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit ModifyOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ModifyOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModifyOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  ModifyOrderBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

struct ModifyOrder::Traits {
  using type = ModifyOrder;
  static auto constexpr Create = CreateModifyOrder;
};

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    const char *routing_id = nullptr,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateModifyOrder(
      _fbb,
      account__,
      order_id,
      quantity,
      price,
      routing_id__,
      version,
      conditional_on_version);
}

struct OrderAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderAckBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_TYPE = 14,
    VT_ORIGIN = 16,
    VT_STATUS = 18,
    VT_ERROR = 20,
    VT_TEXT = 22,
    VT_REQUEST_ID = 24,
    VT_EXTERNAL_ACCOUNT = 26,
    VT_EXTERNAL_ORDER_ID = 28,
    VT_ROUTING_ID = 30,
    VT_VERSION = 32,
    VT_SIDE = 34,
    VT_ROUND_TRIP_LATENCY = 36
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  roq::fbs::RequestType type() const {
    return static_cast<roq::fbs::RequestType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  roq::fbs::Origin origin() const {
    return static_cast<roq::fbs::Origin>(GetField<uint8_t>(VT_ORIGIN, 0));
  }
  roq::fbs::RequestStatus status() const {
    return static_cast<roq::fbs::RequestStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  roq::fbs::Error error() const {
    return static_cast<roq::fbs::Error>(GetField<uint8_t>(VT_ERROR, 0));
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *request_id() const {
    return GetPointer<const flatbuffers::String *>(VT_REQUEST_ID);
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  roq::fbs::Side side() const {
    return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  int64_t round_trip_latency() const {
    return GetField<int64_t>(VT_ROUND_TRIP_LATENCY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ORIGIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_ERROR, 1) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_REQUEST_ID) &&
           verifier.VerifyString(request_id()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<int64_t>(verifier, VT_ROUND_TRIP_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct OrderAckBuilder {
  typedef OrderAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(OrderAck::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(OrderAck::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(OrderAck::VT_ORDER_ID, order_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(OrderAck::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(OrderAck::VT_SYMBOL, symbol);
  }
  void add_type(roq::fbs::RequestType type) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_origin(roq::fbs::Origin origin) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ORIGIN, static_cast<uint8_t>(origin), 0);
  }
  void add_status(roq::fbs::RequestStatus status) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_error(roq::fbs::Error error) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(OrderAck::VT_TEXT, text);
  }
  void add_request_id(flatbuffers::Offset<flatbuffers::String> request_id) {
    fbb_.AddOffset(OrderAck::VT_REQUEST_ID, request_id);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderAck::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(OrderAck::VT_VERSION, version, 0);
  }
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_round_trip_latency(int64_t round_trip_latency) {
    fbb_.AddElement<int64_t>(OrderAck::VT_ROUND_TRIP_LATENCY, round_trip_latency, 0);
  }
  explicit OrderAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OrderAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderAck> CreateOrderAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::RequestType type = roq::fbs::RequestType::Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin::Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus::Undefined,
    roq::fbs::Error error = roq::fbs::Error::Undefined,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> request_id = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    int64_t round_trip_latency = 0) {
  OrderAckBuilder builder_(_fbb);
  builder_.add_round_trip_latency(round_trip_latency);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_request_id(request_id);
  builder_.add_text(text);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_side(side);
  builder_.add_error(error);
  builder_.add_status(status);
  builder_.add_origin(origin);
  builder_.add_type(type);
  return builder_.Finish();
}

struct OrderAck::Traits {
  using type = OrderAck;
  static auto constexpr Create = CreateOrderAck;
};

inline flatbuffers::Offset<OrderAck> CreateOrderAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::RequestType type = roq::fbs::RequestType::Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin::Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus::Undefined,
    roq::fbs::Error error = roq::fbs::Error::Undefined,
    const char *text = nullptr,
    const char *request_id = nullptr,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    const char *routing_id = nullptr,
    uint32_t version = 0,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    int64_t round_trip_latency = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto request_id__ = request_id ? _fbb.CreateString(request_id) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateOrderAck(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      type,
      origin,
      status,
      error,
      text__,
      request_id__,
      external_account__,
      external_order_id__,
      routing_id__,
      version,
      side,
      round_trip_latency);
}

struct OrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_MAX_SHOW_QUANTITY = 18,
    VT_ORDER_TYPE = 20,
    VT_TIME_IN_FORCE = 22,
    VT_ZZZ_EXECUTION_INSTRUCTIONS = 24,
    VT_ORDER_TEMPLATE = 26,
    VT_CREATE_TIME_UTC = 28,
    VT_UPDATE_TIME_UTC = 30,
    VT_EXTERNAL_ACCOUNT = 32,
    VT_EXTERNAL_ORDER_ID = 34,
    VT_STATUS = 36,
    VT_QUANTITY = 38,
    VT_PRICE = 40,
    VT_STOP_PRICE = 42,
    VT_REMAINING_QUANTITY = 44,
    VT_TRADED_QUANTITY = 46,
    VT_AVERAGE_TRADED_PRICE = 48,
    VT_LAST_TRADED_QUANTITY = 50,
    VT_LAST_TRADED_PRICE = 52,
    VT_LAST_LIQUIDITY = 54,
    VT_ROUTING_ID = 56,
    VT_MAX_REQUEST_VERSION = 58,
    VT_MAX_RESPONSE_VERSION = 60,
    VT_MAX_ACCEPTED_VERSION = 62,
    VT_UPDATE_TYPE = 64,
    VT_EXECUTION_INSTRUCTIONS = 66,
    VT_USER = 68
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  roq::fbs::Side side() const {
    return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  uint8_t zzz_execution_instructions() const {
    return GetField<uint8_t>(VT_ZZZ_EXECUTION_INSTRUCTIONS, 0);
  }
  const flatbuffers::String *order_template() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_TEMPLATE);
  }
  int64_t create_time_utc() const {
    return GetField<int64_t>(VT_CREATE_TIME_UTC, 0);
  }
  int64_t update_time_utc() const {
    return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0);
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  roq::fbs::OrderStatus status() const {
    return static_cast<roq::fbs::OrderStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  double quantity() const {
    return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double price() const {
    return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double stop_price() const {
    return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double remaining_quantity() const {
    return GetField<double>(VT_REMAINING_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double traded_quantity() const {
    return GetField<double>(VT_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double average_traded_price() const {
    return GetField<double>(VT_AVERAGE_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_quantity() const {
    return GetField<double>(VT_LAST_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_price() const {
    return GetField<double>(VT_LAST_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::Liquidity last_liquidity() const {
    return static_cast<roq::fbs::Liquidity>(GetField<uint8_t>(VT_LAST_LIQUIDITY, 0));
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  uint32_t max_request_version() const {
    return GetField<uint32_t>(VT_MAX_REQUEST_VERSION, 0);
  }
  uint32_t max_response_version() const {
    return GetField<uint32_t>(VT_MAX_RESPONSE_VERSION, 0);
  }
  uint32_t max_accepted_version() const {
    return GetField<uint32_t>(VT_MAX_ACCEPTED_VERSION, 0);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  uint32_t execution_instructions() const {
    return GetField<uint32_t>(VT_EXECUTION_INSTRUCTIONS, 0);
  }
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY, 8) &&
           VerifyField<uint8_t>(verifier, VT_ORDER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZZZ_EXECUTION_INSTRUCTIONS, 1) &&
           VerifyOffset(verifier, VT_ORDER_TEMPLATE) &&
           verifier.VerifyString(order_template()) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC, 8) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_STOP_PRICE, 8) &&
           VerifyField<double>(verifier, VT_REMAINING_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_TRADED_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_AVERAGE_TRADED_PRICE, 8) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_PRICE, 8) &&
           VerifyField<uint8_t>(verifier, VT_LAST_LIQUIDITY, 1) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_REQUEST_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_RESPONSE_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ACCEPTED_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_EXECUTION_INSTRUCTIONS, 4) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           verifier.EndTable();
  }
};

struct OrderUpdateBuilder {
  typedef OrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(OrderUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(OrderUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_ORDER_ID, order_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(OrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(OrderUpdate::VT_SYMBOL, symbol);
  }
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_zzz_execution_instructions(uint8_t zzz_execution_instructions) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_ZZZ_EXECUTION_INSTRUCTIONS, zzz_execution_instructions, 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(OrderUpdate::VT_ORDER_TEMPLATE, order_template);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_status(roq::fbs::OrderStatus status) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(OrderUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(OrderUpdate::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_remaining_quantity(double remaining_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_REMAINING_QUANTITY, remaining_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_traded_quantity(double traded_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_TRADED_QUANTITY, traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_average_traded_price(double average_traded_price) {
    fbb_.AddElement<double>(OrderUpdate::VT_AVERAGE_TRADED_PRICE, average_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_quantity(double last_traded_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_LAST_TRADED_QUANTITY, last_traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_price(double last_traded_price) {
    fbb_.AddElement<double>(OrderUpdate::VT_LAST_TRADED_PRICE, last_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_liquidity(roq::fbs::Liquidity last_liquidity) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_LAST_LIQUIDITY, static_cast<uint8_t>(last_liquidity), 0);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_max_request_version(uint32_t max_request_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_REQUEST_VERSION, max_request_version, 0);
  }
  void add_max_response_version(uint32_t max_response_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_RESPONSE_VERSION, max_response_version, 0);
  }
  void add_max_accepted_version(uint32_t max_accepted_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_ACCEPTED_VERSION, max_accepted_version, 0);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_execution_instructions(uint32_t execution_instructions) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_EXECUTION_INSTRUCTIONS, execution_instructions, 0);
  }
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(OrderUpdate::VT_USER, user);
  }
  explicit OrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType::Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce::Undefined,
    uint8_t zzz_execution_instructions = 0,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus::Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity::Undefined,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t max_request_version = 0,
    uint32_t max_response_version = 0,
    uint32_t max_accepted_version = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    uint32_t execution_instructions = 0,
    flatbuffers::Offset<flatbuffers::String> user = 0) {
  OrderUpdateBuilder builder_(_fbb);
  builder_.add_last_traded_price(last_traded_price);
  builder_.add_last_traded_quantity(last_traded_quantity);
  builder_.add_average_traded_price(average_traded_price);
  builder_.add_traded_quantity(traded_quantity);
  builder_.add_remaining_quantity(remaining_quantity);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_user(user);
  builder_.add_execution_instructions(execution_instructions);
  builder_.add_max_accepted_version(max_accepted_version);
  builder_.add_max_response_version(max_response_version);
  builder_.add_max_request_version(max_request_version);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  builder_.add_last_liquidity(last_liquidity);
  builder_.add_status(status);
  builder_.add_zzz_execution_instructions(zzz_execution_instructions);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

struct OrderUpdate::Traits {
  using type = OrderUpdate;
  static auto constexpr Create = CreateOrderUpdate;
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType::Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce::Undefined,
    uint8_t zzz_execution_instructions = 0,
    const char *order_template = nullptr,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus::Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity::Undefined,
    const char *routing_id = nullptr,
    uint32_t max_request_version = 0,
    uint32_t max_response_version = 0,
    uint32_t max_accepted_version = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    uint32_t execution_instructions = 0,
    const char *user = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  auto user__ = user ? _fbb.CreateString(user) : 0;
  return roq::fbs::CreateOrderUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      max_show_quantity,
      order_type,
      time_in_force,
      zzz_execution_instructions,
      order_template__,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      status,
      quantity,
      price,
      stop_price,
      remaining_quantity,
      traded_quantity,
      average_traded_price,
      last_traded_quantity,
      last_traded_price,
      last_liquidity,
      routing_id__,
      max_request_version,
      max_response_version,
      max_accepted_version,
      update_type,
      execution_instructions,
      user__);
}

struct ParametersUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParametersUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETERS = 4,
    VT_UPDATE_TYPE = 6,
    VT_USER = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Parameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Parameter>> *>(VT_PARAMETERS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           verifier.EndTable();
  }
};

struct ParametersUpdateBuilder {
  typedef ParametersUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Parameter>>> parameters) {
    fbb_.AddOffset(ParametersUpdate::VT_PARAMETERS, parameters);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(ParametersUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(ParametersUpdate::VT_USER, user);
  }
  explicit ParametersUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ParametersUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParametersUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParametersUpdate> CreateParametersUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Parameter>>> parameters = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    flatbuffers::Offset<flatbuffers::String> user = 0) {
  ParametersUpdateBuilder builder_(_fbb);
  builder_.add_user(user);
  builder_.add_parameters(parameters);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct ParametersUpdate::Traits {
  using type = ParametersUpdate;
  static auto constexpr Create = CreateParametersUpdate;
};

inline flatbuffers::Offset<ParametersUpdate> CreateParametersUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<roq::fbs::Parameter>> *parameters = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    const char *user = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Parameter>>(*parameters) : 0;
  auto user__ = user ? _fbb.CreateString(user) : 0;
  return roq::fbs::CreateParametersUpdate(
      _fbb,
      parameters__,
      update_type,
      user__);
}

struct PositionUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PositionUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_EXTERNAL_ACCOUNT = 24,
    VT_LONG_QUANTITY = 26,
    VT_SHORT_QUANTITY = 28,
    VT_LONG_QUANTITY_BEGIN = 30,
    VT_SHORT_QUANTITY_BEGIN = 32
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  double long_quantity() const {
    return GetField<double>(VT_LONG_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double short_quantity() const {
    return GetField<double>(VT_SHORT_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double long_quantity_begin() const {
    return GetField<double>(VT_LONG_QUANTITY_BEGIN, std::numeric_limits<double>::quiet_NaN());
  }
  double short_quantity_begin() const {
    return GetField<double>(VT_SHORT_QUANTITY_BEGIN, std::numeric_limits<double>::quiet_NaN());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) &&
           VerifyField<double>(verifier, VT_LONG_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_SHORT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_LONG_QUANTITY_BEGIN, 8) &&
           VerifyField<double>(verifier, VT_SHORT_QUANTITY_BEGIN, 8) &&
           verifier.EndTable();
  }
};

struct PositionUpdateBuilder {
  typedef PositionUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(PositionUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(PositionUpdate::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(PositionUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(PositionUpdate::VT_SYMBOL, symbol);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(PositionUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_long_quantity(double long_quantity) {
    fbb_.AddElement<double>(PositionUpdate::VT_LONG_QUANTITY, long_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_short_quantity(double short_quantity) {
    fbb_.AddElement<double>(PositionUpdate::VT_SHORT_QUANTITY, short_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_long_quantity_begin(double long_quantity_begin) {
    fbb_.AddElement<double>(PositionUpdate::VT_LONG_QUANTITY_BEGIN, long_quantity_begin, std::numeric_limits<double>::quiet_NaN());
  }
  void add_short_quantity_begin(double short_quantity_begin) {
    fbb_.AddElement<double>(PositionUpdate::VT_SHORT_QUANTITY_BEGIN, short_quantity_begin, std::numeric_limits<double>::quiet_NaN());
  }
  explicit PositionUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PositionUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PositionUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    double long_quantity = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity = std::numeric_limits<double>::quiet_NaN(),
    double long_quantity_begin = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity_begin = std::numeric_limits<double>::quiet_NaN()) {
  PositionUpdateBuilder builder_(_fbb);
  builder_.add_short_quantity_begin(short_quantity_begin);
  builder_.add_long_quantity_begin(long_quantity_begin);
  builder_.add_short_quantity(short_quantity);
  builder_.add_long_quantity(long_quantity);
  builder_.add_external_account(external_account);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct PositionUpdate::Traits {
  using type = PositionUpdate;
  static auto constexpr Create = CreatePositionUpdate;
};

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const char *external_account = nullptr,
    double long_quantity = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity = std::numeric_limits<double>::quiet_NaN(),
    double long_quantity_begin = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity_begin = std::numeric_limits<double>::quiet_NaN()) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreatePositionUpdate(
      _fbb,
      stream_id,
      account__,
      exchange__,
      symbol__,
      external_account__,
      long_quantity,
      short_quantity,
      long_quantity_begin,
      short_quantity_begin);
}

struct RateLimitTrigger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RateLimitTriggerBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ORIGIN = 6,
    VT_TYPE = 8,
    VT_USERS = 10,
    VT_ACCOUNTS = 12,
    VT_BAN_EXPIRES = 14,
    VT_TRIGGERED_BY = 16,
    VT_BUFFER_CAPACITY = 18,
    VT_REMAINING_REQUESTS = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  roq::fbs::Origin origin() const {
    return static_cast<roq::fbs::Origin>(GetField<uint8_t>(VT_ORIGIN, 0));
  }
  roq::fbs::RateLimitType type() const {
    return static_cast<roq::fbs::RateLimitType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_USERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACCOUNTS);
  }
  int64_t ban_expires() const {
    return GetField<int64_t>(VT_BAN_EXPIRES, 0);
  }
  const flatbuffers::String *triggered_by() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIGGERED_BY);
  }
  roq::fbs::BufferCapacity buffer_capacity() const {
    return static_cast<roq::fbs::BufferCapacity>(GetField<uint8_t>(VT_BUFFER_CAPACITY, 0));
  }
  uint32_t remaining_requests() const {
    return GetField<uint32_t>(VT_REMAINING_REQUESTS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ORIGIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfStrings(users()) &&
           VerifyOffset(verifier, VT_ACCOUNTS) &&
           verifier.VerifyVector(accounts()) &&
           verifier.VerifyVectorOfStrings(accounts()) &&
           VerifyField<int64_t>(verifier, VT_BAN_EXPIRES, 8) &&
           VerifyOffset(verifier, VT_TRIGGERED_BY) &&
           verifier.VerifyString(triggered_by()) &&
           VerifyField<uint8_t>(verifier, VT_BUFFER_CAPACITY, 1) &&
           VerifyField<uint32_t>(verifier, VT_REMAINING_REQUESTS, 4) &&
           verifier.EndTable();
  }
};

struct RateLimitTriggerBuilder {
  typedef RateLimitTrigger Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RateLimitTrigger::VT_NAME, name);
  }
  void add_origin(roq::fbs::Origin origin) {
    fbb_.AddElement<uint8_t>(RateLimitTrigger::VT_ORIGIN, static_cast<uint8_t>(origin), 0);
  }
  void add_type(roq::fbs::RateLimitType type) {
    fbb_.AddElement<uint8_t>(RateLimitTrigger::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> users) {
    fbb_.AddOffset(RateLimitTrigger::VT_USERS, users);
  }
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts) {
    fbb_.AddOffset(RateLimitTrigger::VT_ACCOUNTS, accounts);
  }
  void add_ban_expires(int64_t ban_expires) {
    fbb_.AddElement<int64_t>(RateLimitTrigger::VT_BAN_EXPIRES, ban_expires, 0);
  }
  void add_triggered_by(flatbuffers::Offset<flatbuffers::String> triggered_by) {
    fbb_.AddOffset(RateLimitTrigger::VT_TRIGGERED_BY, triggered_by);
  }
  void add_buffer_capacity(roq::fbs::BufferCapacity buffer_capacity) {
    fbb_.AddElement<uint8_t>(RateLimitTrigger::VT_BUFFER_CAPACITY, static_cast<uint8_t>(buffer_capacity), 0);
  }
  void add_remaining_requests(uint32_t remaining_requests) {
    fbb_.AddElement<uint32_t>(RateLimitTrigger::VT_REMAINING_REQUESTS, remaining_requests, 0);
  }
  explicit RateLimitTriggerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RateLimitTrigger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RateLimitTrigger>(end);
    return o;
  }
};

inline flatbuffers::Offset<RateLimitTrigger> CreateRateLimitTrigger(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    roq::fbs::Origin origin = roq::fbs::Origin::Undefined,
    roq::fbs::RateLimitType type = roq::fbs::RateLimitType::Undefined,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts = 0,
    int64_t ban_expires = 0,
    flatbuffers::Offset<flatbuffers::String> triggered_by = 0,
    roq::fbs::BufferCapacity buffer_capacity = roq::fbs::BufferCapacity::Undefined,
    uint32_t remaining_requests = 0) {
  RateLimitTriggerBuilder builder_(_fbb);
  builder_.add_ban_expires(ban_expires);
  builder_.add_remaining_requests(remaining_requests);
  builder_.add_triggered_by(triggered_by);
  builder_.add_accounts(accounts);
  builder_.add_users(users);
  builder_.add_name(name);
  builder_.add_buffer_capacity(buffer_capacity);
  builder_.add_type(type);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct RateLimitTrigger::Traits {
  using type = RateLimitTrigger;
  static auto constexpr Create = CreateRateLimitTrigger;
};

inline flatbuffers::Offset<RateLimitTrigger> CreateRateLimitTriggerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    roq::fbs::Origin origin = roq::fbs::Origin::Undefined,
    roq::fbs::RateLimitType type = roq::fbs::RateLimitType::Undefined,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *users = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *accounts = nullptr,
    int64_t ban_expires = 0,
    const char *triggered_by = nullptr,
    roq::fbs::BufferCapacity buffer_capacity = roq::fbs::BufferCapacity::Undefined,
    uint32_t remaining_requests = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*users) : 0;
  auto accounts__ = accounts ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*accounts) : 0;
  auto triggered_by__ = triggered_by ? _fbb.CreateString(triggered_by) : 0;
  return roq::fbs::CreateRateLimitTrigger(
      _fbb,
      name__,
      origin,
      type,
      users__,
      accounts__,
      ban_expires,
      triggered_by__,
      buffer_capacity,
      remaining_requests);
}

struct ReferenceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReferenceDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_DESCRIPTION = 10,
    VT_SECURITY_TYPE = 12,
    VT_QUOTE_CURRENCY = 14,
    VT_BASE_CURRENCY = 16,
    VT_COMMISSION_CURRENCY = 18,
    VT_TICK_SIZE = 20,
    VT_MULTIPLIER = 22,
    VT_MIN_TRADE_VOL = 24,
    VT_OPTION_TYPE = 26,
    VT_STRIKE_CURRENCY = 28,
    VT_STRIKE_PRICE = 30,
    VT_UNDERLYING = 32,
    VT_TIME_ZONE = 34,
    VT_ISSUE_DATE = 36,
    VT_SETTLEMENT_DATE = 38,
    VT_EXPIRY_DATETIME = 40,
    VT_EXPIRY_DATETIME_UTC = 42,
    VT_MAX_TRADE_VOL = 44,
    VT_TRADE_VOL_STEP_SIZE = 46,
    VT_MARGIN_CURRENCY = 48,
    VT_DISCARD = 50,
    VT_MIN_NOTIONAL = 52
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  roq::fbs::SecurityType security_type() const {
    return static_cast<roq::fbs::SecurityType>(GetField<uint8_t>(VT_SECURITY_TYPE, 0));
  }
  const flatbuffers::String *quote_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_QUOTE_CURRENCY);
  }
  const flatbuffers::String *base_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_BASE_CURRENCY);
  }
  const flatbuffers::String *commission_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMISSION_CURRENCY);
  }
  double tick_size() const {
    return GetField<double>(VT_TICK_SIZE, std::numeric_limits<double>::quiet_NaN());
  }
  double multiplier() const {
    return GetField<double>(VT_MULTIPLIER, std::numeric_limits<double>::quiet_NaN());
  }
  double min_trade_vol() const {
    return GetField<double>(VT_MIN_TRADE_VOL, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OptionType option_type() const {
    return static_cast<roq::fbs::OptionType>(GetField<uint8_t>(VT_OPTION_TYPE, 0));
  }
  const flatbuffers::String *strike_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_STRIKE_CURRENCY);
  }
  double strike_price() const {
    return GetField<double>(VT_STRIKE_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *underlying() const {
    return GetPointer<const flatbuffers::String *>(VT_UNDERLYING);
  }
  const flatbuffers::String *time_zone() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME_ZONE);
  }
  int32_t issue_date() const {
    return GetField<int32_t>(VT_ISSUE_DATE, 0);
  }
  int32_t settlement_date() const {
    return GetField<int32_t>(VT_SETTLEMENT_DATE, 0);
  }
  int64_t expiry_datetime() const {
    return GetField<int64_t>(VT_EXPIRY_DATETIME, 0);
  }
  int64_t expiry_datetime_utc() const {
    return GetField<int64_t>(VT_EXPIRY_DATETIME_UTC, 0);
  }
  double max_trade_vol() const {
    return GetField<double>(VT_MAX_TRADE_VOL, std::numeric_limits<double>::quiet_NaN());
  }
  double trade_vol_step_size() const {
    return GetField<double>(VT_TRADE_VOL_STEP_SIZE, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *margin_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_MARGIN_CURRENCY);
  }
  bool discard() const {
    return GetField<uint8_t>(VT_DISCARD, 0) != 0;
  }
  double min_notional() const {
    return GetField<double>(VT_MIN_NOTIONAL, std::numeric_limits<double>::quiet_NaN());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_SECURITY_TYPE, 1) &&
           VerifyOffset(verifier, VT_QUOTE_CURRENCY) &&
           verifier.VerifyString(quote_currency()) &&
           VerifyOffset(verifier, VT_BASE_CURRENCY) &&
           verifier.VerifyString(base_currency()) &&
           VerifyOffset(verifier, VT_COMMISSION_CURRENCY) &&
           verifier.VerifyString(commission_currency()) &&
           VerifyField<double>(verifier, VT_TICK_SIZE, 8) &&
           VerifyField<double>(verifier, VT_MULTIPLIER, 8) &&
           VerifyField<double>(verifier, VT_MIN_TRADE_VOL, 8) &&
           VerifyField<uint8_t>(verifier, VT_OPTION_TYPE, 1) &&
           VerifyOffset(verifier, VT_STRIKE_CURRENCY) &&
           verifier.VerifyString(strike_currency()) &&
           VerifyField<double>(verifier, VT_STRIKE_PRICE, 8) &&
           VerifyOffset(verifier, VT_UNDERLYING) &&
           verifier.VerifyString(underlying()) &&
           VerifyOffset(verifier, VT_TIME_ZONE) &&
           verifier.VerifyString(time_zone()) &&
           VerifyField<int32_t>(verifier, VT_ISSUE_DATE, 4) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DATE, 4) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME, 8) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME_UTC, 8) &&
           VerifyField<double>(verifier, VT_MAX_TRADE_VOL, 8) &&
           VerifyField<double>(verifier, VT_TRADE_VOL_STEP_SIZE, 8) &&
           VerifyOffset(verifier, VT_MARGIN_CURRENCY) &&
           verifier.VerifyString(margin_currency()) &&
           VerifyField<uint8_t>(verifier, VT_DISCARD, 1) &&
           VerifyField<double>(verifier, VT_MIN_NOTIONAL, 8) &&
           verifier.EndTable();
  }
};

struct ReferenceDataBuilder {
  typedef ReferenceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(ReferenceData::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(ReferenceData::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(ReferenceData::VT_SYMBOL, symbol);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(ReferenceData::VT_DESCRIPTION, description);
  }
  void add_security_type(roq::fbs::SecurityType security_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_SECURITY_TYPE, static_cast<uint8_t>(security_type), 0);
  }
  void add_quote_currency(flatbuffers::Offset<flatbuffers::String> quote_currency) {
    fbb_.AddOffset(ReferenceData::VT_QUOTE_CURRENCY, quote_currency);
  }
  void add_base_currency(flatbuffers::Offset<flatbuffers::String> base_currency) {
    fbb_.AddOffset(ReferenceData::VT_BASE_CURRENCY, base_currency);
  }
  void add_commission_currency(flatbuffers::Offset<flatbuffers::String> commission_currency) {
    fbb_.AddOffset(ReferenceData::VT_COMMISSION_CURRENCY, commission_currency);
  }
  void add_tick_size(double tick_size) {
    fbb_.AddElement<double>(ReferenceData::VT_TICK_SIZE, tick_size, std::numeric_limits<double>::quiet_NaN());
  }
  void add_multiplier(double multiplier) {
    fbb_.AddElement<double>(ReferenceData::VT_MULTIPLIER, multiplier, std::numeric_limits<double>::quiet_NaN());
  }
  void add_min_trade_vol(double min_trade_vol) {
    fbb_.AddElement<double>(ReferenceData::VT_MIN_TRADE_VOL, min_trade_vol, std::numeric_limits<double>::quiet_NaN());
  }
  void add_option_type(roq::fbs::OptionType option_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_OPTION_TYPE, static_cast<uint8_t>(option_type), 0);
  }
  void add_strike_currency(flatbuffers::Offset<flatbuffers::String> strike_currency) {
    fbb_.AddOffset(ReferenceData::VT_STRIKE_CURRENCY, strike_currency);
  }
  void add_strike_price(double strike_price) {
    fbb_.AddElement<double>(ReferenceData::VT_STRIKE_PRICE, strike_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_underlying(flatbuffers::Offset<flatbuffers::String> underlying) {
    fbb_.AddOffset(ReferenceData::VT_UNDERLYING, underlying);
  }
  void add_time_zone(flatbuffers::Offset<flatbuffers::String> time_zone) {
    fbb_.AddOffset(ReferenceData::VT_TIME_ZONE, time_zone);
  }
  void add_issue_date(int32_t issue_date) {
    fbb_.AddElement<int32_t>(ReferenceData::VT_ISSUE_DATE, issue_date, 0);
  }
  void add_settlement_date(int32_t settlement_date) {
    fbb_.AddElement<int32_t>(ReferenceData::VT_SETTLEMENT_DATE, settlement_date, 0);
  }
  void add_expiry_datetime(int64_t expiry_datetime) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME, expiry_datetime, 0);
  }
  void add_expiry_datetime_utc(int64_t expiry_datetime_utc) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME_UTC, expiry_datetime_utc, 0);
  }
  void add_max_trade_vol(double max_trade_vol) {
    fbb_.AddElement<double>(ReferenceData::VT_MAX_TRADE_VOL, max_trade_vol, std::numeric_limits<double>::quiet_NaN());
  }
  void add_trade_vol_step_size(double trade_vol_step_size) {
    fbb_.AddElement<double>(ReferenceData::VT_TRADE_VOL_STEP_SIZE, trade_vol_step_size, std::numeric_limits<double>::quiet_NaN());
  }
  void add_margin_currency(flatbuffers::Offset<flatbuffers::String> margin_currency) {
    fbb_.AddOffset(ReferenceData::VT_MARGIN_CURRENCY, margin_currency);
  }
  void add_discard(bool discard) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_DISCARD, static_cast<uint8_t>(discard), 0);
  }
  void add_min_notional(double min_notional) {
    fbb_.AddElement<double>(ReferenceData::VT_MIN_NOTIONAL, min_notional, std::numeric_limits<double>::quiet_NaN());
  }
  explicit ReferenceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReferenceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReferenceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReferenceData> CreateReferenceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType::Undefined,
    flatbuffers::Offset<flatbuffers::String> quote_currency = 0,
    flatbuffers::Offset<flatbuffers::String> base_currency = 0,
    flatbuffers::Offset<flatbuffers::String> commission_currency = 0,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType::Undefined,
    flatbuffers::Offset<flatbuffers::String> strike_currency = 0,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> underlying = 0,
    flatbuffers::Offset<flatbuffers::String> time_zone = 0,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0,
    double max_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    double trade_vol_step_size = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> margin_currency = 0,
    bool discard = false,
    double min_notional = std::numeric_limits<double>::quiet_NaN()) {
  ReferenceDataBuilder builder_(_fbb);
  builder_.add_min_notional(min_notional);
  builder_.add_trade_vol_step_size(trade_vol_step_size);
  builder_.add_max_trade_vol(max_trade_vol);
  builder_.add_expiry_datetime_utc(expiry_datetime_utc);
  builder_.add_expiry_datetime(expiry_datetime);
  builder_.add_strike_price(strike_price);
  builder_.add_min_trade_vol(min_trade_vol);
  builder_.add_multiplier(multiplier);
  builder_.add_tick_size(tick_size);
  builder_.add_margin_currency(margin_currency);
  builder_.add_settlement_date(settlement_date);
  builder_.add_issue_date(issue_date);
  builder_.add_time_zone(time_zone);
  builder_.add_underlying(underlying);
  builder_.add_strike_currency(strike_currency);
  builder_.add_commission_currency(commission_currency);
  builder_.add_base_currency(base_currency);
  builder_.add_quote_currency(quote_currency);
  builder_.add_description(description);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_discard(discard);
  builder_.add_option_type(option_type);
  builder_.add_security_type(security_type);
  return builder_.Finish();
}

struct ReferenceData::Traits {
  using type = ReferenceData;
  static auto constexpr Create = CreateReferenceData;
};

inline flatbuffers::Offset<ReferenceData> CreateReferenceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const char *description = nullptr,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType::Undefined,
    const char *quote_currency = nullptr,
    const char *base_currency = nullptr,
    const char *commission_currency = nullptr,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType::Undefined,
    const char *strike_currency = nullptr,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    const char *underlying = nullptr,
    const char *time_zone = nullptr,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0,
    double max_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    double trade_vol_step_size = std::numeric_limits<double>::quiet_NaN(),
    const char *margin_currency = nullptr,
    bool discard = false,
    double min_notional = std::numeric_limits<double>::quiet_NaN()) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto quote_currency__ = quote_currency ? _fbb.CreateString(quote_currency) : 0;
  auto base_currency__ = base_currency ? _fbb.CreateString(base_currency) : 0;
  auto commission_currency__ = commission_currency ? _fbb.CreateString(commission_currency) : 0;
  auto strike_currency__ = strike_currency ? _fbb.CreateString(strike_currency) : 0;
  auto underlying__ = underlying ? _fbb.CreateString(underlying) : 0;
  auto time_zone__ = time_zone ? _fbb.CreateString(time_zone) : 0;
  auto margin_currency__ = margin_currency ? _fbb.CreateString(margin_currency) : 0;
  return roq::fbs::CreateReferenceData(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      description__,
      security_type,
      quote_currency__,
      base_currency__,
      commission_currency__,
      tick_size,
      multiplier,
      min_trade_vol,
      option_type,
      strike_currency__,
      strike_price,
      underlying__,
      time_zone__,
      issue_date,
      settlement_date,
      expiry_datetime,
      expiry_datetime_utc,
      max_trade_vol,
      trade_vol_step_size,
      margin_currency__,
      discard,
      min_notional);
}

struct StatisticsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_STATISTICS = 10,
    VT_UPDATE_TYPE = 12,
    VT_EXCHANGE_TIME_UTC = 14
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> *statistics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> *>(VT_STATISTICS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const {
    return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyVector(statistics()) &&
           verifier.VerifyVectorOfTables(statistics()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           verifier.EndTable();
  }
};

struct StatisticsUpdateBuilder {
  typedef StatisticsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(StatisticsUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(StatisticsUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(StatisticsUpdate::VT_SYMBOL, symbol);
  }
  void add_statistics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics) {
    fbb_.AddOffset(StatisticsUpdate::VT_STATISTICS, statistics);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(StatisticsUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(StatisticsUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit StatisticsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatisticsUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatisticsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0) {
  StatisticsUpdateBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_statistics(statistics);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct StatisticsUpdate::Traits {
  using type = StatisticsUpdate;
  static auto constexpr Create = CreateStatisticsUpdate;
};

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Statistics>> *statistics = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto statistics__ = statistics ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Statistics>>(*statistics) : 0;
  return roq::fbs::CreateStatisticsUpdate(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      statistics__,
      update_type,
      exchange_time_utc);
}

struct StreamStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StreamStatusBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_SUPPORTS = 8,
    VT_CONNECTION_STATUS = 10,
    VT_PROTOCOL = 12,
    VT_PRIORITY = 14,
    VT_TRANSPORT = 16,
    VT_ENCODING = 18
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint64_t supports() const {
    return GetField<uint64_t>(VT_SUPPORTS, 0);
  }
  roq::fbs::ConnectionStatus connection_status() const {
    return static_cast<roq::fbs::ConnectionStatus>(GetField<uint8_t>(VT_CONNECTION_STATUS, 0));
  }
  roq::fbs::Protocol protocol() const {
    return static_cast<roq::fbs::Protocol>(GetField<uint8_t>(VT_PROTOCOL, 0));
  }
  roq::fbs::Priority priority() const {
    return static_cast<roq::fbs::Priority>(GetField<uint32_t>(VT_PRIORITY, 0));
  }
  roq::fbs::Transport transport() const {
    return static_cast<roq::fbs::Transport>(GetField<uint8_t>(VT_TRANSPORT, 0));
  }
  uint32_t encoding() const {
    return GetField<uint32_t>(VT_ENCODING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTS, 8) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTION_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPORT, 1) &&
           VerifyField<uint32_t>(verifier, VT_ENCODING, 4) &&
           verifier.EndTable();
  }
};

struct StreamStatusBuilder {
  typedef StreamStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(StreamStatus::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(StreamStatus::VT_ACCOUNT, account);
  }
  void add_supports(uint64_t supports) {
    fbb_.AddElement<uint64_t>(StreamStatus::VT_SUPPORTS, supports, 0);
  }
  void add_connection_status(roq::fbs::ConnectionStatus connection_status) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_CONNECTION_STATUS, static_cast<uint8_t>(connection_status), 0);
  }
  void add_protocol(roq::fbs::Protocol protocol) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_PROTOCOL, static_cast<uint8_t>(protocol), 0);
  }
  void add_priority(roq::fbs::Priority priority) {
    fbb_.AddElement<uint32_t>(StreamStatus::VT_PRIORITY, static_cast<uint32_t>(priority), 0);
  }
  void add_transport(roq::fbs::Transport transport) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_TRANSPORT, static_cast<uint8_t>(transport), 0);
  }
  void add_encoding(uint32_t encoding) {
    fbb_.AddElement<uint32_t>(StreamStatus::VT_ENCODING, encoding, 0);
  }
  explicit StreamStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StreamStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StreamStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<StreamStatus> CreateStreamStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus connection_status = roq::fbs::ConnectionStatus::Undefined,
    roq::fbs::Protocol protocol = roq::fbs::Protocol::Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority::Undefined,
    roq::fbs::Transport transport = roq::fbs::Transport::Undefined,
    uint32_t encoding = 0) {
  StreamStatusBuilder builder_(_fbb);
  builder_.add_supports(supports);
  builder_.add_encoding(encoding);
  builder_.add_priority(priority);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_transport(transport);
  builder_.add_protocol(protocol);
  builder_.add_connection_status(connection_status);
  return builder_.Finish();
}

struct StreamStatus::Traits {
  using type = StreamStatus;
  static auto constexpr Create = CreateStreamStatus;
};

inline flatbuffers::Offset<StreamStatus> CreateStreamStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus connection_status = roq::fbs::ConnectionStatus::Undefined,
    roq::fbs::Protocol protocol = roq::fbs::Protocol::Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority::Undefined,
    roq::fbs::Transport transport = roq::fbs::Transport::Undefined,
    uint32_t encoding = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateStreamStatus(
      _fbb,
      stream_id,
      account__,
      supports,
      connection_status,
      protocol,
      priority,
      transport,
      encoding);
}

struct TopOfBook FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopOfBookBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_LAYER = 10,
    VT_UPDATE_TYPE = 12,
    VT_EXCHANGE_TIME_UTC = 14,
    VT_EXCHANGE_SEQUENCE = 16
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const roq::fbs::Layer *layer() const {
    return GetPointer<const roq::fbs::Layer *>(VT_LAYER);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const {
    return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0);
  }
  int64_t exchange_sequence() const {
    return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_LAYER) &&
           verifier.VerifyTable(layer()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           verifier.EndTable();
  }
};

struct TopOfBookBuilder {
  typedef TopOfBook Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(TopOfBook::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TopOfBook::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(TopOfBook::VT_SYMBOL, symbol);
  }
  void add_layer(flatbuffers::Offset<roq::fbs::Layer> layer) {
    fbb_.AddOffset(TopOfBook::VT_LAYER, layer);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(TopOfBook::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TopOfBook::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(TopOfBook::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  explicit TopOfBookBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopOfBook> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopOfBook>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopOfBook> CreateTopOfBook(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  TopOfBookBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_layer(layer);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

struct TopOfBook::Traits {
  using type = TopOfBook;
  static auto constexpr Create = CreateTopOfBook;
};

inline flatbuffers::Offset<TopOfBook> CreateTopOfBookDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateTopOfBook(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      layer,
      update_type,
      exchange_time_utc,
      exchange_sequence);
}

struct TradeSummary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeSummaryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADES = 10,
    VT_EXCHANGE_TIME_UTC = 12,
    VT_EXCHANGE_SEQUENCE = 14
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> *trades() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> *>(VT_TRADES);
  }
  int64_t exchange_time_utc() const {
    return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0);
  }
  int64_t exchange_sequence() const {
    return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_TRADES) &&
           verifier.VerifyVector(trades()) &&
           verifier.VerifyVectorOfTables(trades()) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           verifier.EndTable();
  }
};

struct TradeSummaryBuilder {
  typedef TradeSummary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(TradeSummary::VT_STREAM_ID, stream_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeSummary::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(TradeSummary::VT_SYMBOL, symbol);
  }
  void add_trades(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades) {
    fbb_.AddOffset(TradeSummary::VT_TRADES, trades);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TradeSummary::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(TradeSummary::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  explicit TradeSummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TradeSummary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSummary>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSummary> CreateTradeSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades = 0,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  TradeSummaryBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_trades(trades);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct TradeSummary::Traits {
  using type = TradeSummary;
  static auto constexpr Create = CreateTradeSummary;
};

inline flatbuffers::Offset<TradeSummary> CreateTradeSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Trade>> *trades = nullptr,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto trades__ = trades ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Trade>>(*trades) : 0;
  return roq::fbs::CreateTradeSummary(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      trades__,
      exchange_time_utc,
      exchange_sequence);
}

struct TradeUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeUpdateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_CREATE_TIME_UTC = 18,
    VT_UPDATE_TIME_UTC = 20,
    VT_EXTERNAL_ACCOUNT = 22,
    VT_EXTERNAL_ORDER_ID = 24,
    VT_FILLS = 26,
    VT_ROUTING_ID = 28,
    VT_UPDATE_TYPE = 30,
    VT_USER = 32
  };
  uint16_t stream_id() const {
    return GetField<uint16_t>(VT_STREAM_ID, 0);
  }
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  uint32_t order_id() const {
    return GetField<uint32_t>(VT_ORDER_ID, 0);
  }
  const flatbuffers::String *exchange() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE);
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  roq::fbs::Side side() const {
    return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0));
  }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  int64_t create_time_utc() const {
    return GetField<int64_t>(VT_CREATE_TIME_UTC, 0);
  }
  int64_t update_time_utc() const {
    return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0);
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> *fills() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> *>(VT_FILLS);
  }
  const flatbuffers::String *routing_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  const flatbuffers::String *user() const {
    return GetPointer<const flatbuffers::String *>(VT_USER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) &&
           VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC, 8) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) &&
           VerifyOffset(verifier, VT_FILLS) &&
           verifier.VerifyVector(fills()) &&
           verifier.VerifyVectorOfTables(fills()) &&
           VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyString(user()) &&
           verifier.EndTable();
  }
};

struct TradeUpdateBuilder {
  typedef TradeUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) {
    fbb_.AddElement<uint16_t>(TradeUpdate::VT_STREAM_ID, stream_id, 0);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(TradeUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) {
    fbb_.AddElement<uint32_t>(TradeUpdate::VT_ORDER_ID, order_id, 0);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(TradeUpdate::VT_SYMBOL, symbol);
  }
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_fills(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills) {
    fbb_.AddOffset(TradeUpdate::VT_FILLS, fills);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(TradeUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_user(flatbuffers::Offset<flatbuffers::String> user) {
    fbb_.AddOffset(TradeUpdate::VT_USER, user);
  }
  explicit TradeUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TradeUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    flatbuffers::Offset<flatbuffers::String> user = 0) {
  TradeUpdateBuilder builder_(_fbb);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_user(user);
  builder_.add_routing_id(routing_id);
  builder_.add_fills(fills);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

struct TradeUpdate::Traits {
  using type = TradeUpdate;
  static auto constexpr Create = CreateTradeUpdate;
};

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side::Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect::Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Fill>> *fills = nullptr,
    const char *routing_id = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType::Undefined,
    const char *user = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto fills__ = fills ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Fill>>(*fills) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  auto user__ = user ? _fbb.CreateString(user) : 0;
  return roq::fbs::CreateTradeUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      fills__,
      routing_id__,
      update_type,
      user__);
}

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_UUID = 12,
    VT_LOGIN = 14,
    VT_PASSWORD = 16
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *application() const {
    return GetPointer<const flatbuffers::String *>(VT_APPLICATION);
  }
  const flatbuffers::String *hostname() const {
    return GetPointer<const flatbuffers::String *>(VT_HOSTNAME);
  }
  uint32_t pid() const {
    return GetField<uint32_t>(VT_PID, 0);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *login() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGIN);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_APPLICATION) &&
           verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID, 4) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_LOGIN) &&
           verifier.VerifyString(login()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct HandshakeBuilder {
  typedef Handshake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Handshake::VT_VERSION, version, 0);
  }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(Handshake::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(Handshake::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) {
    fbb_.AddElement<uint32_t>(Handshake::VT_PID, pid, 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Handshake::VT_UUID, uuid);
  }
  void add_login(flatbuffers::Offset<flatbuffers::String> login) {
    fbb_.AddOffset(Handshake::VT_LOGIN, login);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Handshake::VT_PASSWORD, password);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Handshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> login = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_login(login);
  builder_.add_uuid(uuid);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Handshake::Traits {
  using type = Handshake;
  static auto constexpr Create = CreateHandshake;
};

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const char *application = nullptr,
    const char *hostname = nullptr,
    uint32_t pid = 0,
    const char *uuid = nullptr,
    const char *login = nullptr,
    const char *password = nullptr) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto login__ = login ? _fbb.CreateString(login) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return roq::fbs::CreateHandshake(
      _fbb,
      version,
      application__,
      hostname__,
      pid,
      uuid__,
      login__,
      password__);
}

struct HandshakeAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeAckBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_FAILURE = 12,
    VT_FAILURE_REASON = 14,
    VT_UUID = 16,
    VT_NAME = 18,
    VT_USER_ID = 20
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *application() const {
    return GetPointer<const flatbuffers::String *>(VT_APPLICATION);
  }
  const flatbuffers::String *hostname() const {
    return GetPointer<const flatbuffers::String *>(VT_HOSTNAME);
  }
  uint32_t pid() const {
    return GetField<uint32_t>(VT_PID, 0);
  }
  bool failure() const {
    return GetField<uint8_t>(VT_FAILURE, 0) != 0;
  }
  const flatbuffers::String *failure_reason() const {
    return GetPointer<const flatbuffers::String *>(VT_FAILURE_REASON);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t user_id() const {
    return GetField<uint8_t>(VT_USER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_APPLICATION) &&
           verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID, 4) &&
           VerifyField<uint8_t>(verifier, VT_FAILURE, 1) &&
           VerifyOffset(verifier, VT_FAILURE_REASON) &&
           verifier.VerifyString(failure_reason()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_USER_ID, 1) &&
           verifier.EndTable();
  }
};

struct HandshakeAckBuilder {
  typedef HandshakeAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(HandshakeAck::VT_VERSION, version, 0);
  }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(HandshakeAck::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(HandshakeAck::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) {
    fbb_.AddElement<uint32_t>(HandshakeAck::VT_PID, pid, 0);
  }
  void add_failure(bool failure) {
    fbb_.AddElement<uint8_t>(HandshakeAck::VT_FAILURE, static_cast<uint8_t>(failure), 0);
  }
  void add_failure_reason(flatbuffers::Offset<flatbuffers::String> failure_reason) {
    fbb_.AddOffset(HandshakeAck::VT_FAILURE_REASON, failure_reason);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(HandshakeAck::VT_UUID, uuid);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HandshakeAck::VT_NAME, name);
  }
  void add_user_id(uint8_t user_id) {
    fbb_.AddElement<uint8_t>(HandshakeAck::VT_USER_ID, user_id, 0);
  }
  explicit HandshakeAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HandshakeAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    bool failure = false,
    flatbuffers::Offset<flatbuffers::String> failure_reason = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t user_id = 0) {
  HandshakeAckBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  builder_.add_failure_reason(failure_reason);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  builder_.add_user_id(user_id);
  builder_.add_failure(failure);
  return builder_.Finish();
}

struct HandshakeAck::Traits {
  using type = HandshakeAck;
  static auto constexpr Create = CreateHandshakeAck;
};

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const char *application = nullptr,
    const char *hostname = nullptr,
    uint32_t pid = 0,
    bool failure = false,
    const char *failure_reason = nullptr,
    const char *uuid = nullptr,
    const char *name = nullptr,
    uint8_t user_id = 0) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto failure_reason__ = failure_reason ? _fbb.CreateString(failure_reason) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return roq::fbs::CreateHandshakeAck(
      _fbb,
      version,
      application__,
      hostname__,
      pid,
      failure,
      failure_reason__,
      uuid__,
      name__,
      user_id);
}

struct Subscribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubscribeBuilder {
  typedef Subscribe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubscribeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Subscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Subscribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Subscribe> CreateSubscribe(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubscribeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Subscribe::Traits {
  using type = Subscribe;
  static auto constexpr Create = CreateSubscribe;
};

struct BatchBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchBeginBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchBeginBuilder {
  typedef BatchBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchBegin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchBegin> CreateBatchBegin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchBeginBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchBegin::Traits {
  using type = BatchBegin;
  static auto constexpr Create = CreateBatchBegin;
};

struct BatchEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchEndBuilder Builder;
  struct Traits;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchEndBuilder {
  typedef BatchEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchEnd> CreateBatchEnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchEndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchEnd::Traits {
  using type = BatchEnd;
  static auto constexpr Create = CreateBatchEnd;
};

struct SourceInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQNO = 4,
    VT_SEND_TIME_UTC = 6,
    VT_CREATE_TIME_UTC = 8,
    VT_SEND_TIME = 10,
    VT_CREATE_TIME = 12
  };
  uint64_t seqno() const {
    return GetField<uint64_t>(VT_SEQNO, 0);
  }
  uint64_t send_time_utc() const {
    return GetField<uint64_t>(VT_SEND_TIME_UTC, 0);
  }
  uint64_t create_time_utc() const {
    return GetField<uint64_t>(VT_CREATE_TIME_UTC, 0);
  }
  uint64_t send_time() const {
    return GetField<uint64_t>(VT_SEND_TIME, 0);
  }
  uint64_t create_time() const {
    return GetField<uint64_t>(VT_CREATE_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SEQNO, 8) &&
           VerifyField<uint64_t>(verifier, VT_SEND_TIME_UTC, 8) &&
           VerifyField<uint64_t>(verifier, VT_CREATE_TIME_UTC, 8) &&
           VerifyField<uint64_t>(verifier, VT_SEND_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_CREATE_TIME, 8) &&
           verifier.EndTable();
  }
};

struct SourceInfoBuilder {
  typedef SourceInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqno(uint64_t seqno) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_SEQNO, seqno, 0);
  }
  void add_send_time_utc(uint64_t send_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME_UTC, send_time_utc, 0);
  }
  void add_create_time_utc(uint64_t create_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_send_time(uint64_t send_time) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME, send_time, 0);
  }
  void add_create_time(uint64_t create_time) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME, create_time, 0);
  }
  explicit SourceInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SourceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceInfo> CreateSourceInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seqno = 0,
    uint64_t send_time_utc = 0,
    uint64_t create_time_utc = 0,
    uint64_t send_time = 0,
    uint64_t create_time = 0) {
  SourceInfoBuilder builder_(_fbb);
  builder_.add_create_time(create_time);
  builder_.add_send_time(send_time);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_send_time_utc(send_time_utc);
  builder_.add_seqno(seqno);
  return builder_.Finish();
}

struct SourceInfo::Traits {
  using type = SourceInfo;
  static auto constexpr Create = CreateSourceInfo;
};

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_INFO = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  const roq::fbs::SourceInfo *source_info() const {
    return GetPointer<const roq::fbs::SourceInfo *>(VT_SOURCE_INFO);
  }
  roq::fbs::Message message_type() const {
    return static_cast<roq::fbs::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const roq::fbs::Handshake *message_as_Handshake() const {
    return message_type() == roq::fbs::Message::Handshake ? static_cast<const roq::fbs::Handshake *>(message()) : nullptr;
  }
  const roq::fbs::HandshakeAck *message_as_HandshakeAck() const {
    return message_type() == roq::fbs::Message::HandshakeAck ? static_cast<const roq::fbs::HandshakeAck *>(message()) : nullptr;
  }
  const roq::fbs::Subscribe *message_as_Subscribe() const {
    return message_type() == roq::fbs::Message::Subscribe ? static_cast<const roq::fbs::Subscribe *>(message()) : nullptr;
  }
  const roq::fbs::BatchBegin *message_as_BatchBegin() const {
    return message_type() == roq::fbs::Message::BatchBegin ? static_cast<const roq::fbs::BatchBegin *>(message()) : nullptr;
  }
  const roq::fbs::BatchEnd *message_as_BatchEnd() const {
    return message_type() == roq::fbs::Message::BatchEnd ? static_cast<const roq::fbs::BatchEnd *>(message()) : nullptr;
  }
  const roq::fbs::DownloadBegin *message_as_DownloadBegin() const {
    return message_type() == roq::fbs::Message::DownloadBegin ? static_cast<const roq::fbs::DownloadBegin *>(message()) : nullptr;
  }
  const roq::fbs::DownloadEnd *message_as_DownloadEnd() const {
    return message_type() == roq::fbs::Message::DownloadEnd ? static_cast<const roq::fbs::DownloadEnd *>(message()) : nullptr;
  }
  const roq::fbs::GatewaySettings *message_as_GatewaySettings() const {
    return message_type() == roq::fbs::Message::GatewaySettings ? static_cast<const roq::fbs::GatewaySettings *>(message()) : nullptr;
  }
  const roq::fbs::StreamStatus *message_as_StreamStatus() const {
    return message_type() == roq::fbs::Message::StreamStatus ? static_cast<const roq::fbs::StreamStatus *>(message()) : nullptr;
  }
  const roq::fbs::ExternalLatency *message_as_ExternalLatency() const {
    return message_type() == roq::fbs::Message::ExternalLatency ? static_cast<const roq::fbs::ExternalLatency *>(message()) : nullptr;
  }
  const roq::fbs::RateLimitTrigger *message_as_RateLimitTrigger() const {
    return message_type() == roq::fbs::Message::RateLimitTrigger ? static_cast<const roq::fbs::RateLimitTrigger *>(message()) : nullptr;
  }
  const roq::fbs::GatewayStatus *message_as_GatewayStatus() const {
    return message_type() == roq::fbs::Message::GatewayStatus ? static_cast<const roq::fbs::GatewayStatus *>(message()) : nullptr;
  }
  const roq::fbs::ReferenceData *message_as_ReferenceData() const {
    return message_type() == roq::fbs::Message::ReferenceData ? static_cast<const roq::fbs::ReferenceData *>(message()) : nullptr;
  }
  const roq::fbs::MarketStatus *message_as_MarketStatus() const {
    return message_type() == roq::fbs::Message::MarketStatus ? static_cast<const roq::fbs::MarketStatus *>(message()) : nullptr;
  }
  const roq::fbs::TopOfBook *message_as_TopOfBook() const {
    return message_type() == roq::fbs::Message::TopOfBook ? static_cast<const roq::fbs::TopOfBook *>(message()) : nullptr;
  }
  const roq::fbs::MarketByPriceUpdate *message_as_MarketByPriceUpdate() const {
    return message_type() == roq::fbs::Message::MarketByPriceUpdate ? static_cast<const roq::fbs::MarketByPriceUpdate *>(message()) : nullptr;
  }
  const roq::fbs::MarketByOrderUpdate *message_as_MarketByOrderUpdate() const {
    return message_type() == roq::fbs::Message::MarketByOrderUpdate ? static_cast<const roq::fbs::MarketByOrderUpdate *>(message()) : nullptr;
  }
  const roq::fbs::TradeSummary *message_as_TradeSummary() const {
    return message_type() == roq::fbs::Message::TradeSummary ? static_cast<const roq::fbs::TradeSummary *>(message()) : nullptr;
  }
  const roq::fbs::StatisticsUpdate *message_as_StatisticsUpdate() const {
    return message_type() == roq::fbs::Message::StatisticsUpdate ? static_cast<const roq::fbs::StatisticsUpdate *>(message()) : nullptr;
  }
  const roq::fbs::CreateOrder *message_as_CreateOrder() const {
    return message_type() == roq::fbs::Message::CreateOrder ? static_cast<const roq::fbs::CreateOrder *>(message()) : nullptr;
  }
  const roq::fbs::ModifyOrder *message_as_ModifyOrder() const {
    return message_type() == roq::fbs::Message::ModifyOrder ? static_cast<const roq::fbs::ModifyOrder *>(message()) : nullptr;
  }
  const roq::fbs::CancelOrder *message_as_CancelOrder() const {
    return message_type() == roq::fbs::Message::CancelOrder ? static_cast<const roq::fbs::CancelOrder *>(message()) : nullptr;
  }
  const roq::fbs::CancelAllOrders *message_as_CancelAllOrders() const {
    return message_type() == roq::fbs::Message::CancelAllOrders ? static_cast<const roq::fbs::CancelAllOrders *>(message()) : nullptr;
  }
  const roq::fbs::OrderAck *message_as_OrderAck() const {
    return message_type() == roq::fbs::Message::OrderAck ? static_cast<const roq::fbs::OrderAck *>(message()) : nullptr;
  }
  const roq::fbs::OrderUpdate *message_as_OrderUpdate() const {
    return message_type() == roq::fbs::Message::OrderUpdate ? static_cast<const roq::fbs::OrderUpdate *>(message()) : nullptr;
  }
  const roq::fbs::TradeUpdate *message_as_TradeUpdate() const {
    return message_type() == roq::fbs::Message::TradeUpdate ? static_cast<const roq::fbs::TradeUpdate *>(message()) : nullptr;
  }
  const roq::fbs::PositionUpdate *message_as_PositionUpdate() const {
    return message_type() == roq::fbs::Message::PositionUpdate ? static_cast<const roq::fbs::PositionUpdate *>(message()) : nullptr;
  }
  const roq::fbs::FundsUpdate *message_as_FundsUpdate() const {
    return message_type() == roq::fbs::Message::FundsUpdate ? static_cast<const roq::fbs::FundsUpdate *>(message()) : nullptr;
  }
  const roq::fbs::CustomMetrics *message_as_CustomMetrics() const {
    return message_type() == roq::fbs::Message::CustomMetrics ? static_cast<const roq::fbs::CustomMetrics *>(message()) : nullptr;
  }
  const roq::fbs::CustomMetricsUpdate *message_as_CustomMetricsUpdate() const {
    return message_type() == roq::fbs::Message::CustomMetricsUpdate ? static_cast<const roq::fbs::CustomMetricsUpdate *>(message()) : nullptr;
  }
  const roq::fbs::ParametersUpdate *message_as_ParametersUpdate() const {
    return message_type() == roq::fbs::Message::ParametersUpdate ? static_cast<const roq::fbs::ParametersUpdate *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE_INFO) &&
           verifier.VerifyTable(source_info()) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const roq::fbs::Handshake *Event::message_as<roq::fbs::Handshake>() const {
  return message_as_Handshake();
}

template<> inline const roq::fbs::HandshakeAck *Event::message_as<roq::fbs::HandshakeAck>() const {
  return message_as_HandshakeAck();
}

template<> inline const roq::fbs::Subscribe *Event::message_as<roq::fbs::Subscribe>() const {
  return message_as_Subscribe();
}

template<> inline const roq::fbs::BatchBegin *Event::message_as<roq::fbs::BatchBegin>() const {
  return message_as_BatchBegin();
}

template<> inline const roq::fbs::BatchEnd *Event::message_as<roq::fbs::BatchEnd>() const {
  return message_as_BatchEnd();
}

template<> inline const roq::fbs::DownloadBegin *Event::message_as<roq::fbs::DownloadBegin>() const {
  return message_as_DownloadBegin();
}

template<> inline const roq::fbs::DownloadEnd *Event::message_as<roq::fbs::DownloadEnd>() const {
  return message_as_DownloadEnd();
}

template<> inline const roq::fbs::GatewaySettings *Event::message_as<roq::fbs::GatewaySettings>() const {
  return message_as_GatewaySettings();
}

template<> inline const roq::fbs::StreamStatus *Event::message_as<roq::fbs::StreamStatus>() const {
  return message_as_StreamStatus();
}

template<> inline const roq::fbs::ExternalLatency *Event::message_as<roq::fbs::ExternalLatency>() const {
  return message_as_ExternalLatency();
}

template<> inline const roq::fbs::RateLimitTrigger *Event::message_as<roq::fbs::RateLimitTrigger>() const {
  return message_as_RateLimitTrigger();
}

template<> inline const roq::fbs::GatewayStatus *Event::message_as<roq::fbs::GatewayStatus>() const {
  return message_as_GatewayStatus();
}

template<> inline const roq::fbs::ReferenceData *Event::message_as<roq::fbs::ReferenceData>() const {
  return message_as_ReferenceData();
}

template<> inline const roq::fbs::MarketStatus *Event::message_as<roq::fbs::MarketStatus>() const {
  return message_as_MarketStatus();
}

template<> inline const roq::fbs::TopOfBook *Event::message_as<roq::fbs::TopOfBook>() const {
  return message_as_TopOfBook();
}

template<> inline const roq::fbs::MarketByPriceUpdate *Event::message_as<roq::fbs::MarketByPriceUpdate>() const {
  return message_as_MarketByPriceUpdate();
}

template<> inline const roq::fbs::MarketByOrderUpdate *Event::message_as<roq::fbs::MarketByOrderUpdate>() const {
  return message_as_MarketByOrderUpdate();
}

template<> inline const roq::fbs::TradeSummary *Event::message_as<roq::fbs::TradeSummary>() const {
  return message_as_TradeSummary();
}

template<> inline const roq::fbs::StatisticsUpdate *Event::message_as<roq::fbs::StatisticsUpdate>() const {
  return message_as_StatisticsUpdate();
}

template<> inline const roq::fbs::CreateOrder *Event::message_as<roq::fbs::CreateOrder>() const {
  return message_as_CreateOrder();
}

template<> inline const roq::fbs::ModifyOrder *Event::message_as<roq::fbs::ModifyOrder>() const {
  return message_as_ModifyOrder();
}

template<> inline const roq::fbs::CancelOrder *Event::message_as<roq::fbs::CancelOrder>() const {
  return message_as_CancelOrder();
}

template<> inline const roq::fbs::CancelAllOrders *Event::message_as<roq::fbs::CancelAllOrders>() const {
  return message_as_CancelAllOrders();
}

template<> inline const roq::fbs::OrderAck *Event::message_as<roq::fbs::OrderAck>() const {
  return message_as_OrderAck();
}

template<> inline const roq::fbs::OrderUpdate *Event::message_as<roq::fbs::OrderUpdate>() const {
  return message_as_OrderUpdate();
}

template<> inline const roq::fbs::TradeUpdate *Event::message_as<roq::fbs::TradeUpdate>() const {
  return message_as_TradeUpdate();
}

template<> inline const roq::fbs::PositionUpdate *Event::message_as<roq::fbs::PositionUpdate>() const {
  return message_as_PositionUpdate();
}

template<> inline const roq::fbs::FundsUpdate *Event::message_as<roq::fbs::FundsUpdate>() const {
  return message_as_FundsUpdate();
}

template<> inline const roq::fbs::CustomMetrics *Event::message_as<roq::fbs::CustomMetrics>() const {
  return message_as_CustomMetrics();
}

template<> inline const roq::fbs::CustomMetricsUpdate *Event::message_as<roq::fbs::CustomMetricsUpdate>() const {
  return message_as_CustomMetricsUpdate();
}

template<> inline const roq::fbs::ParametersUpdate *Event::message_as<roq::fbs::ParametersUpdate>() const {
  return message_as_ParametersUpdate();
}

struct EventBuilder {
  typedef Event Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_info(flatbuffers::Offset<roq::fbs::SourceInfo> source_info) {
    fbb_.AddOffset(Event::VT_SOURCE_INFO, source_info);
  }
  void add_message_type(roq::fbs::Message message_type) {
    fbb_.AddElement<uint8_t>(Event::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Event::VT_MESSAGE, message);
  }
  explicit EventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<roq::fbs::SourceInfo> source_info = 0,
    roq::fbs::Message message_type = roq::fbs::Message::NONE,
    flatbuffers::Offset<void> message = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_source_info(source_info);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Event::Traits {
  using type = Event;
  static auto constexpr Create = CreateEvent;
};

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message::NONE: {
      return true;
    }
    case Message::Handshake: {
      auto ptr = reinterpret_cast<const roq::fbs::Handshake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::HandshakeAck: {
      auto ptr = reinterpret_cast<const roq::fbs::HandshakeAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::Subscribe: {
      auto ptr = reinterpret_cast<const roq::fbs::Subscribe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::BatchBegin: {
      auto ptr = reinterpret_cast<const roq::fbs::BatchBegin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::BatchEnd: {
      auto ptr = reinterpret_cast<const roq::fbs::BatchEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::DownloadBegin: {
      auto ptr = reinterpret_cast<const roq::fbs::DownloadBegin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::DownloadEnd: {
      auto ptr = reinterpret_cast<const roq::fbs::DownloadEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::GatewaySettings: {
      auto ptr = reinterpret_cast<const roq::fbs::GatewaySettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::StreamStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::StreamStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::ExternalLatency: {
      auto ptr = reinterpret_cast<const roq::fbs::ExternalLatency *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::RateLimitTrigger: {
      auto ptr = reinterpret_cast<const roq::fbs::RateLimitTrigger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::GatewayStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::GatewayStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::ReferenceData: {
      auto ptr = reinterpret_cast<const roq::fbs::ReferenceData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::MarketStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::TopOfBook: {
      auto ptr = reinterpret_cast<const roq::fbs::TopOfBook *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::MarketByPriceUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketByPriceUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::MarketByOrderUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketByOrderUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::TradeSummary: {
      auto ptr = reinterpret_cast<const roq::fbs::TradeSummary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::StatisticsUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::StatisticsUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::CreateOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::CreateOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::ModifyOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::ModifyOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::CancelOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::CancelOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::CancelAllOrders: {
      auto ptr = reinterpret_cast<const roq::fbs::CancelAllOrders *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::OrderAck: {
      auto ptr = reinterpret_cast<const roq::fbs::OrderAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::OrderUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::OrderUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::TradeUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::TradeUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::PositionUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::PositionUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::FundsUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::FundsUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::CustomMetrics: {
      auto ptr = reinterpret_cast<const roq::fbs::CustomMetrics *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::CustomMetricsUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::CustomMetricsUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::ParametersUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::ParametersUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<Message> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const roq::fbs::Event *GetEvent(const void *buf) {
  return flatbuffers::GetRoot<roq::fbs::Event>(buf);
}

inline const roq::fbs::Event *GetSizePrefixedEvent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<roq::fbs::Event>(buf);
}

inline bool VerifyEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<roq::fbs::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<roq::fbs::Event>(nullptr);
}

inline void FinishEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace roq

#endif  // FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
