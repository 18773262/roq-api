// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
#define FLATBUFFERS_GENERATED_API_ROQ_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace roq {
namespace fbs {

struct Fill;
struct FillBuilder;

struct Layer;
struct LayerBuilder;

struct MBOUpdate;
struct MBOUpdateBuilder;

struct MBPUpdate;
struct MBPUpdateBuilder;

struct Measurement;
struct MeasurementBuilder;

struct Statistics;
struct StatisticsBuilder;

struct Trade;
struct TradeBuilder;

struct CancelAllOrders;
struct CancelAllOrdersBuilder;

struct CancelOrder;
struct CancelOrderBuilder;

struct CreateOrder;
struct CreateOrderBuilder;

struct CustomMetrics;
struct CustomMetricsBuilder;

struct CustomMetricsUpdate;
struct CustomMetricsUpdateBuilder;

struct DownloadBegin;
struct DownloadBeginBuilder;

struct DownloadEnd;
struct DownloadEndBuilder;

struct ExternalLatency;
struct ExternalLatencyBuilder;

struct FundsUpdate;
struct FundsUpdateBuilder;

struct GatewaySettings;
struct GatewaySettingsBuilder;

struct GatewayStatus;
struct GatewayStatusBuilder;

struct MarketByOrderUpdate;
struct MarketByOrderUpdateBuilder;

struct MarketByPriceUpdate;
struct MarketByPriceUpdateBuilder;

struct MarketStatus;
struct MarketStatusBuilder;

struct ModifyOrder;
struct ModifyOrderBuilder;

struct OrderAck;
struct OrderAckBuilder;

struct OrderUpdate;
struct OrderUpdateBuilder;

struct PositionUpdate;
struct PositionUpdateBuilder;

struct RateLimitTrigger;
struct RateLimitTriggerBuilder;

struct ReferenceData;
struct ReferenceDataBuilder;

struct StatisticsUpdate;
struct StatisticsUpdateBuilder;

struct StreamStatus;
struct StreamStatusBuilder;

struct TopOfBook;
struct TopOfBookBuilder;

struct TradeSummary;
struct TradeSummaryBuilder;

struct TradeUpdate;
struct TradeUpdateBuilder;

struct Handshake;
struct HandshakeBuilder;

struct HandshakeAck;
struct HandshakeAckBuilder;

struct Subscribe;
struct SubscribeBuilder;

struct BatchBegin;
struct BatchBeginBuilder;

struct BatchEnd;
struct BatchEndBuilder;

struct SourceInfo;
struct SourceInfoBuilder;

struct Event;
struct EventBuilder;

enum ConnectionStatus : uint8_t {
  ConnectionStatus_Undefined = 0,
  ConnectionStatus_Disconnected = 1,
  ConnectionStatus_Connecting = 2,
  ConnectionStatus_LoginSent = 3,
  ConnectionStatus_Downloading = 4,
  ConnectionStatus_Ready = 5,
  ConnectionStatus_LoggedOut = 6,
  ConnectionStatus_MIN = ConnectionStatus_Undefined,
  ConnectionStatus_MAX = ConnectionStatus_LoggedOut
};

inline const ConnectionStatus (&EnumValuesConnectionStatus())[7] {
  static const ConnectionStatus values[] = {
      ConnectionStatus_Undefined,
      ConnectionStatus_Disconnected,
      ConnectionStatus_Connecting,
      ConnectionStatus_LoginSent,
      ConnectionStatus_Downloading,
      ConnectionStatus_Ready,
      ConnectionStatus_LoggedOut};
  return values;
}

inline char const *const *EnumNamesConnectionStatus() {
  static char const *const names[8] = {
      "Undefined", "Disconnected", "Connecting", "LoginSent", "Downloading", "Ready", "LoggedOut", nullptr};
  return names;
}

inline char const *EnumNameConnectionStatus(ConnectionStatus e) {
  if (flatbuffers::IsOutRange(e, ConnectionStatus_Undefined, ConnectionStatus_LoggedOut))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionStatus()[index];
}

enum Decimals : uint8_t {
  Decimals_Undefined = 0,
  Decimals__0 = 1,
  Decimals__1 = 2,
  Decimals__2 = 3,
  Decimals__3 = 4,
  Decimals__4 = 5,
  Decimals__5 = 6,
  Decimals__6 = 7,
  Decimals__7 = 8,
  Decimals__8 = 9,
  Decimals__9 = 10,
  Decimals__10 = 11,
  Decimals__11 = 12,
  Decimals__12 = 13,
  Decimals__13 = 14,
  Decimals__14 = 15,
  Decimals__15 = 16,
  Decimals_MIN = Decimals_Undefined,
  Decimals_MAX = Decimals__15
};

inline const Decimals (&EnumValuesDecimals())[17] {
  static const Decimals values[] = {
      Decimals_Undefined,
      Decimals__0,
      Decimals__1,
      Decimals__2,
      Decimals__3,
      Decimals__4,
      Decimals__5,
      Decimals__6,
      Decimals__7,
      Decimals__8,
      Decimals__9,
      Decimals__10,
      Decimals__11,
      Decimals__12,
      Decimals__13,
      Decimals__14,
      Decimals__15};
  return values;
}

inline char const *const *EnumNamesDecimals() {
  static char const *const names[18] = {
      "Undefined",
      "_0",
      "_1",
      "_2",
      "_3",
      "_4",
      "_5",
      "_6",
      "_7",
      "_8",
      "_9",
      "_10",
      "_11",
      "_12",
      "_13",
      "_14",
      "_15",
      nullptr};
  return names;
}

inline char const *EnumNameDecimals(Decimals e) {
  if (flatbuffers::IsOutRange(e, Decimals_Undefined, Decimals__15))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDecimals()[index];
}

enum Encoding : uint32_t {
  Encoding_Undefined = 0,
  Encoding_FIX = 1,
  Encoding_JSON = 2,
  Encoding_SBE = 4,
  Encoding_MIN = Encoding_Undefined,
  Encoding_MAX = Encoding_SBE
};

inline const Encoding (&EnumValuesEncoding())[4] {
  static const Encoding values[] = {Encoding_Undefined, Encoding_FIX, Encoding_JSON, Encoding_SBE};
  return values;
}

inline char const *const *EnumNamesEncoding() {
  static char const *const names[6] = {"Undefined", "FIX", "JSON", "", "SBE", nullptr};
  return names;
}

inline char const *EnumNameEncoding(Encoding e) {
  if (flatbuffers::IsOutRange(e, Encoding_Undefined, Encoding_SBE))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncoding()[index];
}

enum Error : uint8_t {
  Error_Undefined = 0,
  Error_Unknown = 1,
  Error_NotSupported = 2,
  Error_InvalidAccount = 3,
  Error_InvalidOrderId = 4,
  Error_InvalidExchange = 5,
  Error_InvalidSymbol = 6,
  Error_InvalidSide = 7,
  Error_InvalidPositionEffect = 8,
  Error_InvalidQuantity = 9,
  Error_InvalidMaxShowQuantity = 10,
  Error_InvalidOrderType = 11,
  Error_InvalidTimeInForce = 12,
  Error_InvalidExecutionInstruction = 13,
  Error_InvalidOrderTemplate = 14,
  Error_InvalidPrice = 15,
  Error_InvalidStopPrice = 16,
  Error_InvalidRoutingId = 17,
  Error_InvalidRequestVersion = 18,
  Error_InvalidRequestId = 19,
  Error_InvalidRequestType = 20,
  Error_InvalidRequestStatus = 21,
  Error_InvalidRequestArgs = 22,
  Error_UnknownExternalOrderId = 23,
  Error_NotAuthorized = 24,
  Error_RequestRateLimitReached = 25,
  Error_GatewayNotReady = 26,
  Error_NetworkError = 27,
  Error_Timeout = 28,
  Error_ParseError = 29,
  Error_ModifyHasNoEffect = 30,
  Error_TooLateToModifyOrCancel = 31,
  Error_ConditionalRequestHasFailed = 32,
  Error_UnknownOrderId = 33,
  Error_InsufficientFunds = 34,
  Error_MIN = Error_Undefined,
  Error_MAX = Error_InsufficientFunds
};

inline const Error (&EnumValuesError())[35] {
  static const Error values[] = {
      Error_Undefined,
      Error_Unknown,
      Error_NotSupported,
      Error_InvalidAccount,
      Error_InvalidOrderId,
      Error_InvalidExchange,
      Error_InvalidSymbol,
      Error_InvalidSide,
      Error_InvalidPositionEffect,
      Error_InvalidQuantity,
      Error_InvalidMaxShowQuantity,
      Error_InvalidOrderType,
      Error_InvalidTimeInForce,
      Error_InvalidExecutionInstruction,
      Error_InvalidOrderTemplate,
      Error_InvalidPrice,
      Error_InvalidStopPrice,
      Error_InvalidRoutingId,
      Error_InvalidRequestVersion,
      Error_InvalidRequestId,
      Error_InvalidRequestType,
      Error_InvalidRequestStatus,
      Error_InvalidRequestArgs,
      Error_UnknownExternalOrderId,
      Error_NotAuthorized,
      Error_RequestRateLimitReached,
      Error_GatewayNotReady,
      Error_NetworkError,
      Error_Timeout,
      Error_ParseError,
      Error_ModifyHasNoEffect,
      Error_TooLateToModifyOrCancel,
      Error_ConditionalRequestHasFailed,
      Error_UnknownOrderId,
      Error_InsufficientFunds};
  return values;
}

inline char const *const *EnumNamesError() {
  static char const *const names[36] = {
      "Undefined",
      "Unknown",
      "NotSupported",
      "InvalidAccount",
      "InvalidOrderId",
      "InvalidExchange",
      "InvalidSymbol",
      "InvalidSide",
      "InvalidPositionEffect",
      "InvalidQuantity",
      "InvalidMaxShowQuantity",
      "InvalidOrderType",
      "InvalidTimeInForce",
      "InvalidExecutionInstruction",
      "InvalidOrderTemplate",
      "InvalidPrice",
      "InvalidStopPrice",
      "InvalidRoutingId",
      "InvalidRequestVersion",
      "InvalidRequestId",
      "InvalidRequestType",
      "InvalidRequestStatus",
      "InvalidRequestArgs",
      "UnknownExternalOrderId",
      "NotAuthorized",
      "RequestRateLimitReached",
      "GatewayNotReady",
      "NetworkError",
      "Timeout",
      "ParseError",
      "ModifyHasNoEffect",
      "TooLateToModifyOrCancel",
      "ConditionalRequestHasFailed",
      "UnknownOrderId",
      "InsufficientFunds",
      nullptr};
  return names;
}

inline char const *EnumNameError(Error e) {
  if (flatbuffers::IsOutRange(e, Error_Undefined, Error_InsufficientFunds))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesError()[index];
}

enum ExecutionInstruction : uint8_t {
  ExecutionInstruction_Undefined = 0,
  ExecutionInstruction_ParticipateDoNotInitiate = 1,
  ExecutionInstruction_CancelIfNotBest = 2,
  ExecutionInstruction_DoNotIncrease = 4,
  ExecutionInstruction_DoNotReduce = 8,
  ExecutionInstruction_MIN = ExecutionInstruction_Undefined,
  ExecutionInstruction_MAX = ExecutionInstruction_DoNotReduce
};

inline const ExecutionInstruction (&EnumValuesExecutionInstruction())[5] {
  static const ExecutionInstruction values[] = {
      ExecutionInstruction_Undefined,
      ExecutionInstruction_ParticipateDoNotInitiate,
      ExecutionInstruction_CancelIfNotBest,
      ExecutionInstruction_DoNotIncrease,
      ExecutionInstruction_DoNotReduce};
  return values;
}

inline char const *const *EnumNamesExecutionInstruction() {
  static char const *const names[10] = {
      "Undefined",
      "ParticipateDoNotInitiate",
      "CancelIfNotBest",
      "",
      "DoNotIncrease",
      "",
      "",
      "",
      "DoNotReduce",
      nullptr};
  return names;
}

inline char const *EnumNameExecutionInstruction(ExecutionInstruction e) {
  if (flatbuffers::IsOutRange(e, ExecutionInstruction_Undefined, ExecutionInstruction_DoNotReduce))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutionInstruction()[index];
}

enum Liquidity : uint8_t {
  Liquidity_Undefined = 0,
  Liquidity_Maker = 1,
  Liquidity_Taker = 2,
  Liquidity_MIN = Liquidity_Undefined,
  Liquidity_MAX = Liquidity_Taker
};

inline const Liquidity (&EnumValuesLiquidity())[3] {
  static const Liquidity values[] = {Liquidity_Undefined, Liquidity_Maker, Liquidity_Taker};
  return values;
}

inline char const *const *EnumNamesLiquidity() {
  static char const *const names[4] = {"Undefined", "Maker", "Taker", nullptr};
  return names;
}

inline char const *EnumNameLiquidity(Liquidity e) {
  if (flatbuffers::IsOutRange(e, Liquidity_Undefined, Liquidity_Taker))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLiquidity()[index];
}

enum OptionType : uint8_t {
  OptionType_Undefined = 0,
  OptionType_Call = 1,
  OptionType_Put = 2,
  OptionType_MIN = OptionType_Undefined,
  OptionType_MAX = OptionType_Put
};

inline const OptionType (&EnumValuesOptionType())[3] {
  static const OptionType values[] = {OptionType_Undefined, OptionType_Call, OptionType_Put};
  return values;
}

inline char const *const *EnumNamesOptionType() {
  static char const *const names[4] = {"Undefined", "Call", "Put", nullptr};
  return names;
}

inline char const *EnumNameOptionType(OptionType e) {
  if (flatbuffers::IsOutRange(e, OptionType_Undefined, OptionType_Put))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionType()[index];
}

enum OrderStatus : uint8_t {
  OrderStatus_Undefined = 0,
  OrderStatus_Sent = 1,
  OrderStatus_Accepted = 2,
  OrderStatus_Suspended = 3,
  OrderStatus_Working = 4,
  OrderStatus_Stopped = 5,
  OrderStatus_Completed = 6,
  OrderStatus_Expired = 7,
  OrderStatus_Canceled = 8,
  OrderStatus_Rejected = 9,
  OrderStatus_MIN = OrderStatus_Undefined,
  OrderStatus_MAX = OrderStatus_Rejected
};

inline const OrderStatus (&EnumValuesOrderStatus())[10] {
  static const OrderStatus values[] = {
      OrderStatus_Undefined,
      OrderStatus_Sent,
      OrderStatus_Accepted,
      OrderStatus_Suspended,
      OrderStatus_Working,
      OrderStatus_Stopped,
      OrderStatus_Completed,
      OrderStatus_Expired,
      OrderStatus_Canceled,
      OrderStatus_Rejected};
  return values;
}

inline char const *const *EnumNamesOrderStatus() {
  static char const *const names[11] = {
      "Undefined",
      "Sent",
      "Accepted",
      "Suspended",
      "Working",
      "Stopped",
      "Completed",
      "Expired",
      "Canceled",
      "Rejected",
      nullptr};
  return names;
}

inline char const *EnumNameOrderStatus(OrderStatus e) {
  if (flatbuffers::IsOutRange(e, OrderStatus_Undefined, OrderStatus_Rejected))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderStatus()[index];
}

enum OrderType : uint8_t {
  OrderType_Undefined = 0,
  OrderType_Market = 1,
  OrderType_Limit = 2,
  OrderType_MIN = OrderType_Undefined,
  OrderType_MAX = OrderType_Limit
};

inline const OrderType (&EnumValuesOrderType())[3] {
  static const OrderType values[] = {OrderType_Undefined, OrderType_Market, OrderType_Limit};
  return values;
}

inline char const *const *EnumNamesOrderType() {
  static char const *const names[4] = {"Undefined", "Market", "Limit", nullptr};
  return names;
}

inline char const *EnumNameOrderType(OrderType e) {
  if (flatbuffers::IsOutRange(e, OrderType_Undefined, OrderType_Limit))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderType()[index];
}

enum OrderUpdateAction : uint8_t {
  OrderUpdateAction_Undefined = 0,
  OrderUpdateAction_New = 1,
  OrderUpdateAction_Modify = 2,
  OrderUpdateAction_Remove = 3,
  OrderUpdateAction_MIN = OrderUpdateAction_Undefined,
  OrderUpdateAction_MAX = OrderUpdateAction_Remove
};

inline const OrderUpdateAction (&EnumValuesOrderUpdateAction())[4] {
  static const OrderUpdateAction values[] = {
      OrderUpdateAction_Undefined, OrderUpdateAction_New, OrderUpdateAction_Modify, OrderUpdateAction_Remove};
  return values;
}

inline char const *const *EnumNamesOrderUpdateAction() {
  static char const *const names[5] = {"Undefined", "New", "Modify", "Remove", nullptr};
  return names;
}

inline char const *EnumNameOrderUpdateAction(OrderUpdateAction e) {
  if (flatbuffers::IsOutRange(e, OrderUpdateAction_Undefined, OrderUpdateAction_Remove))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderUpdateAction()[index];
}

enum Origin : uint8_t {
  Origin_Undefined = 0,
  Origin_Client = 1,
  Origin_Gateway = 2,
  Origin_Broker = 3,
  Origin_Exchange = 4,
  Origin_MIN = Origin_Undefined,
  Origin_MAX = Origin_Exchange
};

inline const Origin (&EnumValuesOrigin())[5] {
  static const Origin values[] = {Origin_Undefined, Origin_Client, Origin_Gateway, Origin_Broker, Origin_Exchange};
  return values;
}

inline char const *const *EnumNamesOrigin() {
  static char const *const names[6] = {"Undefined", "Client", "Gateway", "Broker", "Exchange", nullptr};
  return names;
}

inline char const *EnumNameOrigin(Origin e) {
  if (flatbuffers::IsOutRange(e, Origin_Undefined, Origin_Exchange))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrigin()[index];
}

enum PositionEffect : uint8_t {
  PositionEffect_Undefined = 0,
  PositionEffect_Open = 1,
  PositionEffect_Close = 2,
  PositionEffect_MIN = PositionEffect_Undefined,
  PositionEffect_MAX = PositionEffect_Close
};

inline const PositionEffect (&EnumValuesPositionEffect())[3] {
  static const PositionEffect values[] = {PositionEffect_Undefined, PositionEffect_Open, PositionEffect_Close};
  return values;
}

inline char const *const *EnumNamesPositionEffect() {
  static char const *const names[4] = {"Undefined", "Open", "Close", nullptr};
  return names;
}

inline char const *EnumNamePositionEffect(PositionEffect e) {
  if (flatbuffers::IsOutRange(e, PositionEffect_Undefined, PositionEffect_Close))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionEffect()[index];
}

enum Protocol : uint8_t {
  Protocol_Undefined = 0,
  Protocol_FIX = 1,
  Protocol_WS = 2,
  Protocol_HTTP = 3,
  Protocol_SBE = 4,
  Protocol_MIN = Protocol_Undefined,
  Protocol_MAX = Protocol_SBE
};

inline const Protocol (&EnumValuesProtocol())[5] {
  static const Protocol values[] = {Protocol_Undefined, Protocol_FIX, Protocol_WS, Protocol_HTTP, Protocol_SBE};
  return values;
}

inline char const *const *EnumNamesProtocol() {
  static char const *const names[6] = {"Undefined", "FIX", "WS", "HTTP", "SBE", nullptr};
  return names;
}

inline char const *EnumNameProtocol(Protocol e) {
  if (flatbuffers::IsOutRange(e, Protocol_Undefined, Protocol_SBE))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtocol()[index];
}

enum RequestIdType : uint8_t {
  RequestIdType_Undefined = 0,
  RequestIdType_Base64 = 1,
  RequestIdType_Base32 = 2,
  RequestIdType_Simple = 3,
  RequestIdType_UUID = 4,
  RequestIdType_MIN = RequestIdType_Undefined,
  RequestIdType_MAX = RequestIdType_UUID
};

inline const RequestIdType (&EnumValuesRequestIdType())[5] {
  static const RequestIdType values[] = {
      RequestIdType_Undefined, RequestIdType_Base64, RequestIdType_Base32, RequestIdType_Simple, RequestIdType_UUID};
  return values;
}

inline char const *const *EnumNamesRequestIdType() {
  static char const *const names[6] = {"Undefined", "Base64", "Base32", "Simple", "UUID", nullptr};
  return names;
}

inline char const *EnumNameRequestIdType(RequestIdType e) {
  if (flatbuffers::IsOutRange(e, RequestIdType_Undefined, RequestIdType_UUID))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestIdType()[index];
}

enum RequestStatus : uint8_t {
  RequestStatus_Undefined = 0,
  RequestStatus_Forwarded = 1,
  RequestStatus_Accepted = 2,
  RequestStatus_Rejected = 3,
  RequestStatus_Disconnected = 4,
  RequestStatus_Timeout = 5,
  RequestStatus_Failed = 6,
  RequestStatus_MIN = RequestStatus_Undefined,
  RequestStatus_MAX = RequestStatus_Failed
};

inline const RequestStatus (&EnumValuesRequestStatus())[7] {
  static const RequestStatus values[] = {
      RequestStatus_Undefined,
      RequestStatus_Forwarded,
      RequestStatus_Accepted,
      RequestStatus_Rejected,
      RequestStatus_Disconnected,
      RequestStatus_Timeout,
      RequestStatus_Failed};
  return values;
}

inline char const *const *EnumNamesRequestStatus() {
  static char const *const names[8] = {
      "Undefined", "Forwarded", "Accepted", "Rejected", "Disconnected", "Timeout", "Failed", nullptr};
  return names;
}

inline char const *EnumNameRequestStatus(RequestStatus e) {
  if (flatbuffers::IsOutRange(e, RequestStatus_Undefined, RequestStatus_Failed))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestStatus()[index];
}

enum RequestType : uint8_t {
  RequestType_Undefined = 0,
  RequestType_CreateOrder = 1,
  RequestType_ModifyOrder = 2,
  RequestType_CancelOrder = 3,
  RequestType_MIN = RequestType_Undefined,
  RequestType_MAX = RequestType_CancelOrder
};

inline const RequestType (&EnumValuesRequestType())[4] {
  static const RequestType values[] = {
      RequestType_Undefined, RequestType_CreateOrder, RequestType_ModifyOrder, RequestType_CancelOrder};
  return values;
}

inline char const *const *EnumNamesRequestType() {
  static char const *const names[5] = {"Undefined", "CreateOrder", "ModifyOrder", "CancelOrder", nullptr};
  return names;
}

inline char const *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_Undefined, RequestType_CancelOrder))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum SecurityType : uint8_t {
  SecurityType_Undefined = 0,
  SecurityType_Spot = 1,
  SecurityType_Futures = 2,
  SecurityType_Option = 3,
  SecurityType_Swap = 4,
  SecurityType_MIN = SecurityType_Undefined,
  SecurityType_MAX = SecurityType_Swap
};

inline const SecurityType (&EnumValuesSecurityType())[5] {
  static const SecurityType values[] = {
      SecurityType_Undefined, SecurityType_Spot, SecurityType_Futures, SecurityType_Option, SecurityType_Swap};
  return values;
}

inline char const *const *EnumNamesSecurityType() {
  static char const *const names[6] = {"Undefined", "Spot", "Futures", "Option", "Swap", nullptr};
  return names;
}

inline char const *EnumNameSecurityType(SecurityType e) {
  if (flatbuffers::IsOutRange(e, SecurityType_Undefined, SecurityType_Swap))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSecurityType()[index];
}

enum Side : uint8_t {
  Side_Undefined = 0,
  Side_Buy = 1,
  Side_Sell = 2,
  Side_MIN = Side_Undefined,
  Side_MAX = Side_Sell
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {Side_Undefined, Side_Buy, Side_Sell};
  return values;
}

inline char const *const *EnumNamesSide() {
  static char const *const names[4] = {"Undefined", "Buy", "Sell", nullptr};
  return names;
}

inline char const *EnumNameSide(Side e) {
  if (flatbuffers::IsOutRange(e, Side_Undefined, Side_Sell))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum StatisticsType : uint8_t {
  StatisticsType_Undefined = 0,
  StatisticsType_OpenPrice = 1,
  StatisticsType_SettlementPrice = 2,
  StatisticsType_ClosePrice = 3,
  StatisticsType_OpenInterest = 4,
  StatisticsType_PreOpenInterest = 5,
  StatisticsType_PreSettlementPrice = 6,
  StatisticsType_PreClosePrice = 7,
  StatisticsType_HighestTradedPrice = 8,
  StatisticsType_LowestTradedPrice = 9,
  StatisticsType_UpperLimitPrice = 10,
  StatisticsType_LowerLimitPrice = 11,
  StatisticsType_IndexValue = 12,
  StatisticsType_MarginRate = 13,
  StatisticsType_FundingRate = 14,
  StatisticsType_FundingRatePrediction = 15,
  StatisticsType_TradeVolume = 16,
  StatisticsType_MIN = StatisticsType_Undefined,
  StatisticsType_MAX = StatisticsType_TradeVolume
};

inline const StatisticsType (&EnumValuesStatisticsType())[17] {
  static const StatisticsType values[] = {
      StatisticsType_Undefined,
      StatisticsType_OpenPrice,
      StatisticsType_SettlementPrice,
      StatisticsType_ClosePrice,
      StatisticsType_OpenInterest,
      StatisticsType_PreOpenInterest,
      StatisticsType_PreSettlementPrice,
      StatisticsType_PreClosePrice,
      StatisticsType_HighestTradedPrice,
      StatisticsType_LowestTradedPrice,
      StatisticsType_UpperLimitPrice,
      StatisticsType_LowerLimitPrice,
      StatisticsType_IndexValue,
      StatisticsType_MarginRate,
      StatisticsType_FundingRate,
      StatisticsType_FundingRatePrediction,
      StatisticsType_TradeVolume};
  return values;
}

inline char const *const *EnumNamesStatisticsType() {
  static char const *const names[18] = {
      "Undefined",
      "OpenPrice",
      "SettlementPrice",
      "ClosePrice",
      "OpenInterest",
      "PreOpenInterest",
      "PreSettlementPrice",
      "PreClosePrice",
      "HighestTradedPrice",
      "LowestTradedPrice",
      "UpperLimitPrice",
      "LowerLimitPrice",
      "IndexValue",
      "MarginRate",
      "FundingRate",
      "FundingRatePrediction",
      "TradeVolume",
      nullptr};
  return names;
}

inline char const *EnumNameStatisticsType(StatisticsType e) {
  if (flatbuffers::IsOutRange(e, StatisticsType_Undefined, StatisticsType_TradeVolume))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatisticsType()[index];
}

enum SupportType : uint32_t {
  SupportType_Undefined = 0,
  SupportType_ReferenceData = 1,
  SupportType_MarketStatus = 2,
  SupportType_TopOfBook = 4,
  SupportType_MarketByPrice = 8,
  SupportType_MarketByOrder = 16,
  SupportType_TradeSummary = 32,
  SupportType_Statistics = 64,
  SupportType_CreateOrder = 65536,
  SupportType_ModifyOrder = 131072,
  SupportType_CancelOrder = 262144,
  SupportType_OrderAck = 524288,
  SupportType_Order = 1048576,
  SupportType_Trade = 2097152,
  SupportType_Position = 4194304,
  SupportType_OrderState = 8388608,
  SupportType_Funds = 268435456,
  SupportType_MIN = SupportType_Undefined,
  SupportType_MAX = SupportType_Funds
};

inline const SupportType (&EnumValuesSupportType())[17] {
  static const SupportType values[] = {
      SupportType_Undefined,
      SupportType_ReferenceData,
      SupportType_MarketStatus,
      SupportType_TopOfBook,
      SupportType_MarketByPrice,
      SupportType_MarketByOrder,
      SupportType_TradeSummary,
      SupportType_Statistics,
      SupportType_CreateOrder,
      SupportType_ModifyOrder,
      SupportType_CancelOrder,
      SupportType_OrderAck,
      SupportType_Order,
      SupportType_Trade,
      SupportType_Position,
      SupportType_OrderState,
      SupportType_Funds};
  return values;
}

inline char const *EnumNameSupportType(SupportType e) {
  switch (e) {
    case SupportType_Undefined:
      return "Undefined";
    case SupportType_ReferenceData:
      return "ReferenceData";
    case SupportType_MarketStatus:
      return "MarketStatus";
    case SupportType_TopOfBook:
      return "TopOfBook";
    case SupportType_MarketByPrice:
      return "MarketByPrice";
    case SupportType_MarketByOrder:
      return "MarketByOrder";
    case SupportType_TradeSummary:
      return "TradeSummary";
    case SupportType_Statistics:
      return "Statistics";
    case SupportType_CreateOrder:
      return "CreateOrder";
    case SupportType_ModifyOrder:
      return "ModifyOrder";
    case SupportType_CancelOrder:
      return "CancelOrder";
    case SupportType_OrderAck:
      return "OrderAck";
    case SupportType_Order:
      return "Order";
    case SupportType_Trade:
      return "Trade";
    case SupportType_Position:
      return "Position";
    case SupportType_OrderState:
      return "OrderState";
    case SupportType_Funds:
      return "Funds";
    default:
      return "";
  }
}

enum TimeInForce : uint8_t {
  TimeInForce_Undefined = 0,
  TimeInForce_GFD = 1,
  TimeInForce_GTC = 2,
  TimeInForce_OPG = 3,
  TimeInForce_IOC = 4,
  TimeInForce_FOK = 5,
  TimeInForce_GTX = 6,
  TimeInForce_GTD = 7,
  TimeInForce_AT_THE_CLOSE = 8,
  TimeInForce_GOOD_THROUGH_CROSSING = 9,
  TimeInForce_AT_CROSSING = 10,
  TimeInForce_GOOD_FOR_TIME = 11,
  TimeInForce_GFA = 12,
  TimeInForce_GFM = 13,
  TimeInForce_MIN = TimeInForce_Undefined,
  TimeInForce_MAX = TimeInForce_GFM
};

inline const TimeInForce (&EnumValuesTimeInForce())[14] {
  static const TimeInForce values[] = {
      TimeInForce_Undefined,
      TimeInForce_GFD,
      TimeInForce_GTC,
      TimeInForce_OPG,
      TimeInForce_IOC,
      TimeInForce_FOK,
      TimeInForce_GTX,
      TimeInForce_GTD,
      TimeInForce_AT_THE_CLOSE,
      TimeInForce_GOOD_THROUGH_CROSSING,
      TimeInForce_AT_CROSSING,
      TimeInForce_GOOD_FOR_TIME,
      TimeInForce_GFA,
      TimeInForce_GFM};
  return values;
}

inline char const *const *EnumNamesTimeInForce() {
  static char const *const names[15] = {
      "Undefined",
      "GFD",
      "GTC",
      "OPG",
      "IOC",
      "FOK",
      "GTX",
      "GTD",
      "AT_THE_CLOSE",
      "GOOD_THROUGH_CROSSING",
      "AT_CROSSING",
      "GOOD_FOR_TIME",
      "GFA",
      "GFM",
      nullptr};
  return names;
}

inline char const *EnumNameTimeInForce(TimeInForce e) {
  if (flatbuffers::IsOutRange(e, TimeInForce_Undefined, TimeInForce_GFM))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeInForce()[index];
}

enum TradingStatus : uint8_t {
  TradingStatus_Undefined = 0,
  TradingStatus_StartOfDay = 1,
  TradingStatus_PreOpen = 2,
  TradingStatus_PreOpenNoCancel = 3,
  TradingStatus_PreOpenFreeze = 4,
  TradingStatus_Open = 5,
  TradingStatus_FastMarket = 6,
  TradingStatus_Halt = 7,
  TradingStatus_CloseNotFinal = 8,
  TradingStatus_PreClose = 9,
  TradingStatus_PreCloseNoCancel = 10,
  TradingStatus_PreCloseFreeze = 11,
  TradingStatus_Close = 12,
  TradingStatus_PostClose = 13,
  TradingStatus_EndOfDay = 14,
  TradingStatus_MIN = TradingStatus_Undefined,
  TradingStatus_MAX = TradingStatus_EndOfDay
};

inline const TradingStatus (&EnumValuesTradingStatus())[15] {
  static const TradingStatus values[] = {
      TradingStatus_Undefined,
      TradingStatus_StartOfDay,
      TradingStatus_PreOpen,
      TradingStatus_PreOpenNoCancel,
      TradingStatus_PreOpenFreeze,
      TradingStatus_Open,
      TradingStatus_FastMarket,
      TradingStatus_Halt,
      TradingStatus_CloseNotFinal,
      TradingStatus_PreClose,
      TradingStatus_PreCloseNoCancel,
      TradingStatus_PreCloseFreeze,
      TradingStatus_Close,
      TradingStatus_PostClose,
      TradingStatus_EndOfDay};
  return values;
}

inline char const *const *EnumNamesTradingStatus() {
  static char const *const names[16] = {
      "Undefined",
      "StartOfDay",
      "PreOpen",
      "PreOpenNoCancel",
      "PreOpenFreeze",
      "Open",
      "FastMarket",
      "Halt",
      "CloseNotFinal",
      "PreClose",
      "PreCloseNoCancel",
      "PreCloseFreeze",
      "Close",
      "PostClose",
      "EndOfDay",
      nullptr};
  return names;
}

inline char const *EnumNameTradingStatus(TradingStatus e) {
  if (flatbuffers::IsOutRange(e, TradingStatus_Undefined, TradingStatus_EndOfDay))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTradingStatus()[index];
}

enum Transport : uint8_t {
  Transport_Undefined = 0,
  Transport_TCP = 1,
  Transport_UDP = 2,
  Transport_MIN = Transport_Undefined,
  Transport_MAX = Transport_UDP
};

inline const Transport (&EnumValuesTransport())[3] {
  static const Transport values[] = {Transport_Undefined, Transport_TCP, Transport_UDP};
  return values;
}

inline char const *const *EnumNamesTransport() {
  static char const *const names[4] = {"Undefined", "TCP", "UDP", nullptr};
  return names;
}

inline char const *EnumNameTransport(Transport e) {
  if (flatbuffers::IsOutRange(e, Transport_Undefined, Transport_UDP))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTransport()[index];
}

enum UpdateType : uint8_t {
  UpdateType_Undefined = 0,
  UpdateType_Snapshot = 1,
  UpdateType_Incremental = 2,
  UpdateType_Stale = 3,
  UpdateType_MIN = UpdateType_Undefined,
  UpdateType_MAX = UpdateType_Stale
};

inline const UpdateType (&EnumValuesUpdateType())[4] {
  static const UpdateType values[] = {
      UpdateType_Undefined, UpdateType_Snapshot, UpdateType_Incremental, UpdateType_Stale};
  return values;
}

inline char const *const *EnumNamesUpdateType() {
  static char const *const names[5] = {"Undefined", "Snapshot", "Incremental", "Stale", nullptr};
  return names;
}

inline char const *EnumNameUpdateType(UpdateType e) {
  if (flatbuffers::IsOutRange(e, UpdateType_Undefined, UpdateType_Stale))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateType()[index];
}

enum RateLimitType : uint8_t {
  RateLimitType_Undefined = 0,
  RateLimitType_OrderAction = 1,
  RateLimitType_CreateOrder = 2,
  RateLimitType_MIN = RateLimitType_Undefined,
  RateLimitType_MAX = RateLimitType_CreateOrder
};

inline const RateLimitType (&EnumValuesRateLimitType())[3] {
  static const RateLimitType values[] = {RateLimitType_Undefined, RateLimitType_OrderAction, RateLimitType_CreateOrder};
  return values;
}

inline char const *const *EnumNamesRateLimitType() {
  static char const *const names[4] = {"Undefined", "OrderAction", "CreateOrder", nullptr};
  return names;
}

inline char const *EnumNameRateLimitType(RateLimitType e) {
  if (flatbuffers::IsOutRange(e, RateLimitType_Undefined, RateLimitType_CreateOrder))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRateLimitType()[index];
}

enum Priority : uint32_t {
  Priority_Undefined = 0,
  Priority_Primary = 1,
  Priority_Secondary = 2,
  Priority_MIN = Priority_Undefined,
  Priority_MAX = Priority_Secondary
};

inline const Priority (&EnumValuesPriority())[3] {
  static const Priority values[] = {Priority_Undefined, Priority_Primary, Priority_Secondary};
  return values;
}

inline char const *const *EnumNamesPriority() {
  static char const *const names[4] = {"Undefined", "Primary", "Secondary", nullptr};
  return names;
}

inline char const *EnumNamePriority(Priority e) {
  if (flatbuffers::IsOutRange(e, Priority_Undefined, Priority_Secondary))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPriority()[index];
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_Handshake = 1,
  Message_HandshakeAck = 2,
  Message_Subscribe = 3,
  Message_BatchBegin = 4,
  Message_BatchEnd = 5,
  Message_DownloadBegin = 6,
  Message_DownloadEnd = 7,
  Message_GatewaySettings = 8,
  Message_StreamStatus = 9,
  Message_ExternalLatency = 10,
  Message_RateLimitTrigger = 11,
  Message_GatewayStatus = 12,
  Message_ReferenceData = 13,
  Message_MarketStatus = 14,
  Message_TopOfBook = 15,
  Message_MarketByPriceUpdate = 16,
  Message_MarketByOrderUpdate = 17,
  Message_TradeSummary = 18,
  Message_StatisticsUpdate = 19,
  Message_CreateOrder = 20,
  Message_ModifyOrder = 21,
  Message_CancelOrder = 22,
  Message_CancelAllOrders = 23,
  Message_OrderAck = 24,
  Message_OrderUpdate = 25,
  Message_TradeUpdate = 26,
  Message_PositionUpdate = 27,
  Message_FundsUpdate = 28,
  Message_CustomMetrics = 29,
  Message_CustomMetricsUpdate = 30,
  Message_MIN = Message_NONE,
  Message_MAX = Message_CustomMetricsUpdate
};

inline const Message (&EnumValuesMessage())[31] {
  static const Message values[] = {
      Message_NONE,
      Message_Handshake,
      Message_HandshakeAck,
      Message_Subscribe,
      Message_BatchBegin,
      Message_BatchEnd,
      Message_DownloadBegin,
      Message_DownloadEnd,
      Message_GatewaySettings,
      Message_StreamStatus,
      Message_ExternalLatency,
      Message_RateLimitTrigger,
      Message_GatewayStatus,
      Message_ReferenceData,
      Message_MarketStatus,
      Message_TopOfBook,
      Message_MarketByPriceUpdate,
      Message_MarketByOrderUpdate,
      Message_TradeSummary,
      Message_StatisticsUpdate,
      Message_CreateOrder,
      Message_ModifyOrder,
      Message_CancelOrder,
      Message_CancelAllOrders,
      Message_OrderAck,
      Message_OrderUpdate,
      Message_TradeUpdate,
      Message_PositionUpdate,
      Message_FundsUpdate,
      Message_CustomMetrics,
      Message_CustomMetricsUpdate};
  return values;
}

inline char const *const *EnumNamesMessage() {
  static char const *const names[32] = {
      "NONE",
      "Handshake",
      "HandshakeAck",
      "Subscribe",
      "BatchBegin",
      "BatchEnd",
      "DownloadBegin",
      "DownloadEnd",
      "GatewaySettings",
      "StreamStatus",
      "ExternalLatency",
      "RateLimitTrigger",
      "GatewayStatus",
      "ReferenceData",
      "MarketStatus",
      "TopOfBook",
      "MarketByPriceUpdate",
      "MarketByOrderUpdate",
      "TradeSummary",
      "StatisticsUpdate",
      "CreateOrder",
      "ModifyOrder",
      "CancelOrder",
      "CancelAllOrders",
      "OrderAck",
      "OrderUpdate",
      "TradeUpdate",
      "PositionUpdate",
      "FundsUpdate",
      "CustomMetrics",
      "CustomMetricsUpdate",
      nullptr};
  return names;
}

inline char const *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_CustomMetricsUpdate))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template <typename T>
struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template <>
struct MessageTraits<roq::fbs::Handshake> {
  static const Message enum_value = Message_Handshake;
};

template <>
struct MessageTraits<roq::fbs::HandshakeAck> {
  static const Message enum_value = Message_HandshakeAck;
};

template <>
struct MessageTraits<roq::fbs::Subscribe> {
  static const Message enum_value = Message_Subscribe;
};

template <>
struct MessageTraits<roq::fbs::BatchBegin> {
  static const Message enum_value = Message_BatchBegin;
};

template <>
struct MessageTraits<roq::fbs::BatchEnd> {
  static const Message enum_value = Message_BatchEnd;
};

template <>
struct MessageTraits<roq::fbs::DownloadBegin> {
  static const Message enum_value = Message_DownloadBegin;
};

template <>
struct MessageTraits<roq::fbs::DownloadEnd> {
  static const Message enum_value = Message_DownloadEnd;
};

template <>
struct MessageTraits<roq::fbs::GatewaySettings> {
  static const Message enum_value = Message_GatewaySettings;
};

template <>
struct MessageTraits<roq::fbs::StreamStatus> {
  static const Message enum_value = Message_StreamStatus;
};

template <>
struct MessageTraits<roq::fbs::ExternalLatency> {
  static const Message enum_value = Message_ExternalLatency;
};

template <>
struct MessageTraits<roq::fbs::RateLimitTrigger> {
  static const Message enum_value = Message_RateLimitTrigger;
};

template <>
struct MessageTraits<roq::fbs::GatewayStatus> {
  static const Message enum_value = Message_GatewayStatus;
};

template <>
struct MessageTraits<roq::fbs::ReferenceData> {
  static const Message enum_value = Message_ReferenceData;
};

template <>
struct MessageTraits<roq::fbs::MarketStatus> {
  static const Message enum_value = Message_MarketStatus;
};

template <>
struct MessageTraits<roq::fbs::TopOfBook> {
  static const Message enum_value = Message_TopOfBook;
};

template <>
struct MessageTraits<roq::fbs::MarketByPriceUpdate> {
  static const Message enum_value = Message_MarketByPriceUpdate;
};

template <>
struct MessageTraits<roq::fbs::MarketByOrderUpdate> {
  static const Message enum_value = Message_MarketByOrderUpdate;
};

template <>
struct MessageTraits<roq::fbs::TradeSummary> {
  static const Message enum_value = Message_TradeSummary;
};

template <>
struct MessageTraits<roq::fbs::StatisticsUpdate> {
  static const Message enum_value = Message_StatisticsUpdate;
};

template <>
struct MessageTraits<roq::fbs::CreateOrder> {
  static const Message enum_value = Message_CreateOrder;
};

template <>
struct MessageTraits<roq::fbs::ModifyOrder> {
  static const Message enum_value = Message_ModifyOrder;
};

template <>
struct MessageTraits<roq::fbs::CancelOrder> {
  static const Message enum_value = Message_CancelOrder;
};

template <>
struct MessageTraits<roq::fbs::CancelAllOrders> {
  static const Message enum_value = Message_CancelAllOrders;
};

template <>
struct MessageTraits<roq::fbs::OrderAck> {
  static const Message enum_value = Message_OrderAck;
};

template <>
struct MessageTraits<roq::fbs::OrderUpdate> {
  static const Message enum_value = Message_OrderUpdate;
};

template <>
struct MessageTraits<roq::fbs::TradeUpdate> {
  static const Message enum_value = Message_TradeUpdate;
};

template <>
struct MessageTraits<roq::fbs::PositionUpdate> {
  static const Message enum_value = Message_PositionUpdate;
};

template <>
struct MessageTraits<roq::fbs::FundsUpdate> {
  static const Message enum_value = Message_FundsUpdate;
};

template <>
struct MessageTraits<roq::fbs::CustomMetrics> {
  static const Message enum_value = Message_CustomMetrics;
};

template <>
struct MessageTraits<roq::fbs::CustomMetricsUpdate> {
  static const Message enum_value = Message_CustomMetricsUpdate;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, void const *obj, Message type);
bool VerifyMessageVector(
    flatbuffers::Verifier &verifier,
    flatbuffers::Vector<flatbuffers::Offset<void>> const *values,
    flatbuffers::Vector<uint8_t> const *types);

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTERNAL_TRADE_ID = 4,
    VT_QUANTITY = 6,
    VT_PRICE = 8,
    VT_LIQUIDITY = 10
  };
  flatbuffers::String const *external_trade_id() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_TRADE_ID);
  }
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  double price() const { return GetField<double>(VT_PRICE, 0.0); }
  roq::fbs::Liquidity liquidity() const { return static_cast<roq::fbs::Liquidity>(GetField<uint8_t>(VT_LIQUIDITY, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_EXTERNAL_TRADE_ID) &&
           verifier.VerifyString(external_trade_id()) && VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) && VerifyField<uint8_t>(verifier, VT_LIQUIDITY, 1) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_external_trade_id(flatbuffers::Offset<flatbuffers::String> external_trade_id) {
    fbb_.AddOffset(Fill::VT_EXTERNAL_TRADE_ID, external_trade_id);
  }
  void add_quantity(double quantity) { fbb_.AddElement<double>(Fill::VT_QUANTITY, quantity, 0.0); }
  void add_price(double price) { fbb_.AddElement<double>(Fill::VT_PRICE, price, 0.0); }
  void add_liquidity(roq::fbs::Liquidity liquidity) {
    fbb_.AddElement<uint8_t>(Fill::VT_LIQUIDITY, static_cast<uint8_t>(liquidity), 0);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Fill> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> external_trade_id = 0,
    double quantity = 0.0,
    double price = 0.0,
    roq::fbs::Liquidity liquidity = roq::fbs::Liquidity_Undefined) {
  FillBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_external_trade_id(external_trade_id);
  builder_.add_liquidity(liquidity);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *external_trade_id = nullptr,
    double quantity = 0.0,
    double price = 0.0,
    roq::fbs::Liquidity liquidity = roq::fbs::Liquidity_Undefined) {
  auto external_trade_id__ = external_trade_id ? _fbb.CreateString(external_trade_id) : 0;
  return roq::fbs::CreateFill(_fbb, external_trade_id__, quantity, price, liquidity);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BID_PRICE = 4,
    VT_BID_QUANTITY = 6,
    VT_ASK_PRICE = 8,
    VT_ASK_QUANTITY = 10
  };
  double bid_price() const { return GetField<double>(VT_BID_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double bid_quantity() const { return GetField<double>(VT_BID_QUANTITY, 0.0); }
  double ask_price() const { return GetField<double>(VT_ASK_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double ask_quantity() const { return GetField<double>(VT_ASK_QUANTITY, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_BID_PRICE, 8) &&
           VerifyField<double>(verifier, VT_BID_QUANTITY, 8) && VerifyField<double>(verifier, VT_ASK_PRICE, 8) &&
           VerifyField<double>(verifier, VT_ASK_QUANTITY, 8) && verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bid_price(double bid_price) {
    fbb_.AddElement<double>(Layer::VT_BID_PRICE, bid_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_bid_quantity(double bid_quantity) { fbb_.AddElement<double>(Layer::VT_BID_QUANTITY, bid_quantity, 0.0); }
  void add_ask_price(double ask_price) {
    fbb_.AddElement<double>(Layer::VT_ASK_PRICE, ask_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_ask_quantity(double ask_quantity) { fbb_.AddElement<double>(Layer::VT_ASK_QUANTITY, ask_quantity, 0.0); }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Layer> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    double bid_price = std::numeric_limits<double>::quiet_NaN(),
    double bid_quantity = 0.0,
    double ask_price = std::numeric_limits<double>::quiet_NaN(),
    double ask_quantity = 0.0) {
  LayerBuilder builder_(_fbb);
  builder_.add_ask_quantity(ask_quantity);
  builder_.add_ask_price(ask_price);
  builder_.add_bid_quantity(bid_quantity);
  builder_.add_bid_price(bid_price);
  return builder_.Finish();
}

struct MBOUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBOUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_REMAINING_QUANTITY = 6,
    VT_ACTION = 8,
    VT_PRIORITY = 10,
    VT_ORDER_ID = 12
  };
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double remaining_quantity() const { return GetField<double>(VT_REMAINING_QUANTITY, 0.0); }
  roq::fbs::OrderUpdateAction action() const {
    return static_cast<roq::fbs::OrderUpdateAction>(GetField<uint8_t>(VT_ACTION, 0));
  }
  uint32_t priority() const { return GetField<uint32_t>(VT_PRIORITY, 0); }
  flatbuffers::String const *order_id() const { return GetPointer<flatbuffers::String const *>(VT_ORDER_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_REMAINING_QUANTITY, 8) && VerifyField<uint8_t>(verifier, VT_ACTION, 1) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) && VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) && verifier.EndTable();
  }
};

struct MBOUpdateBuilder {
  typedef MBOUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBOUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_remaining_quantity(double remaining_quantity) {
    fbb_.AddElement<double>(MBOUpdate::VT_REMAINING_QUANTITY, remaining_quantity, 0.0);
  }
  void add_action(roq::fbs::OrderUpdateAction action) {
    fbb_.AddElement<uint8_t>(MBOUpdate::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_priority(uint32_t priority) { fbb_.AddElement<uint32_t>(MBOUpdate::VT_PRIORITY, priority, 0); }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(MBOUpdate::VT_ORDER_ID, order_id);
  }
  explicit MBOUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MBOUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBOUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = 0.0,
    roq::fbs::OrderUpdateAction action = roq::fbs::OrderUpdateAction_Undefined,
    uint32_t priority = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0) {
  MBOUpdateBuilder builder_(_fbb);
  builder_.add_remaining_quantity(remaining_quantity);
  builder_.add_price(price);
  builder_.add_order_id(order_id);
  builder_.add_priority(priority);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = 0.0,
    roq::fbs::OrderUpdateAction action = roq::fbs::OrderUpdateAction_Undefined,
    uint32_t priority = 0,
    char const *order_id = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return roq::fbs::CreateMBOUpdate(_fbb, price, remaining_quantity, action, priority, order_id__);
}

struct MBPUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBPUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_QUANTITY = 6,
    VT_IMPLIED_QUANTITY = 8,
    VT_PRICE_LEVEL = 10,
    VT_NUMBER_OF_ORDERS = 12
  };
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  double implied_quantity() const { return GetField<double>(VT_IMPLIED_QUANTITY, 0.0); }
  uint32_t price_level() const { return GetField<uint32_t>(VT_PRICE_LEVEL, 0); }
  uint32_t number_of_orders() const { return GetField<uint32_t>(VT_NUMBER_OF_ORDERS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) && VerifyField<double>(verifier, VT_IMPLIED_QUANTITY, 8) &&
           VerifyField<uint32_t>(verifier, VT_PRICE_LEVEL, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_ORDERS, 4) && verifier.EndTable();
  }
};

struct MBPUpdateBuilder {
  typedef MBPUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBPUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) { fbb_.AddElement<double>(MBPUpdate::VT_QUANTITY, quantity, 0.0); }
  void add_implied_quantity(double implied_quantity) {
    fbb_.AddElement<double>(MBPUpdate::VT_IMPLIED_QUANTITY, implied_quantity, 0.0);
  }
  void add_price_level(uint32_t price_level) { fbb_.AddElement<uint32_t>(MBPUpdate::VT_PRICE_LEVEL, price_level, 0); }
  void add_number_of_orders(uint32_t number_of_orders) {
    fbb_.AddElement<uint32_t>(MBPUpdate::VT_NUMBER_OF_ORDERS, number_of_orders, 0);
  }
  explicit MBPUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MBPUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBPUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBPUpdate> CreateMBPUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    double implied_quantity = 0.0,
    uint32_t price_level = 0,
    uint32_t number_of_orders = 0) {
  MBPUpdateBuilder builder_(_fbb);
  builder_.add_implied_quantity(implied_quantity);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_number_of_orders(number_of_orders);
  builder_.add_price_level(price_level);
  return builder_.Finish();
}

struct Measurement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeasurementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_VALUE = 6 };
  flatbuffers::String const *name() const { return GetPointer<flatbuffers::String const *>(VT_NAME); }
  double value() const { return GetField<double>(VT_VALUE, std::numeric_limits<double>::quiet_NaN()); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyField<double>(verifier, VT_VALUE, 8) && verifier.EndTable();
  }
};

struct MeasurementBuilder {
  typedef Measurement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Measurement::VT_NAME, name); }
  void add_value(double value) {
    fbb_.AddElement<double>(Measurement::VT_VALUE, value, std::numeric_limits<double>::quiet_NaN());
  }
  explicit MeasurementBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Measurement> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Measurement>(end);
    return o;
  }
};

inline flatbuffers::Offset<Measurement> CreateMeasurement(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double value = std::numeric_limits<double>::quiet_NaN()) {
  MeasurementBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Measurement> CreateMeasurementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *name = nullptr,
    double value = std::numeric_limits<double>::quiet_NaN()) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return roq::fbs::CreateMeasurement(_fbb, name__, value);
}

struct Statistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6,
    VT_BEGIN_TIME_UTC = 8,
    VT_END_TIME_UTC = 10
  };
  roq::fbs::StatisticsType type() const { return static_cast<roq::fbs::StatisticsType>(GetField<uint8_t>(VT_TYPE, 0)); }
  double value() const { return GetField<double>(VT_VALUE, std::numeric_limits<double>::quiet_NaN()); }
  int64_t begin_time_utc() const { return GetField<int64_t>(VT_BEGIN_TIME_UTC, 0); }
  int64_t end_time_utc() const { return GetField<int64_t>(VT_END_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<double>(verifier, VT_VALUE, 8) && VerifyField<int64_t>(verifier, VT_BEGIN_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_END_TIME_UTC, 8) && verifier.EndTable();
  }
};

struct StatisticsBuilder {
  typedef Statistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(roq::fbs::StatisticsType type) {
    fbb_.AddElement<uint8_t>(Statistics::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Statistics::VT_VALUE, value, std::numeric_limits<double>::quiet_NaN());
  }
  void add_begin_time_utc(int64_t begin_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_BEGIN_TIME_UTC, begin_time_utc, 0);
  }
  void add_end_time_utc(int64_t end_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_END_TIME_UTC, end_time_utc, 0);
  }
  explicit StatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Statistics> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Statistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Statistics> CreateStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::StatisticsType type = roq::fbs::StatisticsType_Undefined,
    double value = std::numeric_limits<double>::quiet_NaN(),
    int64_t begin_time_utc = 0,
    int64_t end_time_utc = 0) {
  StatisticsBuilder builder_(_fbb);
  builder_.add_end_time_utc(end_time_utc);
  builder_.add_begin_time_utc(begin_time_utc);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIDE = 4,
    VT_PRICE = 6,
    VT_QUANTITY = 8,
    VT_TRADE_ID = 10
  };
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  flatbuffers::String const *trade_id() const { return GetPointer<flatbuffers::String const *>(VT_TRADE_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_SIDE, 1) &&
           VerifyField<double>(verifier, VT_PRICE, 8) && VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyOffset(verifier, VT_TRADE_ID) && verifier.VerifyString(trade_id()) && verifier.EndTable();
  }
};

struct TradeBuilder {
  typedef Trade Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(Trade::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_price(double price) {
    fbb_.AddElement<double>(Trade::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) { fbb_.AddElement<double>(Trade::VT_QUANTITY, quantity, 0.0); }
  void add_trade_id(flatbuffers::Offset<flatbuffers::String> trade_id) { fbb_.AddOffset(Trade::VT_TRADE_ID, trade_id); }
  explicit TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Trade> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    flatbuffers::Offset<flatbuffers::String> trade_id = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_trade_id(trade_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trade> CreateTradeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    char const *trade_id = nullptr) {
  auto trade_id__ = trade_id ? _fbb.CreateString(trade_id) : 0;
  return roq::fbs::CreateTrade(_fbb, side, price, quantity, trade_id__);
}

struct CancelAllOrders FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelAllOrdersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4 };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct CancelAllOrdersBuilder {
  typedef CancelAllOrders Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelAllOrders::VT_ACCOUNT, account);
  }
  explicit CancelAllOrdersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CancelAllOrders> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelAllOrders>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrders(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> account = 0) {
  CancelAllOrdersBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrdersDirect(
    flatbuffers::FlatBufferBuilder &_fbb, char const *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateCancelAllOrders(_fbb, account__);
}

struct CancelOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_ROUTING_ID = 8,
    VT_VERSION = 10,
    VT_CONDITIONAL_ON_VERSION = 12
  };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  uint32_t conditional_on_version() const { return GetField<uint32_t>(VT_CONDITIONAL_ON_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONDITIONAL_ON_VERSION, 4) && verifier.EndTable();
  }
};

struct CancelOrderBuilder {
  typedef CancelOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(CancelOrder::VT_ORDER_ID, order_id, 0); }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CancelOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(CancelOrder::VT_VERSION, version, 0); }
  void add_conditional_on_version(uint32_t conditional_on_version) {
    fbb_.AddElement<uint32_t>(CancelOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit CancelOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CancelOrder> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelOrder> CreateCancelOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  CancelOrderBuilder builder_(_fbb);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelOrder> CreateCancelOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *account = nullptr,
    uint32_t order_id = 0,
    char const *routing_id = nullptr,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCancelOrder(_fbb, account__, order_id, routing_id__, version, conditional_on_version);
}

struct CreateOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_SIDE = 12,
    VT_POSITION_EFFECT = 14,
    VT_MAX_SHOW_QUANTITY = 16,
    VT_ORDER_TYPE = 18,
    VT_TIME_IN_FORCE = 20,
    VT_ZZZ_EXECUTION_INSTRUCTIONS = 22,
    VT_ORDER_TEMPLATE = 24,
    VT_QUANTITY = 26,
    VT_PRICE = 28,
    VT_STOP_PRICE = 30,
    VT_ROUTING_ID = 32,
    VT_EXECUTION_INSTRUCTIONS = 34
  };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  uint8_t zzz_execution_instructions() const { return GetField<uint8_t>(VT_ZZZ_EXECUTION_INSTRUCTIONS, 0); }
  flatbuffers::String const *order_template() const {
    return GetPointer<flatbuffers::String const *>(VT_ORDER_TEMPLATE);
  }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double stop_price() const { return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  uint32_t execution_instructions() const { return GetField<uint32_t>(VT_EXECUTION_INSTRUCTIONS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY, 8) && VerifyField<uint8_t>(verifier, VT_ORDER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZZZ_EXECUTION_INSTRUCTIONS, 1) &&
           VerifyOffset(verifier, VT_ORDER_TEMPLATE) && verifier.VerifyString(order_template()) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) && VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_STOP_PRICE, 8) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint32_t>(verifier, VT_EXECUTION_INSTRUCTIONS, 4) &&
           verifier.EndTable();
  }
};

struct CreateOrderBuilder {
  typedef CreateOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CreateOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(CreateOrder::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CreateOrder::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(CreateOrder::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(CreateOrder::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(
        CreateOrder::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_zzz_execution_instructions(uint8_t zzz_execution_instructions) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_ZZZ_EXECUTION_INSTRUCTIONS, zzz_execution_instructions, 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(CreateOrder::VT_ORDER_TEMPLATE, order_template);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(CreateOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(CreateOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(CreateOrder::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CreateOrder::VT_ROUTING_ID, routing_id);
  }
  void add_execution_instructions(uint32_t execution_instructions) {
    fbb_.AddElement<uint32_t>(CreateOrder::VT_EXECUTION_INSTRUCTIONS, execution_instructions, 0);
  }
  explicit CreateOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CreateOrder> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateOrder> CreateCreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    uint8_t zzz_execution_instructions = 0,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t execution_instructions = 0) {
  CreateOrderBuilder builder_(_fbb);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_execution_instructions(execution_instructions);
  builder_.add_routing_id(routing_id);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_zzz_execution_instructions(zzz_execution_instructions);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateOrder> CreateCreateOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *account = nullptr,
    uint32_t order_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    uint8_t zzz_execution_instructions = 0,
    char const *order_template = nullptr,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    char const *routing_id = nullptr,
    uint32_t execution_instructions = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCreateOrder(
      _fbb,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      max_show_quantity,
      order_type,
      time_in_force,
      zzz_execution_instructions,
      order_template__,
      quantity,
      price,
      stop_price,
      routing_id__,
      execution_instructions);
}

struct CustomMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_MEASUREMENTS = 12
  };
  flatbuffers::String const *label() const { return GetPointer<flatbuffers::String const *>(VT_LABEL); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> const *measurements() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> const *>(VT_MEASUREMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_LABEL) && verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_MEASUREMENTS) && verifier.VerifyVector(measurements()) &&
           verifier.VerifyVectorOfTables(measurements()) && verifier.EndTable();
  }
};

struct CustomMetricsBuilder {
  typedef CustomMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) { fbb_.AddOffset(CustomMetrics::VT_LABEL, label); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CustomMetrics::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CustomMetrics::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(CustomMetrics::VT_SYMBOL, symbol); }
  void add_measurements(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements) {
    fbb_.AddOffset(CustomMetrics::VT_MEASUREMENTS, measurements);
  }
  explicit CustomMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CustomMetrics> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomMetrics> CreateCustomMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements = 0) {
  CustomMetricsBuilder builder_(_fbb);
  builder_.add_measurements(measurements);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_label(label);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomMetrics> CreateCustomMetricsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *label = nullptr,
    char const *account = nullptr,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::Measurement>> const *measurements = nullptr) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto measurements__ = measurements ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Measurement>>(*measurements) : 0;
  return roq::fbs::CreateCustomMetrics(_fbb, label__, account__, exchange__, symbol__, measurements__);
}

struct CustomMetricsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomMetricsUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER = 4,
    VT_LABEL = 6,
    VT_ACCOUNT = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_MEASUREMENTS = 14
  };
  flatbuffers::String const *user() const { return GetPointer<flatbuffers::String const *>(VT_USER); }
  flatbuffers::String const *label() const { return GetPointer<flatbuffers::String const *>(VT_LABEL); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> const *measurements() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>> const *>(VT_MEASUREMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_USER) && verifier.VerifyString(user()) &&
           VerifyOffset(verifier, VT_LABEL) && verifier.VerifyString(label()) && VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_MEASUREMENTS) && verifier.VerifyVector(measurements()) &&
           verifier.VerifyVectorOfTables(measurements()) && verifier.EndTable();
  }
};

struct CustomMetricsUpdateBuilder {
  typedef CustomMetricsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<flatbuffers::String> user) { fbb_.AddOffset(CustomMetricsUpdate::VT_USER, user); }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_LABEL, label);
  }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_SYMBOL, symbol);
  }
  void add_measurements(
      flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements) {
    fbb_.AddOffset(CustomMetricsUpdate::VT_MEASUREMENTS, measurements);
  }
  explicit CustomMetricsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CustomMetricsUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomMetricsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomMetricsUpdate> CreateCustomMetricsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Measurement>>> measurements = 0) {
  CustomMetricsUpdateBuilder builder_(_fbb);
  builder_.add_measurements(measurements);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_label(label);
  builder_.add_user(user);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomMetricsUpdate> CreateCustomMetricsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *user = nullptr,
    char const *label = nullptr,
    char const *account = nullptr,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::Measurement>> const *measurements = nullptr) {
  auto user__ = user ? _fbb.CreateString(user) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto measurements__ = measurements ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Measurement>>(*measurements) : 0;
  return roq::fbs::CreateCustomMetricsUpdate(_fbb, user__, label__, account__, exchange__, symbol__, measurements__);
}

struct DownloadBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadBeginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4 };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct DownloadBeginBuilder {
  typedef DownloadBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadBegin::VT_ACCOUNT, account);
  }
  explicit DownloadBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<DownloadBegin> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBegin(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> account = 0) {
  DownloadBeginBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBeginDirect(
    flatbuffers::FlatBufferBuilder &_fbb, char const *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadBegin(_fbb, account__);
}

struct DownloadEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadEndBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4, VT_MAX_ORDER_ID = 6 };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t max_order_id() const { return GetField<uint32_t>(VT_MAX_ORDER_ID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ORDER_ID, 4) && verifier.EndTable();
  }
};

struct DownloadEndBuilder {
  typedef DownloadEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadEnd::VT_ACCOUNT, account);
  }
  void add_max_order_id(uint32_t max_order_id) {
    fbb_.AddElement<uint32_t>(DownloadEnd::VT_MAX_ORDER_ID, max_order_id, 0);
  }
  explicit DownloadEndBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<DownloadEnd> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t max_order_id = 0) {
  DownloadEndBuilder builder_(_fbb);
  builder_.add_max_order_id(max_order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEndDirect(
    flatbuffers::FlatBufferBuilder &_fbb, char const *account = nullptr, uint32_t max_order_id = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadEnd(_fbb, account__, max_order_id);
}

struct ExternalLatency FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExternalLatencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_STREAM_ID = 4, VT_LATENCY = 6, VT_ACCOUNT = 8 };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  int64_t latency() const { return GetField<int64_t>(VT_LATENCY, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyField<int64_t>(verifier, VT_LATENCY, 8) && VerifyOffset(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) && verifier.EndTable();
  }
};

struct ExternalLatencyBuilder {
  typedef ExternalLatency Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(ExternalLatency::VT_STREAM_ID, stream_id, 0); }
  void add_latency(int64_t latency) { fbb_.AddElement<int64_t>(ExternalLatency::VT_LATENCY, latency, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ExternalLatency::VT_ACCOUNT, account);
  }
  explicit ExternalLatencyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ExternalLatency> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExternalLatency>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExternalLatency> CreateExternalLatency(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    int64_t latency = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0) {
  ExternalLatencyBuilder builder_(_fbb);
  builder_.add_latency(latency);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExternalLatency> CreateExternalLatencyDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t stream_id = 0, int64_t latency = 0, char const *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateExternalLatency(_fbb, stream_id, latency, account__);
}

struct FundsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FundsUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_CURRENCY = 8,
    VT_BALANCE = 10,
    VT_HOLD = 12,
    VT_EXTERNAL_ACCOUNT = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  flatbuffers::String const *currency() const { return GetPointer<flatbuffers::String const *>(VT_CURRENCY); }
  double balance() const { return GetField<double>(VT_BALANCE, std::numeric_limits<double>::quiet_NaN()); }
  double hold() const { return GetField<double>(VT_HOLD, std::numeric_limits<double>::quiet_NaN()); }
  flatbuffers::String const *external_account() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_CURRENCY) && verifier.VerifyString(currency()) &&
           VerifyField<double>(verifier, VT_BALANCE, 8) && VerifyField<double>(verifier, VT_HOLD, 8) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) && verifier.VerifyString(external_account()) &&
           verifier.EndTable();
  }
};

struct FundsUpdateBuilder {
  typedef FundsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(FundsUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(FundsUpdate::VT_ACCOUNT, account);
  }
  void add_currency(flatbuffers::Offset<flatbuffers::String> currency) {
    fbb_.AddOffset(FundsUpdate::VT_CURRENCY, currency);
  }
  void add_balance(double balance) {
    fbb_.AddElement<double>(FundsUpdate::VT_BALANCE, balance, std::numeric_limits<double>::quiet_NaN());
  }
  void add_hold(double hold) {
    fbb_.AddElement<double>(FundsUpdate::VT_HOLD, hold, std::numeric_limits<double>::quiet_NaN());
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(FundsUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  explicit FundsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<FundsUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FundsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> currency = 0,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> external_account = 0) {
  FundsUpdateBuilder builder_(_fbb);
  builder_.add_hold(hold);
  builder_.add_balance(balance);
  builder_.add_external_account(external_account);
  builder_.add_currency(currency);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    char const *currency = nullptr,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    char const *external_account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto currency__ = currency ? _fbb.CreateString(currency) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreateFundsUpdate(_fbb, stream_id, account__, currency__, balance, hold, external_account__);
}

struct GatewaySettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewaySettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUPPORTS = 4,
    VT_MBP_MAX_DEPTH = 6,
    VT_MBP_ALLOW_PRICE_INVERSION = 8,
    VT_MBP_ALLOW_REMOVE_NON_EXISTING = 12,
    VT_OMS_DOWNLOAD_HAS_STATE = 14,
    VT_OMS_DOWNLOAD_HAS_ROUTING_ID = 16,
    VT_MBP_TICK_SIZE_MULTIPLIER = 18,
    VT_MBP_MIN_TRADE_VOL_MULTIPLIER = 20,
    VT_OMS_REQUEST_ID_TYPE = 22
  };
  uint64_t supports() const { return GetField<uint64_t>(VT_SUPPORTS, 0); }
  uint32_t mbp_max_depth() const { return GetField<uint32_t>(VT_MBP_MAX_DEPTH, 0); }
  bool mbp_allow_price_inversion() const { return GetField<uint8_t>(VT_MBP_ALLOW_PRICE_INVERSION, 0) != 0; }
  bool mbp_allow_remove_non_existing() const { return GetField<uint8_t>(VT_MBP_ALLOW_REMOVE_NON_EXISTING, 0) != 0; }
  bool oms_download_has_state() const { return GetField<uint8_t>(VT_OMS_DOWNLOAD_HAS_STATE, 0) != 0; }
  bool oms_download_has_routing_id() const { return GetField<uint8_t>(VT_OMS_DOWNLOAD_HAS_ROUTING_ID, 0) != 0; }
  double mbp_tick_size_multiplier() const {
    return GetField<double>(VT_MBP_TICK_SIZE_MULTIPLIER, std::numeric_limits<double>::quiet_NaN());
  }
  double mbp_min_trade_vol_multiplier() const {
    return GetField<double>(VT_MBP_MIN_TRADE_VOL_MULTIPLIER, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::RequestIdType oms_request_id_type() const {
    return static_cast<roq::fbs::RequestIdType>(GetField<uint8_t>(VT_OMS_REQUEST_ID_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_SUPPORTS, 8) &&
           VerifyField<uint32_t>(verifier, VT_MBP_MAX_DEPTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_PRICE_INVERSION, 1) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_REMOVE_NON_EXISTING, 1) &&
           VerifyField<uint8_t>(verifier, VT_OMS_DOWNLOAD_HAS_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OMS_DOWNLOAD_HAS_ROUTING_ID, 1) &&
           VerifyField<double>(verifier, VT_MBP_TICK_SIZE_MULTIPLIER, 8) &&
           VerifyField<double>(verifier, VT_MBP_MIN_TRADE_VOL_MULTIPLIER, 8) &&
           VerifyField<uint8_t>(verifier, VT_OMS_REQUEST_ID_TYPE, 1) && verifier.EndTable();
  }
};

struct GatewaySettingsBuilder {
  typedef GatewaySettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_supports(uint64_t supports) { fbb_.AddElement<uint64_t>(GatewaySettings::VT_SUPPORTS, supports, 0); }
  void add_mbp_max_depth(uint32_t mbp_max_depth) {
    fbb_.AddElement<uint32_t>(GatewaySettings::VT_MBP_MAX_DEPTH, mbp_max_depth, 0);
  }
  void add_mbp_allow_price_inversion(bool mbp_allow_price_inversion) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_MBP_ALLOW_PRICE_INVERSION, static_cast<uint8_t>(mbp_allow_price_inversion), 0);
  }
  void add_mbp_allow_remove_non_existing(bool mbp_allow_remove_non_existing) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_MBP_ALLOW_REMOVE_NON_EXISTING, static_cast<uint8_t>(mbp_allow_remove_non_existing), 0);
  }
  void add_oms_download_has_state(bool oms_download_has_state) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_OMS_DOWNLOAD_HAS_STATE, static_cast<uint8_t>(oms_download_has_state), 0);
  }
  void add_oms_download_has_routing_id(bool oms_download_has_routing_id) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_OMS_DOWNLOAD_HAS_ROUTING_ID, static_cast<uint8_t>(oms_download_has_routing_id), 0);
  }
  void add_mbp_tick_size_multiplier(double mbp_tick_size_multiplier) {
    fbb_.AddElement<double>(
        GatewaySettings::VT_MBP_TICK_SIZE_MULTIPLIER,
        mbp_tick_size_multiplier,
        std::numeric_limits<double>::quiet_NaN());
  }
  void add_mbp_min_trade_vol_multiplier(double mbp_min_trade_vol_multiplier) {
    fbb_.AddElement<double>(
        GatewaySettings::VT_MBP_MIN_TRADE_VOL_MULTIPLIER,
        mbp_min_trade_vol_multiplier,
        std::numeric_limits<double>::quiet_NaN());
  }
  void add_oms_request_id_type(roq::fbs::RequestIdType oms_request_id_type) {
    fbb_.AddElement<uint8_t>(GatewaySettings::VT_OMS_REQUEST_ID_TYPE, static_cast<uint8_t>(oms_request_id_type), 0);
  }
  explicit GatewaySettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<GatewaySettings> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewaySettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewaySettings> CreateGatewaySettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t supports = 0,
    uint32_t mbp_max_depth = 0,
    bool mbp_allow_price_inversion = false,
    bool mbp_allow_remove_non_existing = false,
    bool oms_download_has_state = false,
    bool oms_download_has_routing_id = false,
    double mbp_tick_size_multiplier = std::numeric_limits<double>::quiet_NaN(),
    double mbp_min_trade_vol_multiplier = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::RequestIdType oms_request_id_type = roq::fbs::RequestIdType_Undefined) {
  GatewaySettingsBuilder builder_(_fbb);
  builder_.add_mbp_min_trade_vol_multiplier(mbp_min_trade_vol_multiplier);
  builder_.add_mbp_tick_size_multiplier(mbp_tick_size_multiplier);
  builder_.add_supports(supports);
  builder_.add_mbp_max_depth(mbp_max_depth);
  builder_.add_oms_request_id_type(oms_request_id_type);
  builder_.add_oms_download_has_routing_id(oms_download_has_routing_id);
  builder_.add_oms_download_has_state(oms_download_has_state);
  builder_.add_mbp_allow_remove_non_existing(mbp_allow_remove_non_existing);
  builder_.add_mbp_allow_price_inversion(mbp_allow_price_inversion);
  return builder_.Finish();
}

struct GatewayStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewayStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_SUPPORTED = 6,
    VT_AVAILABLE = 8,
    VT_UNAVAILABLE = 10
  };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint64_t supported() const { return GetField<uint64_t>(VT_SUPPORTED, 0); }
  uint64_t available() const { return GetField<uint64_t>(VT_AVAILABLE, 0); }
  uint64_t unavailable() const { return GetField<uint64_t>(VT_UNAVAILABLE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTED, 8) && VerifyField<uint64_t>(verifier, VT_AVAILABLE, 8) &&
           VerifyField<uint64_t>(verifier, VT_UNAVAILABLE, 8) && verifier.EndTable();
  }
};

struct GatewayStatusBuilder {
  typedef GatewayStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(GatewayStatus::VT_ACCOUNT, account);
  }
  void add_supported(uint64_t supported) { fbb_.AddElement<uint64_t>(GatewayStatus::VT_SUPPORTED, supported, 0); }
  void add_available(uint64_t available) { fbb_.AddElement<uint64_t>(GatewayStatus::VT_AVAILABLE, available, 0); }
  void add_unavailable(uint64_t unavailable) {
    fbb_.AddElement<uint64_t>(GatewayStatus::VT_UNAVAILABLE, unavailable, 0);
  }
  explicit GatewayStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<GatewayStatus> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewayStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  GatewayStatusBuilder builder_(_fbb);
  builder_.add_unavailable(unavailable);
  builder_.add_available(available);
  builder_.add_supported(supported);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *account = nullptr,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateGatewayStatus(_fbb, account__, supported, available, unavailable);
}

struct MarketByOrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByOrderUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_UPDATE_TYPE = 14,
    VT_EXCHANGE_TIME_UTC = 16,
    VT_EXCHANGE_SEQUENCE = 18,
    VT_PRICE_DECIMALS = 20,
    VT_QUANTITY_DECIMALS = 22,
    VT_CHECKSUM = 24
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *bids() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *>(VT_BIDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *asks() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *>(VT_ASKS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  int64_t exchange_sequence() const { return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0); }
  roq::fbs::Decimals price_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_PRICE_DECIMALS, 0));
  }
  roq::fbs::Decimals quantity_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_QUANTITY_DECIMALS, 0));
  }
  uint32_t checksum() const { return GetField<uint32_t>(VT_CHECKSUM, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) && verifier.VerifyVectorOfTables(bids()) && VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) && verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           VerifyField<uint8_t>(verifier, VT_PRICE_DECIMALS, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUANTITY_DECIMALS, 1) && VerifyField<uint32_t>(verifier, VT_CHECKSUM, 4) &&
           verifier.EndTable();
  }
};

struct MarketByOrderUpdateBuilder {
  typedef MarketByOrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketByOrderUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_ASKS, asks);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByOrderUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(MarketByOrderUpdate::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  void add_price_decimals(roq::fbs::Decimals price_decimals) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_PRICE_DECIMALS, static_cast<uint8_t>(price_decimals), 0);
  }
  void add_quantity_decimals(roq::fbs::Decimals quantity_decimals) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_QUANTITY_DECIMALS, static_cast<uint8_t>(quantity_decimals), 0);
  }
  void add_checksum(uint32_t checksum) { fbb_.AddElement<uint32_t>(MarketByOrderUpdate::VT_CHECKSUM, checksum, 0); }
  explicit MarketByOrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketByOrderUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByOrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals_Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals_Undefined,
    uint32_t checksum = 0) {
  MarketByOrderUpdateBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_checksum(checksum);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_quantity_decimals(quantity_decimals);
  builder_.add_price_decimals(price_decimals);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *bids = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> const *asks = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals_Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals_Undefined,
    uint32_t checksum = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByOrderUpdate(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      bids__,
      asks__,
      update_type,
      exchange_time_utc,
      exchange_sequence,
      price_decimals,
      quantity_decimals,
      checksum);
}

struct MarketByPriceUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByPriceUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_UPDATE_TYPE = 14,
    VT_EXCHANGE_TIME_UTC = 16,
    VT_EXCHANGE_SEQUENCE = 18,
    VT_PRICE_DECIMALS = 20,
    VT_QUANTITY_DECIMALS = 22,
    VT_MAX_DEPTH = 24,
    VT_CHECKSUM = 26
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *bids() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *>(VT_BIDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *asks() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *>(VT_ASKS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  int64_t exchange_sequence() const { return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0); }
  roq::fbs::Decimals price_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_PRICE_DECIMALS, 0));
  }
  roq::fbs::Decimals quantity_decimals() const {
    return static_cast<roq::fbs::Decimals>(GetField<uint8_t>(VT_QUANTITY_DECIMALS, 0));
  }
  uint16_t max_depth() const { return GetField<uint16_t>(VT_MAX_DEPTH, 0); }
  uint32_t checksum() const { return GetField<uint32_t>(VT_CHECKSUM, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) && verifier.VerifyVectorOfTables(bids()) && VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) && verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) &&
           VerifyField<uint8_t>(verifier, VT_PRICE_DECIMALS, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUANTITY_DECIMALS, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_DEPTH, 2) && VerifyField<uint32_t>(verifier, VT_CHECKSUM, 4) &&
           verifier.EndTable();
  }
};

struct MarketByPriceUpdateBuilder {
  typedef MarketByPriceUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketByPriceUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_ASKS, asks);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByPriceUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(MarketByPriceUpdate::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  void add_price_decimals(roq::fbs::Decimals price_decimals) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_PRICE_DECIMALS, static_cast<uint8_t>(price_decimals), 0);
  }
  void add_quantity_decimals(roq::fbs::Decimals quantity_decimals) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_QUANTITY_DECIMALS, static_cast<uint8_t>(quantity_decimals), 0);
  }
  void add_max_depth(uint16_t max_depth) { fbb_.AddElement<uint16_t>(MarketByPriceUpdate::VT_MAX_DEPTH, max_depth, 0); }
  void add_checksum(uint32_t checksum) { fbb_.AddElement<uint32_t>(MarketByPriceUpdate::VT_CHECKSUM, checksum, 0); }
  explicit MarketByPriceUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketByPriceUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByPriceUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals_Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals_Undefined,
    uint16_t max_depth = 0,
    uint32_t checksum = 0) {
  MarketByPriceUpdateBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_checksum(checksum);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_max_depth(max_depth);
  builder_.add_stream_id(stream_id);
  builder_.add_quantity_decimals(quantity_decimals);
  builder_.add_price_decimals(price_decimals);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *bids = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> const *asks = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0,
    roq::fbs::Decimals price_decimals = roq::fbs::Decimals_Undefined,
    roq::fbs::Decimals quantity_decimals = roq::fbs::Decimals_Undefined,
    uint16_t max_depth = 0,
    uint32_t checksum = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByPriceUpdate(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      bids__,
      asks__,
      update_type,
      exchange_time_utc,
      exchange_sequence,
      price_decimals,
      quantity_decimals,
      max_depth,
      checksum);
}

struct MarketStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADING_STATUS = 10
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::TradingStatus trading_status() const {
    return static_cast<roq::fbs::TradingStatus>(GetField<uint8_t>(VT_TRADING_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TRADING_STATUS, 1) && verifier.EndTable();
  }
};

struct MarketStatusBuilder {
  typedef MarketStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketStatus::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketStatus::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(MarketStatus::VT_SYMBOL, symbol); }
  void add_trading_status(roq::fbs::TradingStatus trading_status) {
    fbb_.AddElement<uint8_t>(MarketStatus::VT_TRADING_STATUS, static_cast<uint8_t>(trading_status), 0);
  }
  explicit MarketStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketStatus> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketStatus> CreateMarketStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus_Undefined) {
  MarketStatusBuilder builder_(_fbb);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_trading_status(trading_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketStatus> CreateMarketStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus_Undefined) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateMarketStatus(_fbb, stream_id, exchange__, symbol__, trading_status);
}

struct ModifyOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModifyOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_QUANTITY = 8,
    VT_PRICE = 10,
    VT_ROUTING_ID = 12,
    VT_VERSION = 14,
    VT_CONDITIONAL_ON_VERSION = 16
  };
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  uint32_t conditional_on_version() const { return GetField<uint32_t>(VT_CONDITIONAL_ON_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyField<double>(verifier, VT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_CONDITIONAL_ON_VERSION, 4) && verifier.EndTable();
  }
};

struct ModifyOrderBuilder {
  typedef ModifyOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ModifyOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(ModifyOrder::VT_ORDER_ID, order_id, 0); }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(ModifyOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(ModifyOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(ModifyOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(ModifyOrder::VT_VERSION, version, 0); }
  void add_conditional_on_version(uint32_t conditional_on_version) {
    fbb_.AddElement<uint32_t>(ModifyOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit ModifyOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ModifyOrder> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModifyOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  ModifyOrderBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *account = nullptr,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    char const *routing_id = nullptr,
    uint32_t version = 0,
    uint32_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateModifyOrder(
      _fbb, account__, order_id, quantity, price, routing_id__, version, conditional_on_version);
}

struct OrderAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_TYPE = 14,
    VT_ORIGIN = 16,
    VT_STATUS = 18,
    VT_ERROR = 20,
    VT_TEXT = 22,
    VT_REQUEST_ID = 24,
    VT_EXTERNAL_ACCOUNT = 26,
    VT_EXTERNAL_ORDER_ID = 28,
    VT_ROUTING_ID = 30,
    VT_VERSION = 32,
    VT_SIDE = 34,
    VT_ROUND_TRIP_LATENCY = 36
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::RequestType type() const { return static_cast<roq::fbs::RequestType>(GetField<uint8_t>(VT_TYPE, 0)); }
  roq::fbs::Origin origin() const { return static_cast<roq::fbs::Origin>(GetField<uint8_t>(VT_ORIGIN, 0)); }
  roq::fbs::RequestStatus status() const {
    return static_cast<roq::fbs::RequestStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  roq::fbs::Error error() const { return static_cast<roq::fbs::Error>(GetField<uint8_t>(VT_ERROR, 0)); }
  flatbuffers::String const *text() const { return GetPointer<flatbuffers::String const *>(VT_TEXT); }
  flatbuffers::String const *request_id() const { return GetPointer<flatbuffers::String const *>(VT_REQUEST_ID); }
  flatbuffers::String const *external_account() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ACCOUNT);
  }
  flatbuffers::String const *external_order_id() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ORDER_ID);
  }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  int64_t round_trip_latency() const { return GetField<int64_t>(VT_ROUND_TRIP_LATENCY, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) && VerifyField<uint8_t>(verifier, VT_ORIGIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) && VerifyField<uint8_t>(verifier, VT_ERROR, 1) &&
           VerifyOffset(verifier, VT_TEXT) && verifier.VerifyString(text()) && VerifyOffset(verifier, VT_REQUEST_ID) &&
           verifier.VerifyString(request_id()) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) && VerifyField<int64_t>(verifier, VT_ROUND_TRIP_LATENCY, 8) &&
           verifier.EndTable();
  }
};

struct OrderAckBuilder {
  typedef OrderAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(OrderAck::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) { fbb_.AddOffset(OrderAck::VT_ACCOUNT, account); }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(OrderAck::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(OrderAck::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(OrderAck::VT_SYMBOL, symbol); }
  void add_type(roq::fbs::RequestType type) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_origin(roq::fbs::Origin origin) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ORIGIN, static_cast<uint8_t>(origin), 0);
  }
  void add_status(roq::fbs::RequestStatus status) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_error(roq::fbs::Error error) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(OrderAck::VT_TEXT, text); }
  void add_request_id(flatbuffers::Offset<flatbuffers::String> request_id) {
    fbb_.AddOffset(OrderAck::VT_REQUEST_ID, request_id);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderAck::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(OrderAck::VT_VERSION, version, 0); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(OrderAck::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_round_trip_latency(int64_t round_trip_latency) {
    fbb_.AddElement<int64_t>(OrderAck::VT_ROUND_TRIP_LATENCY, round_trip_latency, 0);
  }
  explicit OrderAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<OrderAck> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderAck> CreateOrderAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::RequestType type = roq::fbs::RequestType_Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus_Undefined,
    roq::fbs::Error error = roq::fbs::Error_Undefined,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> request_id = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t version = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    int64_t round_trip_latency = 0) {
  OrderAckBuilder builder_(_fbb);
  builder_.add_round_trip_latency(round_trip_latency);
  builder_.add_version(version);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_request_id(request_id);
  builder_.add_text(text);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_side(side);
  builder_.add_error(error);
  builder_.add_status(status);
  builder_.add_origin(origin);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderAck> CreateOrderAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    uint32_t order_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    roq::fbs::RequestType type = roq::fbs::RequestType_Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus_Undefined,
    roq::fbs::Error error = roq::fbs::Error_Undefined,
    char const *text = nullptr,
    char const *request_id = nullptr,
    char const *external_account = nullptr,
    char const *external_order_id = nullptr,
    char const *routing_id = nullptr,
    uint32_t version = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    int64_t round_trip_latency = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto request_id__ = request_id ? _fbb.CreateString(request_id) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateOrderAck(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      type,
      origin,
      status,
      error,
      text__,
      request_id__,
      external_account__,
      external_order_id__,
      routing_id__,
      version,
      side,
      round_trip_latency);
}

struct OrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_MAX_SHOW_QUANTITY = 18,
    VT_ORDER_TYPE = 20,
    VT_TIME_IN_FORCE = 22,
    VT_ZZZ_EXECUTION_INSTRUCTIONS = 24,
    VT_ORDER_TEMPLATE = 26,
    VT_CREATE_TIME_UTC = 28,
    VT_UPDATE_TIME_UTC = 30,
    VT_EXTERNAL_ACCOUNT = 32,
    VT_EXTERNAL_ORDER_ID = 34,
    VT_STATUS = 36,
    VT_QUANTITY = 38,
    VT_PRICE = 40,
    VT_STOP_PRICE = 42,
    VT_REMAINING_QUANTITY = 44,
    VT_TRADED_QUANTITY = 46,
    VT_AVERAGE_TRADED_PRICE = 48,
    VT_LAST_TRADED_QUANTITY = 50,
    VT_LAST_TRADED_PRICE = 52,
    VT_LAST_LIQUIDITY = 54,
    VT_ROUTING_ID = 56,
    VT_MAX_REQUEST_VERSION = 58,
    VT_MAX_RESPONSE_VERSION = 60,
    VT_MAX_ACCEPTED_VERSION = 62,
    VT_UPDATE_TYPE = 64,
    VT_EXECUTION_INSTRUCTIONS = 66
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  uint8_t zzz_execution_instructions() const { return GetField<uint8_t>(VT_ZZZ_EXECUTION_INSTRUCTIONS, 0); }
  flatbuffers::String const *order_template() const {
    return GetPointer<flatbuffers::String const *>(VT_ORDER_TEMPLATE);
  }
  int64_t create_time_utc() const { return GetField<int64_t>(VT_CREATE_TIME_UTC, 0); }
  int64_t update_time_utc() const { return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0); }
  flatbuffers::String const *external_account() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ACCOUNT);
  }
  flatbuffers::String const *external_order_id() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ORDER_ID);
  }
  roq::fbs::OrderStatus status() const { return static_cast<roq::fbs::OrderStatus>(GetField<uint8_t>(VT_STATUS, 0)); }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double stop_price() const { return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double remaining_quantity() const {
    return GetField<double>(VT_REMAINING_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double traded_quantity() const {
    return GetField<double>(VT_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double average_traded_price() const {
    return GetField<double>(VT_AVERAGE_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_quantity() const {
    return GetField<double>(VT_LAST_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_price() const {
    return GetField<double>(VT_LAST_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::Liquidity last_liquidity() const {
    return static_cast<roq::fbs::Liquidity>(GetField<uint8_t>(VT_LAST_LIQUIDITY, 0));
  }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  uint32_t max_request_version() const { return GetField<uint32_t>(VT_MAX_REQUEST_VERSION, 0); }
  uint32_t max_response_version() const { return GetField<uint32_t>(VT_MAX_RESPONSE_VERSION, 0); }
  uint32_t max_accepted_version() const { return GetField<uint32_t>(VT_MAX_ACCEPTED_VERSION, 0); }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  uint32_t execution_instructions() const { return GetField<uint32_t>(VT_EXECUTION_INSTRUCTIONS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY, 8) && VerifyField<uint8_t>(verifier, VT_ORDER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ZZZ_EXECUTION_INSTRUCTIONS, 1) &&
           VerifyOffset(verifier, VT_ORDER_TEMPLATE) && verifier.VerifyString(order_template()) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC, 8) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) && VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<double>(verifier, VT_QUANTITY, 8) && VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyField<double>(verifier, VT_STOP_PRICE, 8) && VerifyField<double>(verifier, VT_REMAINING_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_TRADED_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_AVERAGE_TRADED_PRICE, 8) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_PRICE, 8) &&
           VerifyField<uint8_t>(verifier, VT_LAST_LIQUIDITY, 1) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint32_t>(verifier, VT_MAX_REQUEST_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_RESPONSE_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ACCEPTED_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_EXECUTION_INSTRUCTIONS, 4) && verifier.EndTable();
  }
};

struct OrderUpdateBuilder {
  typedef OrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(OrderUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(OrderUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(OrderUpdate::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(OrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(OrderUpdate::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(OrderUpdate::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_zzz_execution_instructions(uint8_t zzz_execution_instructions) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_ZZZ_EXECUTION_INSTRUCTIONS, zzz_execution_instructions, 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(OrderUpdate::VT_ORDER_TEMPLATE, order_template);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_status(roq::fbs::OrderStatus status) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(OrderUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(OrderUpdate::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_remaining_quantity(double remaining_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_REMAINING_QUANTITY, remaining_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_traded_quantity(double traded_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_TRADED_QUANTITY, traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_average_traded_price(double average_traded_price) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_AVERAGE_TRADED_PRICE, average_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_quantity(double last_traded_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_LAST_TRADED_QUANTITY, last_traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_price(double last_traded_price) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_LAST_TRADED_PRICE, last_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_liquidity(roq::fbs::Liquidity last_liquidity) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_LAST_LIQUIDITY, static_cast<uint8_t>(last_liquidity), 0);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_max_request_version(uint32_t max_request_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_REQUEST_VERSION, max_request_version, 0);
  }
  void add_max_response_version(uint32_t max_response_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_RESPONSE_VERSION, max_response_version, 0);
  }
  void add_max_accepted_version(uint32_t max_accepted_version) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_MAX_ACCEPTED_VERSION, max_accepted_version, 0);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_execution_instructions(uint32_t execution_instructions) {
    fbb_.AddElement<uint32_t>(OrderUpdate::VT_EXECUTION_INSTRUCTIONS, execution_instructions, 0);
  }
  explicit OrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<OrderUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    uint8_t zzz_execution_instructions = 0,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity_Undefined,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint32_t max_request_version = 0,
    uint32_t max_response_version = 0,
    uint32_t max_accepted_version = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    uint32_t execution_instructions = 0) {
  OrderUpdateBuilder builder_(_fbb);
  builder_.add_last_traded_price(last_traded_price);
  builder_.add_last_traded_quantity(last_traded_quantity);
  builder_.add_average_traded_price(average_traded_price);
  builder_.add_traded_quantity(traded_quantity);
  builder_.add_remaining_quantity(remaining_quantity);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_execution_instructions(execution_instructions);
  builder_.add_max_accepted_version(max_accepted_version);
  builder_.add_max_response_version(max_response_version);
  builder_.add_max_request_version(max_request_version);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  builder_.add_last_liquidity(last_liquidity);
  builder_.add_status(status);
  builder_.add_zzz_execution_instructions(zzz_execution_instructions);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    uint32_t order_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    uint8_t zzz_execution_instructions = 0,
    char const *order_template = nullptr,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    char const *external_account = nullptr,
    char const *external_order_id = nullptr,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity_Undefined,
    char const *routing_id = nullptr,
    uint32_t max_request_version = 0,
    uint32_t max_response_version = 0,
    uint32_t max_accepted_version = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    uint32_t execution_instructions = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateOrderUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      max_show_quantity,
      order_type,
      time_in_force,
      zzz_execution_instructions,
      order_template__,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      status,
      quantity,
      price,
      stop_price,
      remaining_quantity,
      traded_quantity,
      average_traded_price,
      last_traded_quantity,
      last_traded_price,
      last_liquidity,
      routing_id__,
      max_request_version,
      max_response_version,
      max_accepted_version,
      update_type,
      execution_instructions);
}

struct PositionUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PositionUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_EXTERNAL_ACCOUNT = 24,
    VT_LONG_QUANTITY = 26,
    VT_SHORT_QUANTITY = 28,
    VT_LONG_QUANTITY_BEGIN = 30,
    VT_SHORT_QUANTITY_BEGIN = 32
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::String const *external_account() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ACCOUNT);
  }
  double long_quantity() const { return GetField<double>(VT_LONG_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double short_quantity() const {
    return GetField<double>(VT_SHORT_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double long_quantity_begin() const {
    return GetField<double>(VT_LONG_QUANTITY_BEGIN, std::numeric_limits<double>::quiet_NaN());
  }
  double short_quantity_begin() const {
    return GetField<double>(VT_SHORT_QUANTITY_BEGIN, std::numeric_limits<double>::quiet_NaN());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) && verifier.VerifyString(external_account()) &&
           VerifyField<double>(verifier, VT_LONG_QUANTITY, 8) && VerifyField<double>(verifier, VT_SHORT_QUANTITY, 8) &&
           VerifyField<double>(verifier, VT_LONG_QUANTITY_BEGIN, 8) &&
           VerifyField<double>(verifier, VT_SHORT_QUANTITY_BEGIN, 8) && verifier.EndTable();
  }
};

struct PositionUpdateBuilder {
  typedef PositionUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(PositionUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(PositionUpdate::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(PositionUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(PositionUpdate::VT_SYMBOL, symbol);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(PositionUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_long_quantity(double long_quantity) {
    fbb_.AddElement<double>(PositionUpdate::VT_LONG_QUANTITY, long_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_short_quantity(double short_quantity) {
    fbb_.AddElement<double>(
        PositionUpdate::VT_SHORT_QUANTITY, short_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_long_quantity_begin(double long_quantity_begin) {
    fbb_.AddElement<double>(
        PositionUpdate::VT_LONG_QUANTITY_BEGIN, long_quantity_begin, std::numeric_limits<double>::quiet_NaN());
  }
  void add_short_quantity_begin(double short_quantity_begin) {
    fbb_.AddElement<double>(
        PositionUpdate::VT_SHORT_QUANTITY_BEGIN, short_quantity_begin, std::numeric_limits<double>::quiet_NaN());
  }
  explicit PositionUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<PositionUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PositionUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    double long_quantity = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity = std::numeric_limits<double>::quiet_NaN(),
    double long_quantity_begin = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity_begin = std::numeric_limits<double>::quiet_NaN()) {
  PositionUpdateBuilder builder_(_fbb);
  builder_.add_short_quantity_begin(short_quantity_begin);
  builder_.add_long_quantity_begin(long_quantity_begin);
  builder_.add_short_quantity(short_quantity);
  builder_.add_long_quantity(long_quantity);
  builder_.add_external_account(external_account);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    char const *external_account = nullptr,
    double long_quantity = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity = std::numeric_limits<double>::quiet_NaN(),
    double long_quantity_begin = std::numeric_limits<double>::quiet_NaN(),
    double short_quantity_begin = std::numeric_limits<double>::quiet_NaN()) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreatePositionUpdate(
      _fbb,
      stream_id,
      account__,
      exchange__,
      symbol__,
      external_account__,
      long_quantity,
      short_quantity,
      long_quantity_begin,
      short_quantity_begin);
}

struct RateLimitTrigger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RateLimitTriggerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ORIGIN = 6,
    VT_TYPE = 8,
    VT_USERS = 10,
    VT_ACCOUNTS = 12,
    VT_BAN_EXPIRES = 14,
    VT_TRIGGERED_BY = 16
  };
  flatbuffers::String const *name() const { return GetPointer<flatbuffers::String const *>(VT_NAME); }
  roq::fbs::Origin origin() const { return static_cast<roq::fbs::Origin>(GetField<uint8_t>(VT_ORIGIN, 0)); }
  roq::fbs::RateLimitType type() const { return static_cast<roq::fbs::RateLimitType>(GetField<uint8_t>(VT_TYPE, 0)); }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> const *users() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> const *>(VT_USERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> const *accounts() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> const *>(VT_ACCOUNTS);
  }
  int64_t ban_expires() const { return GetField<int64_t>(VT_BAN_EXPIRES, 0); }
  flatbuffers::String const *triggered_by() const { return GetPointer<flatbuffers::String const *>(VT_TRIGGERED_BY); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ORIGIN, 1) && VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_USERS) && verifier.VerifyVector(users()) &&
           verifier.VerifyVectorOfStrings(users()) && VerifyOffset(verifier, VT_ACCOUNTS) &&
           verifier.VerifyVector(accounts()) && verifier.VerifyVectorOfStrings(accounts()) &&
           VerifyField<int64_t>(verifier, VT_BAN_EXPIRES, 8) && VerifyOffset(verifier, VT_TRIGGERED_BY) &&
           verifier.VerifyString(triggered_by()) && verifier.EndTable();
  }
};

struct RateLimitTriggerBuilder {
  typedef RateLimitTrigger Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(RateLimitTrigger::VT_NAME, name); }
  void add_origin(roq::fbs::Origin origin) {
    fbb_.AddElement<uint8_t>(RateLimitTrigger::VT_ORIGIN, static_cast<uint8_t>(origin), 0);
  }
  void add_type(roq::fbs::RateLimitType type) {
    fbb_.AddElement<uint8_t>(RateLimitTrigger::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> users) {
    fbb_.AddOffset(RateLimitTrigger::VT_USERS, users);
  }
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts) {
    fbb_.AddOffset(RateLimitTrigger::VT_ACCOUNTS, accounts);
  }
  void add_ban_expires(int64_t ban_expires) {
    fbb_.AddElement<int64_t>(RateLimitTrigger::VT_BAN_EXPIRES, ban_expires, 0);
  }
  void add_triggered_by(flatbuffers::Offset<flatbuffers::String> triggered_by) {
    fbb_.AddOffset(RateLimitTrigger::VT_TRIGGERED_BY, triggered_by);
  }
  explicit RateLimitTriggerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<RateLimitTrigger> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RateLimitTrigger>(end);
    return o;
  }
};

inline flatbuffers::Offset<RateLimitTrigger> CreateRateLimitTrigger(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RateLimitType type = roq::fbs::RateLimitType_Undefined,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> users = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts = 0,
    int64_t ban_expires = 0,
    flatbuffers::Offset<flatbuffers::String> triggered_by = 0) {
  RateLimitTriggerBuilder builder_(_fbb);
  builder_.add_ban_expires(ban_expires);
  builder_.add_triggered_by(triggered_by);
  builder_.add_accounts(accounts);
  builder_.add_users(users);
  builder_.add_name(name);
  builder_.add_type(type);
  builder_.add_origin(origin);
  return builder_.Finish();
}

inline flatbuffers::Offset<RateLimitTrigger> CreateRateLimitTriggerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    char const *name = nullptr,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RateLimitType type = roq::fbs::RateLimitType_Undefined,
    std::vector<flatbuffers::Offset<flatbuffers::String>> const *users = nullptr,
    std::vector<flatbuffers::Offset<flatbuffers::String>> const *accounts = nullptr,
    int64_t ban_expires = 0,
    char const *triggered_by = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto users__ = users ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*users) : 0;
  auto accounts__ = accounts ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*accounts) : 0;
  auto triggered_by__ = triggered_by ? _fbb.CreateString(triggered_by) : 0;
  return roq::fbs::CreateRateLimitTrigger(_fbb, name__, origin, type, users__, accounts__, ban_expires, triggered_by__);
}

struct ReferenceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReferenceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_DESCRIPTION = 10,
    VT_SECURITY_TYPE = 12,
    VT_QUOTE_CURRENCY = 14,
    VT_BASE_CURRENCY = 16,
    VT_COMMISSION_CURRENCY = 18,
    VT_TICK_SIZE = 20,
    VT_MULTIPLIER = 22,
    VT_MIN_TRADE_VOL = 24,
    VT_OPTION_TYPE = 26,
    VT_STRIKE_CURRENCY = 28,
    VT_STRIKE_PRICE = 30,
    VT_UNDERLYING = 32,
    VT_TIME_ZONE = 34,
    VT_ISSUE_DATE = 36,
    VT_SETTLEMENT_DATE = 38,
    VT_EXPIRY_DATETIME = 40,
    VT_EXPIRY_DATETIME_UTC = 42,
    VT_MAX_TRADE_VOL = 44,
    VT_TRADE_VOL_STEP_SIZE = 46,
    VT_MARGIN_CURRENCY = 48
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::String const *description() const { return GetPointer<flatbuffers::String const *>(VT_DESCRIPTION); }
  roq::fbs::SecurityType security_type() const {
    return static_cast<roq::fbs::SecurityType>(GetField<uint8_t>(VT_SECURITY_TYPE, 0));
  }
  flatbuffers::String const *quote_currency() const {
    return GetPointer<flatbuffers::String const *>(VT_QUOTE_CURRENCY);
  }
  flatbuffers::String const *base_currency() const { return GetPointer<flatbuffers::String const *>(VT_BASE_CURRENCY); }
  flatbuffers::String const *commission_currency() const {
    return GetPointer<flatbuffers::String const *>(VT_COMMISSION_CURRENCY);
  }
  double tick_size() const { return GetField<double>(VT_TICK_SIZE, std::numeric_limits<double>::quiet_NaN()); }
  double multiplier() const { return GetField<double>(VT_MULTIPLIER, std::numeric_limits<double>::quiet_NaN()); }
  double min_trade_vol() const { return GetField<double>(VT_MIN_TRADE_VOL, std::numeric_limits<double>::quiet_NaN()); }
  roq::fbs::OptionType option_type() const {
    return static_cast<roq::fbs::OptionType>(GetField<uint8_t>(VT_OPTION_TYPE, 0));
  }
  flatbuffers::String const *strike_currency() const {
    return GetPointer<flatbuffers::String const *>(VT_STRIKE_CURRENCY);
  }
  double strike_price() const { return GetField<double>(VT_STRIKE_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  flatbuffers::String const *underlying() const { return GetPointer<flatbuffers::String const *>(VT_UNDERLYING); }
  flatbuffers::String const *time_zone() const { return GetPointer<flatbuffers::String const *>(VT_TIME_ZONE); }
  int32_t issue_date() const { return GetField<int32_t>(VT_ISSUE_DATE, 0); }
  int32_t settlement_date() const { return GetField<int32_t>(VT_SETTLEMENT_DATE, 0); }
  int64_t expiry_datetime() const { return GetField<int64_t>(VT_EXPIRY_DATETIME, 0); }
  int64_t expiry_datetime_utc() const { return GetField<int64_t>(VT_EXPIRY_DATETIME_UTC, 0); }
  double max_trade_vol() const { return GetField<double>(VT_MAX_TRADE_VOL, std::numeric_limits<double>::quiet_NaN()); }
  double trade_vol_step_size() const {
    return GetField<double>(VT_TRADE_VOL_STEP_SIZE, std::numeric_limits<double>::quiet_NaN());
  }
  flatbuffers::String const *margin_currency() const {
    return GetPointer<flatbuffers::String const *>(VT_MARGIN_CURRENCY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) && verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_SECURITY_TYPE, 1) && VerifyOffset(verifier, VT_QUOTE_CURRENCY) &&
           verifier.VerifyString(quote_currency()) && VerifyOffset(verifier, VT_BASE_CURRENCY) &&
           verifier.VerifyString(base_currency()) && VerifyOffset(verifier, VT_COMMISSION_CURRENCY) &&
           verifier.VerifyString(commission_currency()) && VerifyField<double>(verifier, VT_TICK_SIZE, 8) &&
           VerifyField<double>(verifier, VT_MULTIPLIER, 8) && VerifyField<double>(verifier, VT_MIN_TRADE_VOL, 8) &&
           VerifyField<uint8_t>(verifier, VT_OPTION_TYPE, 1) && VerifyOffset(verifier, VT_STRIKE_CURRENCY) &&
           verifier.VerifyString(strike_currency()) && VerifyField<double>(verifier, VT_STRIKE_PRICE, 8) &&
           VerifyOffset(verifier, VT_UNDERLYING) && verifier.VerifyString(underlying()) &&
           VerifyOffset(verifier, VT_TIME_ZONE) && verifier.VerifyString(time_zone()) &&
           VerifyField<int32_t>(verifier, VT_ISSUE_DATE, 4) && VerifyField<int32_t>(verifier, VT_SETTLEMENT_DATE, 4) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME, 8) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME_UTC, 8) &&
           VerifyField<double>(verifier, VT_MAX_TRADE_VOL, 8) &&
           VerifyField<double>(verifier, VT_TRADE_VOL_STEP_SIZE, 8) && VerifyOffset(verifier, VT_MARGIN_CURRENCY) &&
           verifier.VerifyString(margin_currency()) && verifier.EndTable();
  }
};

struct ReferenceDataBuilder {
  typedef ReferenceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(ReferenceData::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(ReferenceData::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(ReferenceData::VT_SYMBOL, symbol); }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(ReferenceData::VT_DESCRIPTION, description);
  }
  void add_security_type(roq::fbs::SecurityType security_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_SECURITY_TYPE, static_cast<uint8_t>(security_type), 0);
  }
  void add_quote_currency(flatbuffers::Offset<flatbuffers::String> quote_currency) {
    fbb_.AddOffset(ReferenceData::VT_QUOTE_CURRENCY, quote_currency);
  }
  void add_base_currency(flatbuffers::Offset<flatbuffers::String> base_currency) {
    fbb_.AddOffset(ReferenceData::VT_BASE_CURRENCY, base_currency);
  }
  void add_commission_currency(flatbuffers::Offset<flatbuffers::String> commission_currency) {
    fbb_.AddOffset(ReferenceData::VT_COMMISSION_CURRENCY, commission_currency);
  }
  void add_tick_size(double tick_size) {
    fbb_.AddElement<double>(ReferenceData::VT_TICK_SIZE, tick_size, std::numeric_limits<double>::quiet_NaN());
  }
  void add_multiplier(double multiplier) {
    fbb_.AddElement<double>(ReferenceData::VT_MULTIPLIER, multiplier, std::numeric_limits<double>::quiet_NaN());
  }
  void add_min_trade_vol(double min_trade_vol) {
    fbb_.AddElement<double>(ReferenceData::VT_MIN_TRADE_VOL, min_trade_vol, std::numeric_limits<double>::quiet_NaN());
  }
  void add_option_type(roq::fbs::OptionType option_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_OPTION_TYPE, static_cast<uint8_t>(option_type), 0);
  }
  void add_strike_currency(flatbuffers::Offset<flatbuffers::String> strike_currency) {
    fbb_.AddOffset(ReferenceData::VT_STRIKE_CURRENCY, strike_currency);
  }
  void add_strike_price(double strike_price) {
    fbb_.AddElement<double>(ReferenceData::VT_STRIKE_PRICE, strike_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_underlying(flatbuffers::Offset<flatbuffers::String> underlying) {
    fbb_.AddOffset(ReferenceData::VT_UNDERLYING, underlying);
  }
  void add_time_zone(flatbuffers::Offset<flatbuffers::String> time_zone) {
    fbb_.AddOffset(ReferenceData::VT_TIME_ZONE, time_zone);
  }
  void add_issue_date(int32_t issue_date) { fbb_.AddElement<int32_t>(ReferenceData::VT_ISSUE_DATE, issue_date, 0); }
  void add_settlement_date(int32_t settlement_date) {
    fbb_.AddElement<int32_t>(ReferenceData::VT_SETTLEMENT_DATE, settlement_date, 0);
  }
  void add_expiry_datetime(int64_t expiry_datetime) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME, expiry_datetime, 0);
  }
  void add_expiry_datetime_utc(int64_t expiry_datetime_utc) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME_UTC, expiry_datetime_utc, 0);
  }
  void add_max_trade_vol(double max_trade_vol) {
    fbb_.AddElement<double>(ReferenceData::VT_MAX_TRADE_VOL, max_trade_vol, std::numeric_limits<double>::quiet_NaN());
  }
  void add_trade_vol_step_size(double trade_vol_step_size) {
    fbb_.AddElement<double>(
        ReferenceData::VT_TRADE_VOL_STEP_SIZE, trade_vol_step_size, std::numeric_limits<double>::quiet_NaN());
  }
  void add_margin_currency(flatbuffers::Offset<flatbuffers::String> margin_currency) {
    fbb_.AddOffset(ReferenceData::VT_MARGIN_CURRENCY, margin_currency);
  }
  explicit ReferenceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ReferenceData> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReferenceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReferenceData> CreateReferenceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType_Undefined,
    flatbuffers::Offset<flatbuffers::String> quote_currency = 0,
    flatbuffers::Offset<flatbuffers::String> base_currency = 0,
    flatbuffers::Offset<flatbuffers::String> commission_currency = 0,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType_Undefined,
    flatbuffers::Offset<flatbuffers::String> strike_currency = 0,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> underlying = 0,
    flatbuffers::Offset<flatbuffers::String> time_zone = 0,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0,
    double max_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    double trade_vol_step_size = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> margin_currency = 0) {
  ReferenceDataBuilder builder_(_fbb);
  builder_.add_trade_vol_step_size(trade_vol_step_size);
  builder_.add_max_trade_vol(max_trade_vol);
  builder_.add_expiry_datetime_utc(expiry_datetime_utc);
  builder_.add_expiry_datetime(expiry_datetime);
  builder_.add_strike_price(strike_price);
  builder_.add_min_trade_vol(min_trade_vol);
  builder_.add_multiplier(multiplier);
  builder_.add_tick_size(tick_size);
  builder_.add_margin_currency(margin_currency);
  builder_.add_settlement_date(settlement_date);
  builder_.add_issue_date(issue_date);
  builder_.add_time_zone(time_zone);
  builder_.add_underlying(underlying);
  builder_.add_strike_currency(strike_currency);
  builder_.add_commission_currency(commission_currency);
  builder_.add_base_currency(base_currency);
  builder_.add_quote_currency(quote_currency);
  builder_.add_description(description);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_option_type(option_type);
  builder_.add_security_type(security_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReferenceData> CreateReferenceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    char const *description = nullptr,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType_Undefined,
    char const *quote_currency = nullptr,
    char const *base_currency = nullptr,
    char const *commission_currency = nullptr,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType_Undefined,
    char const *strike_currency = nullptr,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    char const *underlying = nullptr,
    char const *time_zone = nullptr,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0,
    double max_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    double trade_vol_step_size = std::numeric_limits<double>::quiet_NaN(),
    char const *margin_currency = nullptr) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto quote_currency__ = quote_currency ? _fbb.CreateString(quote_currency) : 0;
  auto base_currency__ = base_currency ? _fbb.CreateString(base_currency) : 0;
  auto commission_currency__ = commission_currency ? _fbb.CreateString(commission_currency) : 0;
  auto strike_currency__ = strike_currency ? _fbb.CreateString(strike_currency) : 0;
  auto underlying__ = underlying ? _fbb.CreateString(underlying) : 0;
  auto time_zone__ = time_zone ? _fbb.CreateString(time_zone) : 0;
  auto margin_currency__ = margin_currency ? _fbb.CreateString(margin_currency) : 0;
  return roq::fbs::CreateReferenceData(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      description__,
      security_type,
      quote_currency__,
      base_currency__,
      commission_currency__,
      tick_size,
      multiplier,
      min_trade_vol,
      option_type,
      strike_currency__,
      strike_price,
      underlying__,
      time_zone__,
      issue_date,
      settlement_date,
      expiry_datetime,
      expiry_datetime_utc,
      max_trade_vol,
      trade_vol_step_size,
      margin_currency__);
}

struct StatisticsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_STATISTICS = 10,
    VT_UPDATE_TYPE = 12,
    VT_EXCHANGE_TIME_UTC = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> const *statistics() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> const *>(VT_STATISTICS);
  }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_STATISTICS) && verifier.VerifyVector(statistics()) &&
           verifier.VerifyVectorOfTables(statistics()) && VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) && verifier.EndTable();
  }
};

struct StatisticsUpdateBuilder {
  typedef StatisticsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(StatisticsUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(StatisticsUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(StatisticsUpdate::VT_SYMBOL, symbol);
  }
  void add_statistics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics) {
    fbb_.AddOffset(StatisticsUpdate::VT_STATISTICS, statistics);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(StatisticsUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(StatisticsUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit StatisticsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<StatisticsUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatisticsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0) {
  StatisticsUpdateBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_statistics(statistics);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::Statistics>> const *statistics = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto statistics__ = statistics ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Statistics>>(*statistics) : 0;
  return roq::fbs::CreateStatisticsUpdate(
      _fbb, stream_id, exchange__, symbol__, statistics__, update_type, exchange_time_utc);
}

struct StreamStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StreamStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_SUPPORTS = 8,
    VT_CONNECTION_STATUS = 10,
    VT_PROTOCOL = 12,
    VT_PRIORITY = 14,
    VT_TRANSPORT = 16,
    VT_ENCODING = 18
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint64_t supports() const { return GetField<uint64_t>(VT_SUPPORTS, 0); }
  roq::fbs::ConnectionStatus connection_status() const {
    return static_cast<roq::fbs::ConnectionStatus>(GetField<uint8_t>(VT_CONNECTION_STATUS, 0));
  }
  roq::fbs::Protocol protocol() const { return static_cast<roq::fbs::Protocol>(GetField<uint8_t>(VT_PROTOCOL, 0)); }
  roq::fbs::Priority priority() const { return static_cast<roq::fbs::Priority>(GetField<uint32_t>(VT_PRIORITY, 0)); }
  roq::fbs::Transport transport() const { return static_cast<roq::fbs::Transport>(GetField<uint8_t>(VT_TRANSPORT, 0)); }
  uint32_t encoding() const { return GetField<uint32_t>(VT_ENCODING, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTS, 8) && VerifyField<uint8_t>(verifier, VT_CONNECTION_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) && VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPORT, 1) && VerifyField<uint32_t>(verifier, VT_ENCODING, 4) &&
           verifier.EndTable();
  }
};

struct StreamStatusBuilder {
  typedef StreamStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(StreamStatus::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(StreamStatus::VT_ACCOUNT, account);
  }
  void add_supports(uint64_t supports) { fbb_.AddElement<uint64_t>(StreamStatus::VT_SUPPORTS, supports, 0); }
  void add_connection_status(roq::fbs::ConnectionStatus connection_status) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_CONNECTION_STATUS, static_cast<uint8_t>(connection_status), 0);
  }
  void add_protocol(roq::fbs::Protocol protocol) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_PROTOCOL, static_cast<uint8_t>(protocol), 0);
  }
  void add_priority(roq::fbs::Priority priority) {
    fbb_.AddElement<uint32_t>(StreamStatus::VT_PRIORITY, static_cast<uint32_t>(priority), 0);
  }
  void add_transport(roq::fbs::Transport transport) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_TRANSPORT, static_cast<uint8_t>(transport), 0);
  }
  void add_encoding(uint32_t encoding) { fbb_.AddElement<uint32_t>(StreamStatus::VT_ENCODING, encoding, 0); }
  explicit StreamStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<StreamStatus> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StreamStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<StreamStatus> CreateStreamStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus connection_status = roq::fbs::ConnectionStatus_Undefined,
    roq::fbs::Protocol protocol = roq::fbs::Protocol_Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority_Undefined,
    roq::fbs::Transport transport = roq::fbs::Transport_Undefined,
    uint32_t encoding = 0) {
  StreamStatusBuilder builder_(_fbb);
  builder_.add_supports(supports);
  builder_.add_encoding(encoding);
  builder_.add_priority(priority);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_transport(transport);
  builder_.add_protocol(protocol);
  builder_.add_connection_status(connection_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<StreamStatus> CreateStreamStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus connection_status = roq::fbs::ConnectionStatus_Undefined,
    roq::fbs::Protocol protocol = roq::fbs::Protocol_Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority_Undefined,
    roq::fbs::Transport transport = roq::fbs::Transport_Undefined,
    uint32_t encoding = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateStreamStatus(
      _fbb, stream_id, account__, supports, connection_status, protocol, priority, transport, encoding);
}

struct TopOfBook FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopOfBookBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_LAYER = 10,
    VT_UPDATE_TYPE = 12,
    VT_EXCHANGE_TIME_UTC = 14,
    VT_EXCHANGE_SEQUENCE = 16
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::Layer const *layer() const { return GetPointer<roq::fbs::Layer const *>(VT_LAYER); }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  int64_t exchange_sequence() const { return GetField<int64_t>(VT_EXCHANGE_SEQUENCE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_LAYER) &&
           verifier.VerifyTable(layer()) && VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_SEQUENCE, 8) && verifier.EndTable();
  }
};

struct TopOfBookBuilder {
  typedef TopOfBook Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TopOfBook::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TopOfBook::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TopOfBook::VT_SYMBOL, symbol); }
  void add_layer(flatbuffers::Offset<roq::fbs::Layer> layer) { fbb_.AddOffset(TopOfBook::VT_LAYER, layer); }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(TopOfBook::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TopOfBook::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  void add_exchange_sequence(int64_t exchange_sequence) {
    fbb_.AddElement<int64_t>(TopOfBook::VT_EXCHANGE_SEQUENCE, exchange_sequence, 0);
  }
  explicit TopOfBookBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TopOfBook> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopOfBook>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopOfBook> CreateTopOfBook(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  TopOfBookBuilder builder_(_fbb);
  builder_.add_exchange_sequence(exchange_sequence);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_layer(layer);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopOfBook> CreateTopOfBookDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined,
    int64_t exchange_time_utc = 0,
    int64_t exchange_sequence = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateTopOfBook(
      _fbb, stream_id, exchange__, symbol__, layer, update_type, exchange_time_utc, exchange_sequence);
}

struct TradeSummary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeSummaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADES = 10,
    VT_EXCHANGE_TIME_UTC = 12
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> const *trades() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> const *>(VT_TRADES);
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_TRADES) &&
           verifier.VerifyVector(trades()) && verifier.VerifyVectorOfTables(trades()) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC, 8) && verifier.EndTable();
  }
};

struct TradeSummaryBuilder {
  typedef TradeSummary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TradeSummary::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeSummary::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TradeSummary::VT_SYMBOL, symbol); }
  void add_trades(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades) {
    fbb_.AddOffset(TradeSummary::VT_TRADES, trades);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TradeSummary::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit TradeSummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TradeSummary> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSummary>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSummary> CreateTradeSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades = 0,
    int64_t exchange_time_utc = 0) {
  TradeSummaryBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_trades(trades);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TradeSummary> CreateTradeSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::Trade>> const *trades = nullptr,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto trades__ = trades ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Trade>>(*trades) : 0;
  return roq::fbs::CreateTradeSummary(_fbb, stream_id, exchange__, symbol__, trades__, exchange_time_utc);
}

struct TradeUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_CREATE_TIME_UTC = 18,
    VT_UPDATE_TIME_UTC = 20,
    VT_EXTERNAL_ACCOUNT = 22,
    VT_EXTERNAL_ORDER_ID = 24,
    VT_FILLS = 26,
    VT_ROUTING_ID = 28,
    VT_UPDATE_TYPE = 30
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  flatbuffers::String const *account() const { return GetPointer<flatbuffers::String const *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  flatbuffers::String const *exchange() const { return GetPointer<flatbuffers::String const *>(VT_EXCHANGE); }
  flatbuffers::String const *symbol() const { return GetPointer<flatbuffers::String const *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  int64_t create_time_utc() const { return GetField<int64_t>(VT_CREATE_TIME_UTC, 0); }
  int64_t update_time_utc() const { return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0); }
  flatbuffers::String const *external_account() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ACCOUNT);
  }
  flatbuffers::String const *external_order_id() const {
    return GetPointer<flatbuffers::String const *>(VT_EXTERNAL_ORDER_ID);
  }
  flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> const *fills() const {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> const *>(VT_FILLS);
  }
  flatbuffers::String const *routing_id() const { return GetPointer<flatbuffers::String const *>(VT_ROUTING_ID); }
  roq::fbs::UpdateType update_type() const {
    return static_cast<roq::fbs::UpdateType>(GetField<uint8_t>(VT_UPDATE_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID, 2) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID, 4) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE, 1) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT, 1) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC, 8) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC, 8) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) && VerifyOffset(verifier, VT_FILLS) &&
           verifier.VerifyVector(fills()) && verifier.VerifyVectorOfTables(fills()) &&
           VerifyOffset(verifier, VT_ROUTING_ID) && verifier.VerifyString(routing_id()) &&
           VerifyField<uint8_t>(verifier, VT_UPDATE_TYPE, 1) && verifier.EndTable();
  }
};

struct TradeUpdateBuilder {
  typedef TradeUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TradeUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(TradeUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(TradeUpdate::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TradeUpdate::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(TradeUpdate::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_fills(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills) {
    fbb_.AddOffset(TradeUpdate::VT_FILLS, fills);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(TradeUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_update_type(roq::fbs::UpdateType update_type) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_UPDATE_TYPE, static_cast<uint8_t>(update_type), 0);
  }
  explicit TradeUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TradeUpdate> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined) {
  TradeUpdateBuilder builder_(_fbb);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_routing_id(routing_id);
  builder_.add_fills(fills);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_update_type(update_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    char const *account = nullptr,
    uint32_t order_id = 0,
    char const *exchange = nullptr,
    char const *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    char const *external_account = nullptr,
    char const *external_order_id = nullptr,
    std::vector<flatbuffers::Offset<roq::fbs::Fill>> const *fills = nullptr,
    char const *routing_id = nullptr,
    roq::fbs::UpdateType update_type = roq::fbs::UpdateType_Undefined) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto fills__ = fills ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Fill>>(*fills) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateTradeUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      fills__,
      routing_id__,
      update_type);
}

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_UUID = 12,
    VT_LOGIN = 14,
    VT_PASSWORD = 16
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  flatbuffers::String const *application() const { return GetPointer<flatbuffers::String const *>(VT_APPLICATION); }
  flatbuffers::String const *hostname() const { return GetPointer<flatbuffers::String const *>(VT_HOSTNAME); }
  uint32_t pid() const { return GetField<uint32_t>(VT_PID, 0); }
  flatbuffers::String const *uuid() const { return GetPointer<flatbuffers::String const *>(VT_UUID); }
  flatbuffers::String const *login() const { return GetPointer<flatbuffers::String const *>(VT_LOGIN); }
  flatbuffers::String const *password() const { return GetPointer<flatbuffers::String const *>(VT_PASSWORD); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_APPLICATION) && verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) && verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID, 4) && VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) && VerifyOffset(verifier, VT_LOGIN) && verifier.VerifyString(login()) &&
           VerifyOffset(verifier, VT_PASSWORD) && verifier.VerifyString(password()) && verifier.EndTable();
  }
};

struct HandshakeBuilder {
  typedef Handshake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(Handshake::VT_VERSION, version, 0); }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(Handshake::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(Handshake::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) { fbb_.AddElement<uint32_t>(Handshake::VT_PID, pid, 0); }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) { fbb_.AddOffset(Handshake::VT_UUID, uuid); }
  void add_login(flatbuffers::Offset<flatbuffers::String> login) { fbb_.AddOffset(Handshake::VT_LOGIN, login); }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Handshake::VT_PASSWORD, password);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Handshake> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> login = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_login(login);
  builder_.add_uuid(uuid);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    char const *application = nullptr,
    char const *hostname = nullptr,
    uint32_t pid = 0,
    char const *uuid = nullptr,
    char const *login = nullptr,
    char const *password = nullptr) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto login__ = login ? _fbb.CreateString(login) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return roq::fbs::CreateHandshake(_fbb, version, application__, hostname__, pid, uuid__, login__, password__);
}

struct HandshakeAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_FAILURE = 12,
    VT_FAILURE_REASON = 14,
    VT_UUID = 16,
    VT_NAME = 18,
    VT_USER_ID = 20
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  flatbuffers::String const *application() const { return GetPointer<flatbuffers::String const *>(VT_APPLICATION); }
  flatbuffers::String const *hostname() const { return GetPointer<flatbuffers::String const *>(VT_HOSTNAME); }
  uint32_t pid() const { return GetField<uint32_t>(VT_PID, 0); }
  bool failure() const { return GetField<uint8_t>(VT_FAILURE, 0) != 0; }
  flatbuffers::String const *failure_reason() const {
    return GetPointer<flatbuffers::String const *>(VT_FAILURE_REASON);
  }
  flatbuffers::String const *uuid() const { return GetPointer<flatbuffers::String const *>(VT_UUID); }
  flatbuffers::String const *name() const { return GetPointer<flatbuffers::String const *>(VT_NAME); }
  uint8_t user_id() const { return GetField<uint8_t>(VT_USER_ID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_APPLICATION) && verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) && verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID, 4) && VerifyField<uint8_t>(verifier, VT_FAILURE, 1) &&
           VerifyOffset(verifier, VT_FAILURE_REASON) && verifier.VerifyString(failure_reason()) &&
           VerifyOffset(verifier, VT_UUID) && verifier.VerifyString(uuid()) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint8_t>(verifier, VT_USER_ID, 1) && verifier.EndTable();
  }
};

struct HandshakeAckBuilder {
  typedef HandshakeAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(HandshakeAck::VT_VERSION, version, 0); }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(HandshakeAck::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(HandshakeAck::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) { fbb_.AddElement<uint32_t>(HandshakeAck::VT_PID, pid, 0); }
  void add_failure(bool failure) {
    fbb_.AddElement<uint8_t>(HandshakeAck::VT_FAILURE, static_cast<uint8_t>(failure), 0);
  }
  void add_failure_reason(flatbuffers::Offset<flatbuffers::String> failure_reason) {
    fbb_.AddOffset(HandshakeAck::VT_FAILURE_REASON, failure_reason);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) { fbb_.AddOffset(HandshakeAck::VT_UUID, uuid); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(HandshakeAck::VT_NAME, name); }
  void add_user_id(uint8_t user_id) { fbb_.AddElement<uint8_t>(HandshakeAck::VT_USER_ID, user_id, 0); }
  explicit HandshakeAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<HandshakeAck> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    bool failure = false,
    flatbuffers::Offset<flatbuffers::String> failure_reason = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t user_id = 0) {
  HandshakeAckBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  builder_.add_failure_reason(failure_reason);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  builder_.add_user_id(user_id);
  builder_.add_failure(failure);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    char const *application = nullptr,
    char const *hostname = nullptr,
    uint32_t pid = 0,
    bool failure = false,
    char const *failure_reason = nullptr,
    char const *uuid = nullptr,
    char const *name = nullptr,
    uint8_t user_id = 0) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto failure_reason__ = failure_reason ? _fbb.CreateString(failure_reason) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return roq::fbs::CreateHandshakeAck(
      _fbb, version, application__, hostname__, pid, failure, failure_reason__, uuid__, name__, user_id);
}

struct Subscribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct SubscribeBuilder {
  typedef Subscribe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubscribeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Subscribe> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Subscribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Subscribe> CreateSubscribe(flatbuffers::FlatBufferBuilder &_fbb) {
  SubscribeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchBeginBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct BatchBeginBuilder {
  typedef BatchBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<BatchBegin> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchBegin> CreateBatchBegin(flatbuffers::FlatBufferBuilder &_fbb) {
  BatchBeginBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchEndBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct BatchEndBuilder {
  typedef BatchEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchEndBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<BatchEnd> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchEnd> CreateBatchEnd(flatbuffers::FlatBufferBuilder &_fbb) {
  BatchEndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SourceInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQNO = 4,
    VT_SEND_TIME_UTC = 6,
    VT_CREATE_TIME_UTC = 8,
    VT_SEND_TIME = 10,
    VT_CREATE_TIME = 12
  };
  uint64_t seqno() const { return GetField<uint64_t>(VT_SEQNO, 0); }
  uint64_t send_time_utc() const { return GetField<uint64_t>(VT_SEND_TIME_UTC, 0); }
  uint64_t create_time_utc() const { return GetField<uint64_t>(VT_CREATE_TIME_UTC, 0); }
  uint64_t send_time() const { return GetField<uint64_t>(VT_SEND_TIME, 0); }
  uint64_t create_time() const { return GetField<uint64_t>(VT_CREATE_TIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_SEQNO, 8) &&
           VerifyField<uint64_t>(verifier, VT_SEND_TIME_UTC, 8) &&
           VerifyField<uint64_t>(verifier, VT_CREATE_TIME_UTC, 8) && VerifyField<uint64_t>(verifier, VT_SEND_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_CREATE_TIME, 8) && verifier.EndTable();
  }
};

struct SourceInfoBuilder {
  typedef SourceInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqno(uint64_t seqno) { fbb_.AddElement<uint64_t>(SourceInfo::VT_SEQNO, seqno, 0); }
  void add_send_time_utc(uint64_t send_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME_UTC, send_time_utc, 0);
  }
  void add_create_time_utc(uint64_t create_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_send_time(uint64_t send_time) { fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME, send_time, 0); }
  void add_create_time(uint64_t create_time) { fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME, create_time, 0); }
  explicit SourceInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<SourceInfo> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceInfo> CreateSourceInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seqno = 0,
    uint64_t send_time_utc = 0,
    uint64_t create_time_utc = 0,
    uint64_t send_time = 0,
    uint64_t create_time = 0) {
  SourceInfoBuilder builder_(_fbb);
  builder_.add_create_time(create_time);
  builder_.add_send_time(send_time);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_send_time_utc(send_time_utc);
  builder_.add_seqno(seqno);
  return builder_.Finish();
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_INFO = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  roq::fbs::SourceInfo const *source_info() const { return GetPointer<roq::fbs::SourceInfo const *>(VT_SOURCE_INFO); }
  roq::fbs::Message message_type() const {
    return static_cast<roq::fbs::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  void const *message() const { return GetPointer<void const *>(VT_MESSAGE); }
  template <typename T>
  const T *message_as() const;
  roq::fbs::Handshake const *message_as_Handshake() const {
    return message_type() == roq::fbs::Message_Handshake ? static_cast<roq::fbs::Handshake const *>(message())
                                                         : nullptr;
  }
  roq::fbs::HandshakeAck const *message_as_HandshakeAck() const {
    return message_type() == roq::fbs::Message_HandshakeAck ? static_cast<roq::fbs::HandshakeAck const *>(message())
                                                            : nullptr;
  }
  roq::fbs::Subscribe const *message_as_Subscribe() const {
    return message_type() == roq::fbs::Message_Subscribe ? static_cast<roq::fbs::Subscribe const *>(message())
                                                         : nullptr;
  }
  roq::fbs::BatchBegin const *message_as_BatchBegin() const {
    return message_type() == roq::fbs::Message_BatchBegin ? static_cast<roq::fbs::BatchBegin const *>(message())
                                                          : nullptr;
  }
  roq::fbs::BatchEnd const *message_as_BatchEnd() const {
    return message_type() == roq::fbs::Message_BatchEnd ? static_cast<roq::fbs::BatchEnd const *>(message()) : nullptr;
  }
  roq::fbs::DownloadBegin const *message_as_DownloadBegin() const {
    return message_type() == roq::fbs::Message_DownloadBegin ? static_cast<roq::fbs::DownloadBegin const *>(message())
                                                             : nullptr;
  }
  roq::fbs::DownloadEnd const *message_as_DownloadEnd() const {
    return message_type() == roq::fbs::Message_DownloadEnd ? static_cast<roq::fbs::DownloadEnd const *>(message())
                                                           : nullptr;
  }
  roq::fbs::GatewaySettings const *message_as_GatewaySettings() const {
    return message_type() == roq::fbs::Message_GatewaySettings
               ? static_cast<roq::fbs::GatewaySettings const *>(message())
               : nullptr;
  }
  roq::fbs::StreamStatus const *message_as_StreamStatus() const {
    return message_type() == roq::fbs::Message_StreamStatus ? static_cast<roq::fbs::StreamStatus const *>(message())
                                                            : nullptr;
  }
  roq::fbs::ExternalLatency const *message_as_ExternalLatency() const {
    return message_type() == roq::fbs::Message_ExternalLatency
               ? static_cast<roq::fbs::ExternalLatency const *>(message())
               : nullptr;
  }
  roq::fbs::RateLimitTrigger const *message_as_RateLimitTrigger() const {
    return message_type() == roq::fbs::Message_RateLimitTrigger
               ? static_cast<roq::fbs::RateLimitTrigger const *>(message())
               : nullptr;
  }
  roq::fbs::GatewayStatus const *message_as_GatewayStatus() const {
    return message_type() == roq::fbs::Message_GatewayStatus ? static_cast<roq::fbs::GatewayStatus const *>(message())
                                                             : nullptr;
  }
  roq::fbs::ReferenceData const *message_as_ReferenceData() const {
    return message_type() == roq::fbs::Message_ReferenceData ? static_cast<roq::fbs::ReferenceData const *>(message())
                                                             : nullptr;
  }
  roq::fbs::MarketStatus const *message_as_MarketStatus() const {
    return message_type() == roq::fbs::Message_MarketStatus ? static_cast<roq::fbs::MarketStatus const *>(message())
                                                            : nullptr;
  }
  roq::fbs::TopOfBook const *message_as_TopOfBook() const {
    return message_type() == roq::fbs::Message_TopOfBook ? static_cast<roq::fbs::TopOfBook const *>(message())
                                                         : nullptr;
  }
  roq::fbs::MarketByPriceUpdate const *message_as_MarketByPriceUpdate() const {
    return message_type() == roq::fbs::Message_MarketByPriceUpdate
               ? static_cast<roq::fbs::MarketByPriceUpdate const *>(message())
               : nullptr;
  }
  roq::fbs::MarketByOrderUpdate const *message_as_MarketByOrderUpdate() const {
    return message_type() == roq::fbs::Message_MarketByOrderUpdate
               ? static_cast<roq::fbs::MarketByOrderUpdate const *>(message())
               : nullptr;
  }
  roq::fbs::TradeSummary const *message_as_TradeSummary() const {
    return message_type() == roq::fbs::Message_TradeSummary ? static_cast<roq::fbs::TradeSummary const *>(message())
                                                            : nullptr;
  }
  roq::fbs::StatisticsUpdate const *message_as_StatisticsUpdate() const {
    return message_type() == roq::fbs::Message_StatisticsUpdate
               ? static_cast<roq::fbs::StatisticsUpdate const *>(message())
               : nullptr;
  }
  roq::fbs::CreateOrder const *message_as_CreateOrder() const {
    return message_type() == roq::fbs::Message_CreateOrder ? static_cast<roq::fbs::CreateOrder const *>(message())
                                                           : nullptr;
  }
  roq::fbs::ModifyOrder const *message_as_ModifyOrder() const {
    return message_type() == roq::fbs::Message_ModifyOrder ? static_cast<roq::fbs::ModifyOrder const *>(message())
                                                           : nullptr;
  }
  roq::fbs::CancelOrder const *message_as_CancelOrder() const {
    return message_type() == roq::fbs::Message_CancelOrder ? static_cast<roq::fbs::CancelOrder const *>(message())
                                                           : nullptr;
  }
  roq::fbs::CancelAllOrders const *message_as_CancelAllOrders() const {
    return message_type() == roq::fbs::Message_CancelAllOrders
               ? static_cast<roq::fbs::CancelAllOrders const *>(message())
               : nullptr;
  }
  roq::fbs::OrderAck const *message_as_OrderAck() const {
    return message_type() == roq::fbs::Message_OrderAck ? static_cast<roq::fbs::OrderAck const *>(message()) : nullptr;
  }
  roq::fbs::OrderUpdate const *message_as_OrderUpdate() const {
    return message_type() == roq::fbs::Message_OrderUpdate ? static_cast<roq::fbs::OrderUpdate const *>(message())
                                                           : nullptr;
  }
  roq::fbs::TradeUpdate const *message_as_TradeUpdate() const {
    return message_type() == roq::fbs::Message_TradeUpdate ? static_cast<roq::fbs::TradeUpdate const *>(message())
                                                           : nullptr;
  }
  roq::fbs::PositionUpdate const *message_as_PositionUpdate() const {
    return message_type() == roq::fbs::Message_PositionUpdate ? static_cast<roq::fbs::PositionUpdate const *>(message())
                                                              : nullptr;
  }
  roq::fbs::FundsUpdate const *message_as_FundsUpdate() const {
    return message_type() == roq::fbs::Message_FundsUpdate ? static_cast<roq::fbs::FundsUpdate const *>(message())
                                                           : nullptr;
  }
  roq::fbs::CustomMetrics const *message_as_CustomMetrics() const {
    return message_type() == roq::fbs::Message_CustomMetrics ? static_cast<roq::fbs::CustomMetrics const *>(message())
                                                             : nullptr;
  }
  roq::fbs::CustomMetricsUpdate const *message_as_CustomMetricsUpdate() const {
    return message_type() == roq::fbs::Message_CustomMetricsUpdate
               ? static_cast<roq::fbs::CustomMetricsUpdate const *>(message())
               : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SOURCE_INFO) &&
           verifier.VerifyTable(source_info()) && VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) && VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template <>
inline roq::fbs::Handshake const *Event::message_as<roq::fbs::Handshake>() const {
  return message_as_Handshake();
}

template <>
inline roq::fbs::HandshakeAck const *Event::message_as<roq::fbs::HandshakeAck>() const {
  return message_as_HandshakeAck();
}

template <>
inline roq::fbs::Subscribe const *Event::message_as<roq::fbs::Subscribe>() const {
  return message_as_Subscribe();
}

template <>
inline roq::fbs::BatchBegin const *Event::message_as<roq::fbs::BatchBegin>() const {
  return message_as_BatchBegin();
}

template <>
inline roq::fbs::BatchEnd const *Event::message_as<roq::fbs::BatchEnd>() const {
  return message_as_BatchEnd();
}

template <>
inline roq::fbs::DownloadBegin const *Event::message_as<roq::fbs::DownloadBegin>() const {
  return message_as_DownloadBegin();
}

template <>
inline roq::fbs::DownloadEnd const *Event::message_as<roq::fbs::DownloadEnd>() const {
  return message_as_DownloadEnd();
}

template <>
inline roq::fbs::GatewaySettings const *Event::message_as<roq::fbs::GatewaySettings>() const {
  return message_as_GatewaySettings();
}

template <>
inline roq::fbs::StreamStatus const *Event::message_as<roq::fbs::StreamStatus>() const {
  return message_as_StreamStatus();
}

template <>
inline roq::fbs::ExternalLatency const *Event::message_as<roq::fbs::ExternalLatency>() const {
  return message_as_ExternalLatency();
}

template <>
inline roq::fbs::RateLimitTrigger const *Event::message_as<roq::fbs::RateLimitTrigger>() const {
  return message_as_RateLimitTrigger();
}

template <>
inline roq::fbs::GatewayStatus const *Event::message_as<roq::fbs::GatewayStatus>() const {
  return message_as_GatewayStatus();
}

template <>
inline roq::fbs::ReferenceData const *Event::message_as<roq::fbs::ReferenceData>() const {
  return message_as_ReferenceData();
}

template <>
inline roq::fbs::MarketStatus const *Event::message_as<roq::fbs::MarketStatus>() const {
  return message_as_MarketStatus();
}

template <>
inline roq::fbs::TopOfBook const *Event::message_as<roq::fbs::TopOfBook>() const {
  return message_as_TopOfBook();
}

template <>
inline roq::fbs::MarketByPriceUpdate const *Event::message_as<roq::fbs::MarketByPriceUpdate>() const {
  return message_as_MarketByPriceUpdate();
}

template <>
inline roq::fbs::MarketByOrderUpdate const *Event::message_as<roq::fbs::MarketByOrderUpdate>() const {
  return message_as_MarketByOrderUpdate();
}

template <>
inline roq::fbs::TradeSummary const *Event::message_as<roq::fbs::TradeSummary>() const {
  return message_as_TradeSummary();
}

template <>
inline roq::fbs::StatisticsUpdate const *Event::message_as<roq::fbs::StatisticsUpdate>() const {
  return message_as_StatisticsUpdate();
}

template <>
inline roq::fbs::CreateOrder const *Event::message_as<roq::fbs::CreateOrder>() const {
  return message_as_CreateOrder();
}

template <>
inline roq::fbs::ModifyOrder const *Event::message_as<roq::fbs::ModifyOrder>() const {
  return message_as_ModifyOrder();
}

template <>
inline roq::fbs::CancelOrder const *Event::message_as<roq::fbs::CancelOrder>() const {
  return message_as_CancelOrder();
}

template <>
inline roq::fbs::CancelAllOrders const *Event::message_as<roq::fbs::CancelAllOrders>() const {
  return message_as_CancelAllOrders();
}

template <>
inline roq::fbs::OrderAck const *Event::message_as<roq::fbs::OrderAck>() const {
  return message_as_OrderAck();
}

template <>
inline roq::fbs::OrderUpdate const *Event::message_as<roq::fbs::OrderUpdate>() const {
  return message_as_OrderUpdate();
}

template <>
inline roq::fbs::TradeUpdate const *Event::message_as<roq::fbs::TradeUpdate>() const {
  return message_as_TradeUpdate();
}

template <>
inline roq::fbs::PositionUpdate const *Event::message_as<roq::fbs::PositionUpdate>() const {
  return message_as_PositionUpdate();
}

template <>
inline roq::fbs::FundsUpdate const *Event::message_as<roq::fbs::FundsUpdate>() const {
  return message_as_FundsUpdate();
}

template <>
inline roq::fbs::CustomMetrics const *Event::message_as<roq::fbs::CustomMetrics>() const {
  return message_as_CustomMetrics();
}

template <>
inline roq::fbs::CustomMetricsUpdate const *Event::message_as<roq::fbs::CustomMetricsUpdate>() const {
  return message_as_CustomMetricsUpdate();
}

struct EventBuilder {
  typedef Event Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_info(flatbuffers::Offset<roq::fbs::SourceInfo> source_info) {
    fbb_.AddOffset(Event::VT_SOURCE_INFO, source_info);
  }
  void add_message_type(roq::fbs::Message message_type) {
    fbb_.AddElement<uint8_t>(Event::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) { fbb_.AddOffset(Event::VT_MESSAGE, message); }
  explicit EventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Event> Finish() {
    auto const end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<roq::fbs::SourceInfo> source_info = 0,
    roq::fbs::Message message_type = roq::fbs::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_source_info(source_info);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, void const *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Handshake: {
      auto ptr = reinterpret_cast<roq::fbs::Handshake const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_HandshakeAck: {
      auto ptr = reinterpret_cast<roq::fbs::HandshakeAck const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Subscribe: {
      auto ptr = reinterpret_cast<roq::fbs::Subscribe const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_BatchBegin: {
      auto ptr = reinterpret_cast<roq::fbs::BatchBegin const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_BatchEnd: {
      auto ptr = reinterpret_cast<roq::fbs::BatchEnd const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DownloadBegin: {
      auto ptr = reinterpret_cast<roq::fbs::DownloadBegin const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DownloadEnd: {
      auto ptr = reinterpret_cast<roq::fbs::DownloadEnd const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GatewaySettings: {
      auto ptr = reinterpret_cast<roq::fbs::GatewaySettings const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StreamStatus: {
      auto ptr = reinterpret_cast<roq::fbs::StreamStatus const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ExternalLatency: {
      auto ptr = reinterpret_cast<roq::fbs::ExternalLatency const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RateLimitTrigger: {
      auto ptr = reinterpret_cast<roq::fbs::RateLimitTrigger const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GatewayStatus: {
      auto ptr = reinterpret_cast<roq::fbs::GatewayStatus const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReferenceData: {
      auto ptr = reinterpret_cast<roq::fbs::ReferenceData const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketStatus: {
      auto ptr = reinterpret_cast<roq::fbs::MarketStatus const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TopOfBook: {
      auto ptr = reinterpret_cast<roq::fbs::TopOfBook const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketByPriceUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::MarketByPriceUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketByOrderUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::MarketByOrderUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TradeSummary: {
      auto ptr = reinterpret_cast<roq::fbs::TradeSummary const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StatisticsUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::StatisticsUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CreateOrder: {
      auto ptr = reinterpret_cast<roq::fbs::CreateOrder const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ModifyOrder: {
      auto ptr = reinterpret_cast<roq::fbs::ModifyOrder const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CancelOrder: {
      auto ptr = reinterpret_cast<roq::fbs::CancelOrder const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CancelAllOrders: {
      auto ptr = reinterpret_cast<roq::fbs::CancelAllOrders const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_OrderAck: {
      auto ptr = reinterpret_cast<roq::fbs::OrderAck const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_OrderUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::OrderUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TradeUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::TradeUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_PositionUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::PositionUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FundsUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::FundsUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CustomMetrics: {
      auto ptr = reinterpret_cast<roq::fbs::CustomMetrics const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CustomMetricsUpdate: {
      auto ptr = reinterpret_cast<roq::fbs::CustomMetricsUpdate const *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyMessageVector(
    flatbuffers::Verifier &verifier,
    flatbuffers::Vector<flatbuffers::Offset<void>> const *values,
    flatbuffers::Vector<uint8_t> const *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(verifier, values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline roq::fbs::Event const *GetEvent(void const *buf) {
  return flatbuffers::GetRoot<roq::fbs::Event>(buf);
}

inline roq::fbs::Event const *GetSizePrefixedEvent(void const *buf) {
  return flatbuffers::GetSizePrefixedRoot<roq::fbs::Event>(buf);
}

inline bool VerifyEventBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<roq::fbs::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<roq::fbs::Event>(nullptr);
}

inline void FinishEventBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace roq

#endif  // FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
