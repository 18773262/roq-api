// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
#define FLATBUFFERS_GENERATED_API_ROQ_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace roq {
namespace fbs {

struct Fill;
struct FillBuilder;

struct Layer;
struct LayerBuilder;

struct MBOUpdate;
struct MBOUpdateBuilder;

struct MBPUpdate;
struct MBPUpdateBuilder;

struct Statistics;
struct StatisticsBuilder;

struct Trade;
struct TradeBuilder;

struct CancelAllOrders;
struct CancelAllOrdersBuilder;

struct CancelOrder;
struct CancelOrderBuilder;

struct CreateOrder;
struct CreateOrderBuilder;

struct DownloadBegin;
struct DownloadBeginBuilder;

struct DownloadEnd;
struct DownloadEndBuilder;

struct ExternalLatency;
struct ExternalLatencyBuilder;

struct FundsUpdate;
struct FundsUpdateBuilder;

struct GatewaySettings;
struct GatewaySettingsBuilder;

struct GatewayStatus;
struct GatewayStatusBuilder;

struct MarketByOrderUpdate;
struct MarketByOrderUpdateBuilder;

struct MarketByPriceUpdate;
struct MarketByPriceUpdateBuilder;

struct MarketStatus;
struct MarketStatusBuilder;

struct ModifyOrder;
struct ModifyOrderBuilder;

struct OrderAck;
struct OrderAckBuilder;

struct OrderUpdate;
struct OrderUpdateBuilder;

struct PositionUpdate;
struct PositionUpdateBuilder;

struct RateLimitUsage;
struct RateLimitUsageBuilder;

struct ReferenceData;
struct ReferenceDataBuilder;

struct StatisticsUpdate;
struct StatisticsUpdateBuilder;

struct StreamStatus;
struct StreamStatusBuilder;

struct TopOfBook;
struct TopOfBookBuilder;

struct TradeSummary;
struct TradeSummaryBuilder;

struct TradeUpdate;
struct TradeUpdateBuilder;

struct Handshake;
struct HandshakeBuilder;

struct HandshakeAck;
struct HandshakeAckBuilder;

struct Subscribe;
struct SubscribeBuilder;

struct BatchBegin;
struct BatchBeginBuilder;

struct BatchEnd;
struct BatchEndBuilder;

struct SourceInfo;
struct SourceInfoBuilder;

struct Event;
struct EventBuilder;

enum ConnectionStatus : uint8_t {
  ConnectionStatus_Undefined = 0,
  ConnectionStatus_Disconnected = 1,
  ConnectionStatus_Connecting = 2,
  ConnectionStatus_LoginSent = 3,
  ConnectionStatus_Downloading = 4,
  ConnectionStatus_Ready = 5,
  ConnectionStatus_LoggedOut = 6,
  ConnectionStatus_MIN = ConnectionStatus_Undefined,
  ConnectionStatus_MAX = ConnectionStatus_LoggedOut
};

inline const ConnectionStatus (&EnumValuesConnectionStatus())[7] {
  static const ConnectionStatus values[] = {
      ConnectionStatus_Undefined,
      ConnectionStatus_Disconnected,
      ConnectionStatus_Connecting,
      ConnectionStatus_LoginSent,
      ConnectionStatus_Downloading,
      ConnectionStatus_Ready,
      ConnectionStatus_LoggedOut};
  return values;
}

inline const char *const *EnumNamesConnectionStatus() {
  static const char *const names[8] = {
      "Undefined", "Disconnected", "Connecting", "LoginSent", "Downloading", "Ready", "LoggedOut", nullptr};
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  if (flatbuffers::IsOutRange(e, ConnectionStatus_Undefined, ConnectionStatus_LoggedOut))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionStatus()[index];
}

enum Error : uint8_t {
  Error_Undefined = 0,
  Error_Unknown = 1,
  Error_NotSupported = 2,
  Error_InvalidAccount = 3,
  Error_InvalidOrderId = 4,
  Error_InvalidExchange = 5,
  Error_InvalidSymbol = 6,
  Error_InvalidSide = 7,
  Error_InvalidPositionEffect = 8,
  Error_InvalidQuantity = 9,
  Error_InvalidMaxShowQuantity = 10,
  Error_InvalidOrderType = 11,
  Error_InvalidTimeInForce = 12,
  Error_InvalidExecutionInstruction = 13,
  Error_InvalidOrderTemplate = 14,
  Error_InvalidPrice = 15,
  Error_InvalidStopPrice = 16,
  Error_InvalidRoutingId = 17,
  Error_InvalidRequestVersion = 18,
  Error_InvalidRequestId = 19,
  Error_InvalidRequestType = 20,
  Error_InvalidRequestStatus = 21,
  Error_InvalidRequestArgs = 22,
  Error_UnknownExternalOrderId = 23,
  Error_NotAuthorized = 24,
  Error_GatewayNotReady = 25,
  Error_NetworkError = 26,
  Error_MIN = Error_Undefined,
  Error_MAX = Error_NetworkError
};

inline const Error (&EnumValuesError())[27] {
  static const Error values[] = {
      Error_Undefined,
      Error_Unknown,
      Error_NotSupported,
      Error_InvalidAccount,
      Error_InvalidOrderId,
      Error_InvalidExchange,
      Error_InvalidSymbol,
      Error_InvalidSide,
      Error_InvalidPositionEffect,
      Error_InvalidQuantity,
      Error_InvalidMaxShowQuantity,
      Error_InvalidOrderType,
      Error_InvalidTimeInForce,
      Error_InvalidExecutionInstruction,
      Error_InvalidOrderTemplate,
      Error_InvalidPrice,
      Error_InvalidStopPrice,
      Error_InvalidRoutingId,
      Error_InvalidRequestVersion,
      Error_InvalidRequestId,
      Error_InvalidRequestType,
      Error_InvalidRequestStatus,
      Error_InvalidRequestArgs,
      Error_UnknownExternalOrderId,
      Error_NotAuthorized,
      Error_GatewayNotReady,
      Error_NetworkError};
  return values;
}

inline const char *const *EnumNamesError() {
  static const char *const names[28] = {
      "Undefined",
      "Unknown",
      "NotSupported",
      "InvalidAccount",
      "InvalidOrderId",
      "InvalidExchange",
      "InvalidSymbol",
      "InvalidSide",
      "InvalidPositionEffect",
      "InvalidQuantity",
      "InvalidMaxShowQuantity",
      "InvalidOrderType",
      "InvalidTimeInForce",
      "InvalidExecutionInstruction",
      "InvalidOrderTemplate",
      "InvalidPrice",
      "InvalidStopPrice",
      "InvalidRoutingId",
      "InvalidRequestVersion",
      "InvalidRequestId",
      "InvalidRequestType",
      "InvalidRequestStatus",
      "InvalidRequestArgs",
      "UnknownExternalOrderId",
      "NotAuthorized",
      "GatewayNotReady",
      "NetworkError",
      nullptr};
  return names;
}

inline const char *EnumNameError(Error e) {
  if (flatbuffers::IsOutRange(e, Error_Undefined, Error_NetworkError))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesError()[index];
}

enum ExecutionInstruction : uint8_t {
  ExecutionInstruction_Undefined = 0,
  ExecutionInstruction_ParticipateDoNotInitiate = 1,
  ExecutionInstruction_CancelIfNotBest = 2,
  ExecutionInstruction_DoNotIncrease = 4,
  ExecutionInstruction_DoNotReduce = 8,
  ExecutionInstruction_MIN = ExecutionInstruction_Undefined,
  ExecutionInstruction_MAX = ExecutionInstruction_DoNotReduce
};

inline const ExecutionInstruction (&EnumValuesExecutionInstruction())[5] {
  static const ExecutionInstruction values[] = {
      ExecutionInstruction_Undefined,
      ExecutionInstruction_ParticipateDoNotInitiate,
      ExecutionInstruction_CancelIfNotBest,
      ExecutionInstruction_DoNotIncrease,
      ExecutionInstruction_DoNotReduce};
  return values;
}

inline const char *const *EnumNamesExecutionInstruction() {
  static const char *const names[10] = {
      "Undefined",
      "ParticipateDoNotInitiate",
      "CancelIfNotBest",
      "",
      "DoNotIncrease",
      "",
      "",
      "",
      "DoNotReduce",
      nullptr};
  return names;
}

inline const char *EnumNameExecutionInstruction(ExecutionInstruction e) {
  if (flatbuffers::IsOutRange(e, ExecutionInstruction_Undefined, ExecutionInstruction_DoNotReduce))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutionInstruction()[index];
}

enum Liquidity : uint8_t {
  Liquidity_Undefined = 0,
  Liquidity_Maker = 1,
  Liquidity_Taker = 2,
  Liquidity_MIN = Liquidity_Undefined,
  Liquidity_MAX = Liquidity_Taker
};

inline const Liquidity (&EnumValuesLiquidity())[3] {
  static const Liquidity values[] = {Liquidity_Undefined, Liquidity_Maker, Liquidity_Taker};
  return values;
}

inline const char *const *EnumNamesLiquidity() {
  static const char *const names[4] = {"Undefined", "Maker", "Taker", nullptr};
  return names;
}

inline const char *EnumNameLiquidity(Liquidity e) {
  if (flatbuffers::IsOutRange(e, Liquidity_Undefined, Liquidity_Taker))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLiquidity()[index];
}

enum OptionType : uint8_t {
  OptionType_Undefined = 0,
  OptionType_Call = 1,
  OptionType_Put = 2,
  OptionType_MIN = OptionType_Undefined,
  OptionType_MAX = OptionType_Put
};

inline const OptionType (&EnumValuesOptionType())[3] {
  static const OptionType values[] = {OptionType_Undefined, OptionType_Call, OptionType_Put};
  return values;
}

inline const char *const *EnumNamesOptionType() {
  static const char *const names[4] = {"Undefined", "Call", "Put", nullptr};
  return names;
}

inline const char *EnumNameOptionType(OptionType e) {
  if (flatbuffers::IsOutRange(e, OptionType_Undefined, OptionType_Put))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionType()[index];
}

enum OrderStatus : uint8_t {
  OrderStatus_Undefined = 0,
  OrderStatus_Sent = 1,
  OrderStatus_Accepted = 2,
  OrderStatus_Suspended = 3,
  OrderStatus_Working = 4,
  OrderStatus_Stopped = 5,
  OrderStatus_Completed = 6,
  OrderStatus_Expired = 7,
  OrderStatus_Canceled = 8,
  OrderStatus_Rejected = 9,
  OrderStatus_MIN = OrderStatus_Undefined,
  OrderStatus_MAX = OrderStatus_Rejected
};

inline const OrderStatus (&EnumValuesOrderStatus())[10] {
  static const OrderStatus values[] = {
      OrderStatus_Undefined,
      OrderStatus_Sent,
      OrderStatus_Accepted,
      OrderStatus_Suspended,
      OrderStatus_Working,
      OrderStatus_Stopped,
      OrderStatus_Completed,
      OrderStatus_Expired,
      OrderStatus_Canceled,
      OrderStatus_Rejected};
  return values;
}

inline const char *const *EnumNamesOrderStatus() {
  static const char *const names[11] = {
      "Undefined",
      "Sent",
      "Accepted",
      "Suspended",
      "Working",
      "Stopped",
      "Completed",
      "Expired",
      "Canceled",
      "Rejected",
      nullptr};
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  if (flatbuffers::IsOutRange(e, OrderStatus_Undefined, OrderStatus_Rejected))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderStatus()[index];
}

enum OrderType : uint8_t {
  OrderType_Undefined = 0,
  OrderType_Market = 1,
  OrderType_Limit = 2,
  OrderType_MIN = OrderType_Undefined,
  OrderType_MAX = OrderType_Limit
};

inline const OrderType (&EnumValuesOrderType())[3] {
  static const OrderType values[] = {OrderType_Undefined, OrderType_Market, OrderType_Limit};
  return values;
}

inline const char *const *EnumNamesOrderType() {
  static const char *const names[4] = {"Undefined", "Market", "Limit", nullptr};
  return names;
}

inline const char *EnumNameOrderType(OrderType e) {
  if (flatbuffers::IsOutRange(e, OrderType_Undefined, OrderType_Limit))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderType()[index];
}

enum OrderUpdateAction : uint8_t {
  OrderUpdateAction_Undefined = 0,
  OrderUpdateAction_New = 1,
  OrderUpdateAction_Modify = 2,
  OrderUpdateAction_Remove = 3,
  OrderUpdateAction_MIN = OrderUpdateAction_Undefined,
  OrderUpdateAction_MAX = OrderUpdateAction_Remove
};

inline const OrderUpdateAction (&EnumValuesOrderUpdateAction())[4] {
  static const OrderUpdateAction values[] = {
      OrderUpdateAction_Undefined, OrderUpdateAction_New, OrderUpdateAction_Modify, OrderUpdateAction_Remove};
  return values;
}

inline const char *const *EnumNamesOrderUpdateAction() {
  static const char *const names[5] = {"Undefined", "New", "Modify", "Remove", nullptr};
  return names;
}

inline const char *EnumNameOrderUpdateAction(OrderUpdateAction e) {
  if (flatbuffers::IsOutRange(e, OrderUpdateAction_Undefined, OrderUpdateAction_Remove))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderUpdateAction()[index];
}

enum Origin : uint8_t {
  Origin_Undefined = 0,
  Origin_Client = 1,
  Origin_Gateway = 2,
  Origin_Broker = 3,
  Origin_Exchange = 4,
  Origin_MIN = Origin_Undefined,
  Origin_MAX = Origin_Exchange
};

inline const Origin (&EnumValuesOrigin())[5] {
  static const Origin values[] = {Origin_Undefined, Origin_Client, Origin_Gateway, Origin_Broker, Origin_Exchange};
  return values;
}

inline const char *const *EnumNamesOrigin() {
  static const char *const names[6] = {"Undefined", "Client", "Gateway", "Broker", "Exchange", nullptr};
  return names;
}

inline const char *EnumNameOrigin(Origin e) {
  if (flatbuffers::IsOutRange(e, Origin_Undefined, Origin_Exchange))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrigin()[index];
}

enum PositionEffect : uint8_t {
  PositionEffect_Undefined = 0,
  PositionEffect_Open = 1,
  PositionEffect_Close = 2,
  PositionEffect_MIN = PositionEffect_Undefined,
  PositionEffect_MAX = PositionEffect_Close
};

inline const PositionEffect (&EnumValuesPositionEffect())[3] {
  static const PositionEffect values[] = {PositionEffect_Undefined, PositionEffect_Open, PositionEffect_Close};
  return values;
}

inline const char *const *EnumNamesPositionEffect() {
  static const char *const names[4] = {"Undefined", "Open", "Close", nullptr};
  return names;
}

inline const char *EnumNamePositionEffect(PositionEffect e) {
  if (flatbuffers::IsOutRange(e, PositionEffect_Undefined, PositionEffect_Close))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPositionEffect()[index];
}

enum RequestStatus : uint8_t {
  RequestStatus_Undefined = 0,
  RequestStatus_Forwarded = 1,
  RequestStatus_Accepted = 2,
  RequestStatus_Rejected = 3,
  RequestStatus_Timeout = 4,
  RequestStatus_MIN = RequestStatus_Undefined,
  RequestStatus_MAX = RequestStatus_Timeout
};

inline const RequestStatus (&EnumValuesRequestStatus())[5] {
  static const RequestStatus values[] = {
      RequestStatus_Undefined,
      RequestStatus_Forwarded,
      RequestStatus_Accepted,
      RequestStatus_Rejected,
      RequestStatus_Timeout};
  return values;
}

inline const char *const *EnumNamesRequestStatus() {
  static const char *const names[6] = {"Undefined", "Forwarded", "Accepted", "Rejected", "Timeout", nullptr};
  return names;
}

inline const char *EnumNameRequestStatus(RequestStatus e) {
  if (flatbuffers::IsOutRange(e, RequestStatus_Undefined, RequestStatus_Timeout))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestStatus()[index];
}

enum RequestType : uint8_t {
  RequestType_Undefined = 0,
  RequestType_CreateOrder = 1,
  RequestType_ModifyOrder = 2,
  RequestType_CancelOrder = 3,
  RequestType_MIN = RequestType_Undefined,
  RequestType_MAX = RequestType_CancelOrder
};

inline const RequestType (&EnumValuesRequestType())[4] {
  static const RequestType values[] = {
      RequestType_Undefined, RequestType_CreateOrder, RequestType_ModifyOrder, RequestType_CancelOrder};
  return values;
}

inline const char *const *EnumNamesRequestType() {
  static const char *const names[5] = {"Undefined", "CreateOrder", "ModifyOrder", "CancelOrder", nullptr};
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (flatbuffers::IsOutRange(e, RequestType_Undefined, RequestType_CancelOrder))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

enum SecurityType : uint8_t {
  SecurityType_Undefined = 0,
  SecurityType_Spot = 1,
  SecurityType_Futures = 2,
  SecurityType_Option = 3,
  SecurityType_MIN = SecurityType_Undefined,
  SecurityType_MAX = SecurityType_Option
};

inline const SecurityType (&EnumValuesSecurityType())[4] {
  static const SecurityType values[] = {
      SecurityType_Undefined, SecurityType_Spot, SecurityType_Futures, SecurityType_Option};
  return values;
}

inline const char *const *EnumNamesSecurityType() {
  static const char *const names[5] = {"Undefined", "Spot", "Futures", "Option", nullptr};
  return names;
}

inline const char *EnumNameSecurityType(SecurityType e) {
  if (flatbuffers::IsOutRange(e, SecurityType_Undefined, SecurityType_Option))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSecurityType()[index];
}

enum Side : uint8_t {
  Side_Undefined = 0,
  Side_Buy = 1,
  Side_Sell = 2,
  Side_MIN = Side_Undefined,
  Side_MAX = Side_Sell
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {Side_Undefined, Side_Buy, Side_Sell};
  return values;
}

inline const char *const *EnumNamesSide() {
  static const char *const names[4] = {"Undefined", "Buy", "Sell", nullptr};
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (flatbuffers::IsOutRange(e, Side_Undefined, Side_Sell))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum StatisticsType : uint8_t {
  StatisticsType_Undefined = 0,
  StatisticsType_OpenPrice = 1,
  StatisticsType_SettlementPrice = 2,
  StatisticsType_ClosePrice = 3,
  StatisticsType_OpenInterest = 4,
  StatisticsType_PreOpenInterest = 5,
  StatisticsType_PreSettlementPrice = 6,
  StatisticsType_PreClosePrice = 7,
  StatisticsType_HighestTradedPrice = 8,
  StatisticsType_LowestTradedPrice = 9,
  StatisticsType_UpperLimitPrice = 10,
  StatisticsType_LowerLimitPrice = 11,
  StatisticsType_IndexValue = 12,
  StatisticsType_MarginRate = 13,
  StatisticsType_FundingRate = 14,
  StatisticsType_DailyFundingRate = 15,
  StatisticsType_MIN = StatisticsType_Undefined,
  StatisticsType_MAX = StatisticsType_DailyFundingRate
};

inline const StatisticsType (&EnumValuesStatisticsType())[16] {
  static const StatisticsType values[] = {
      StatisticsType_Undefined,
      StatisticsType_OpenPrice,
      StatisticsType_SettlementPrice,
      StatisticsType_ClosePrice,
      StatisticsType_OpenInterest,
      StatisticsType_PreOpenInterest,
      StatisticsType_PreSettlementPrice,
      StatisticsType_PreClosePrice,
      StatisticsType_HighestTradedPrice,
      StatisticsType_LowestTradedPrice,
      StatisticsType_UpperLimitPrice,
      StatisticsType_LowerLimitPrice,
      StatisticsType_IndexValue,
      StatisticsType_MarginRate,
      StatisticsType_FundingRate,
      StatisticsType_DailyFundingRate};
  return values;
}

inline const char *const *EnumNamesStatisticsType() {
  static const char *const names[17] = {
      "Undefined",
      "OpenPrice",
      "SettlementPrice",
      "ClosePrice",
      "OpenInterest",
      "PreOpenInterest",
      "PreSettlementPrice",
      "PreClosePrice",
      "HighestTradedPrice",
      "LowestTradedPrice",
      "UpperLimitPrice",
      "LowerLimitPrice",
      "IndexValue",
      "MarginRate",
      "FundingRate",
      "DailyFundingRate",
      nullptr};
  return names;
}

inline const char *EnumNameStatisticsType(StatisticsType e) {
  if (flatbuffers::IsOutRange(e, StatisticsType_Undefined, StatisticsType_DailyFundingRate))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatisticsType()[index];
}

enum StreamType : uint8_t {
  StreamType_Undefined = 0,
  StreamType_FIX = 1,
  StreamType_WebSocket = 2,
  StreamType_REST = 3,
  StreamType_MIN = StreamType_Undefined,
  StreamType_MAX = StreamType_REST
};

inline const StreamType (&EnumValuesStreamType())[4] {
  static const StreamType values[] = {StreamType_Undefined, StreamType_FIX, StreamType_WebSocket, StreamType_REST};
  return values;
}

inline const char *const *EnumNamesStreamType() {
  static const char *const names[5] = {"Undefined", "FIX", "WebSocket", "REST", nullptr};
  return names;
}

inline const char *EnumNameStreamType(StreamType e) {
  if (flatbuffers::IsOutRange(e, StreamType_Undefined, StreamType_REST))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStreamType()[index];
}

enum SupportType : uint32_t {
  SupportType_Undefined = 0,
  SupportType_ReferenceData = 1,
  SupportType_MarketStatus = 2,
  SupportType_TopOfBook = 4,
  SupportType_MarketByPrice = 8,
  SupportType_MarketByOrder = 16,
  SupportType_TradeSummary = 32,
  SupportType_Statistics = 64,
  SupportType_CreateOrder = 65536,
  SupportType_ModifyOrder = 131072,
  SupportType_CancelOrder = 262144,
  SupportType_OrderAck = 524288,
  SupportType_Order = 1048576,
  SupportType_Trade = 2097152,
  SupportType_Position = 4194304,
  SupportType_OrderState = 8388608,
  SupportType_Funds = 268435456,
  SupportType_MIN = SupportType_Undefined,
  SupportType_MAX = SupportType_Funds
};

inline const SupportType (&EnumValuesSupportType())[17] {
  static const SupportType values[] = {
      SupportType_Undefined,
      SupportType_ReferenceData,
      SupportType_MarketStatus,
      SupportType_TopOfBook,
      SupportType_MarketByPrice,
      SupportType_MarketByOrder,
      SupportType_TradeSummary,
      SupportType_Statistics,
      SupportType_CreateOrder,
      SupportType_ModifyOrder,
      SupportType_CancelOrder,
      SupportType_OrderAck,
      SupportType_Order,
      SupportType_Trade,
      SupportType_Position,
      SupportType_OrderState,
      SupportType_Funds};
  return values;
}

inline const char *EnumNameSupportType(SupportType e) {
  switch (e) {
    case SupportType_Undefined:
      return "Undefined";
    case SupportType_ReferenceData:
      return "ReferenceData";
    case SupportType_MarketStatus:
      return "MarketStatus";
    case SupportType_TopOfBook:
      return "TopOfBook";
    case SupportType_MarketByPrice:
      return "MarketByPrice";
    case SupportType_MarketByOrder:
      return "MarketByOrder";
    case SupportType_TradeSummary:
      return "TradeSummary";
    case SupportType_Statistics:
      return "Statistics";
    case SupportType_CreateOrder:
      return "CreateOrder";
    case SupportType_ModifyOrder:
      return "ModifyOrder";
    case SupportType_CancelOrder:
      return "CancelOrder";
    case SupportType_OrderAck:
      return "OrderAck";
    case SupportType_Order:
      return "Order";
    case SupportType_Trade:
      return "Trade";
    case SupportType_Position:
      return "Position";
    case SupportType_OrderState:
      return "OrderState";
    case SupportType_Funds:
      return "Funds";
    default:
      return "";
  }
}

enum TimeInForce : uint8_t {
  TimeInForce_Undefined = 0,
  TimeInForce_GFD = 1,
  TimeInForce_GTC = 2,
  TimeInForce_OPG = 3,
  TimeInForce_IOC = 4,
  TimeInForce_FOK = 5,
  TimeInForce_GTX = 6,
  TimeInForce_GTD = 7,
  TimeInForce_AT_THE_CLOSE = 8,
  TimeInForce_GOOD_THROUGH_CROSSING = 9,
  TimeInForce_AT_CROSSING = 10,
  TimeInForce_GOOD_FOR_TIME = 11,
  TimeInForce_GFA = 12,
  TimeInForce_GFM = 13,
  TimeInForce_MIN = TimeInForce_Undefined,
  TimeInForce_MAX = TimeInForce_GFM
};

inline const TimeInForce (&EnumValuesTimeInForce())[14] {
  static const TimeInForce values[] = {
      TimeInForce_Undefined,
      TimeInForce_GFD,
      TimeInForce_GTC,
      TimeInForce_OPG,
      TimeInForce_IOC,
      TimeInForce_FOK,
      TimeInForce_GTX,
      TimeInForce_GTD,
      TimeInForce_AT_THE_CLOSE,
      TimeInForce_GOOD_THROUGH_CROSSING,
      TimeInForce_AT_CROSSING,
      TimeInForce_GOOD_FOR_TIME,
      TimeInForce_GFA,
      TimeInForce_GFM};
  return values;
}

inline const char *const *EnumNamesTimeInForce() {
  static const char *const names[15] = {
      "Undefined",
      "GFD",
      "GTC",
      "OPG",
      "IOC",
      "FOK",
      "GTX",
      "GTD",
      "AT_THE_CLOSE",
      "GOOD_THROUGH_CROSSING",
      "AT_CROSSING",
      "GOOD_FOR_TIME",
      "GFA",
      "GFM",
      nullptr};
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  if (flatbuffers::IsOutRange(e, TimeInForce_Undefined, TimeInForce_GFM))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeInForce()[index];
}

enum TradingStatus : uint8_t {
  TradingStatus_Undefined = 0,
  TradingStatus_StartOfDay = 1,
  TradingStatus_PreOpen = 2,
  TradingStatus_PreOpenNoCancel = 3,
  TradingStatus_PreOpenFreeze = 4,
  TradingStatus_Open = 5,
  TradingStatus_FastMarket = 6,
  TradingStatus_Halt = 7,
  TradingStatus_CloseNotFinal = 8,
  TradingStatus_PreClose = 9,
  TradingStatus_PreCloseNoCancel = 10,
  TradingStatus_PreCloseFreeze = 11,
  TradingStatus_Close = 12,
  TradingStatus_PostClose = 13,
  TradingStatus_EndOfDay = 14,
  TradingStatus_MIN = TradingStatus_Undefined,
  TradingStatus_MAX = TradingStatus_EndOfDay
};

inline const TradingStatus (&EnumValuesTradingStatus())[15] {
  static const TradingStatus values[] = {
      TradingStatus_Undefined,
      TradingStatus_StartOfDay,
      TradingStatus_PreOpen,
      TradingStatus_PreOpenNoCancel,
      TradingStatus_PreOpenFreeze,
      TradingStatus_Open,
      TradingStatus_FastMarket,
      TradingStatus_Halt,
      TradingStatus_CloseNotFinal,
      TradingStatus_PreClose,
      TradingStatus_PreCloseNoCancel,
      TradingStatus_PreCloseFreeze,
      TradingStatus_Close,
      TradingStatus_PostClose,
      TradingStatus_EndOfDay};
  return values;
}

inline const char *const *EnumNamesTradingStatus() {
  static const char *const names[16] = {
      "Undefined",
      "StartOfDay",
      "PreOpen",
      "PreOpenNoCancel",
      "PreOpenFreeze",
      "Open",
      "FastMarket",
      "Halt",
      "CloseNotFinal",
      "PreClose",
      "PreCloseNoCancel",
      "PreCloseFreeze",
      "Close",
      "PostClose",
      "EndOfDay",
      nullptr};
  return names;
}

inline const char *EnumNameTradingStatus(TradingStatus e) {
  if (flatbuffers::IsOutRange(e, TradingStatus_Undefined, TradingStatus_EndOfDay))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTradingStatus()[index];
}

enum Priority : uint32_t {
  Priority_Undefined = 0,
  Priority_Primary = 1,
  Priority_MIN = Priority_Undefined,
  Priority_MAX = Priority_Primary
};

inline const Priority (&EnumValuesPriority())[2] {
  static const Priority values[] = {Priority_Undefined, Priority_Primary};
  return values;
}

inline const char *const *EnumNamesPriority() {
  static const char *const names[3] = {"Undefined", "Primary", nullptr};
  return names;
}

inline const char *EnumNamePriority(Priority e) {
  if (flatbuffers::IsOutRange(e, Priority_Undefined, Priority_Primary))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPriority()[index];
}

enum Message : uint8_t {
  Message_NONE = 0,
  Message_Handshake = 1,
  Message_HandshakeAck = 2,
  Message_Subscribe = 3,
  Message_BatchBegin = 4,
  Message_BatchEnd = 5,
  Message_DownloadBegin = 6,
  Message_DownloadEnd = 7,
  Message_GatewaySettings = 8,
  Message_StreamStatus = 9,
  Message_ExternalLatency = 10,
  Message_RateLimitUsage = 11,
  Message_GatewayStatus = 12,
  Message_ReferenceData = 13,
  Message_MarketStatus = 14,
  Message_TopOfBook = 15,
  Message_MarketByPriceUpdate = 16,
  Message_MarketByOrderUpdate = 17,
  Message_TradeSummary = 18,
  Message_StatisticsUpdate = 19,
  Message_CreateOrder = 20,
  Message_ModifyOrder = 21,
  Message_CancelOrder = 22,
  Message_CancelAllOrders = 23,
  Message_OrderAck = 24,
  Message_OrderUpdate = 25,
  Message_TradeUpdate = 26,
  Message_PositionUpdate = 27,
  Message_FundsUpdate = 28,
  Message_MIN = Message_NONE,
  Message_MAX = Message_FundsUpdate
};

inline const Message (&EnumValuesMessage())[29] {
  static const Message values[] = {Message_NONE,           Message_Handshake,           Message_HandshakeAck,
                                   Message_Subscribe,      Message_BatchBegin,          Message_BatchEnd,
                                   Message_DownloadBegin,  Message_DownloadEnd,         Message_GatewaySettings,
                                   Message_StreamStatus,   Message_ExternalLatency,     Message_RateLimitUsage,
                                   Message_GatewayStatus,  Message_ReferenceData,       Message_MarketStatus,
                                   Message_TopOfBook,      Message_MarketByPriceUpdate, Message_MarketByOrderUpdate,
                                   Message_TradeSummary,   Message_StatisticsUpdate,    Message_CreateOrder,
                                   Message_ModifyOrder,    Message_CancelOrder,         Message_CancelAllOrders,
                                   Message_OrderAck,       Message_OrderUpdate,         Message_TradeUpdate,
                                   Message_PositionUpdate, Message_FundsUpdate};
  return values;
}

inline const char *const *EnumNamesMessage() {
  static const char *const names[30] = {"NONE",           "Handshake",           "HandshakeAck",
                                        "Subscribe",      "BatchBegin",          "BatchEnd",
                                        "DownloadBegin",  "DownloadEnd",         "GatewaySettings",
                                        "StreamStatus",   "ExternalLatency",     "RateLimitUsage",
                                        "GatewayStatus",  "ReferenceData",       "MarketStatus",
                                        "TopOfBook",      "MarketByPriceUpdate", "MarketByOrderUpdate",
                                        "TradeSummary",   "StatisticsUpdate",    "CreateOrder",
                                        "ModifyOrder",    "CancelOrder",         "CancelAllOrders",
                                        "OrderAck",       "OrderUpdate",         "TradeUpdate",
                                        "PositionUpdate", "FundsUpdate",         nullptr};
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_FundsUpdate))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template <typename T>
struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template <>
struct MessageTraits<roq::fbs::Handshake> {
  static const Message enum_value = Message_Handshake;
};

template <>
struct MessageTraits<roq::fbs::HandshakeAck> {
  static const Message enum_value = Message_HandshakeAck;
};

template <>
struct MessageTraits<roq::fbs::Subscribe> {
  static const Message enum_value = Message_Subscribe;
};

template <>
struct MessageTraits<roq::fbs::BatchBegin> {
  static const Message enum_value = Message_BatchBegin;
};

template <>
struct MessageTraits<roq::fbs::BatchEnd> {
  static const Message enum_value = Message_BatchEnd;
};

template <>
struct MessageTraits<roq::fbs::DownloadBegin> {
  static const Message enum_value = Message_DownloadBegin;
};

template <>
struct MessageTraits<roq::fbs::DownloadEnd> {
  static const Message enum_value = Message_DownloadEnd;
};

template <>
struct MessageTraits<roq::fbs::GatewaySettings> {
  static const Message enum_value = Message_GatewaySettings;
};

template <>
struct MessageTraits<roq::fbs::StreamStatus> {
  static const Message enum_value = Message_StreamStatus;
};

template <>
struct MessageTraits<roq::fbs::ExternalLatency> {
  static const Message enum_value = Message_ExternalLatency;
};

template <>
struct MessageTraits<roq::fbs::RateLimitUsage> {
  static const Message enum_value = Message_RateLimitUsage;
};

template <>
struct MessageTraits<roq::fbs::GatewayStatus> {
  static const Message enum_value = Message_GatewayStatus;
};

template <>
struct MessageTraits<roq::fbs::ReferenceData> {
  static const Message enum_value = Message_ReferenceData;
};

template <>
struct MessageTraits<roq::fbs::MarketStatus> {
  static const Message enum_value = Message_MarketStatus;
};

template <>
struct MessageTraits<roq::fbs::TopOfBook> {
  static const Message enum_value = Message_TopOfBook;
};

template <>
struct MessageTraits<roq::fbs::MarketByPriceUpdate> {
  static const Message enum_value = Message_MarketByPriceUpdate;
};

template <>
struct MessageTraits<roq::fbs::MarketByOrderUpdate> {
  static const Message enum_value = Message_MarketByOrderUpdate;
};

template <>
struct MessageTraits<roq::fbs::TradeSummary> {
  static const Message enum_value = Message_TradeSummary;
};

template <>
struct MessageTraits<roq::fbs::StatisticsUpdate> {
  static const Message enum_value = Message_StatisticsUpdate;
};

template <>
struct MessageTraits<roq::fbs::CreateOrder> {
  static const Message enum_value = Message_CreateOrder;
};

template <>
struct MessageTraits<roq::fbs::ModifyOrder> {
  static const Message enum_value = Message_ModifyOrder;
};

template <>
struct MessageTraits<roq::fbs::CancelOrder> {
  static const Message enum_value = Message_CancelOrder;
};

template <>
struct MessageTraits<roq::fbs::CancelAllOrders> {
  static const Message enum_value = Message_CancelAllOrders;
};

template <>
struct MessageTraits<roq::fbs::OrderAck> {
  static const Message enum_value = Message_OrderAck;
};

template <>
struct MessageTraits<roq::fbs::OrderUpdate> {
  static const Message enum_value = Message_OrderUpdate;
};

template <>
struct MessageTraits<roq::fbs::TradeUpdate> {
  static const Message enum_value = Message_TradeUpdate;
};

template <>
struct MessageTraits<roq::fbs::PositionUpdate> {
  static const Message enum_value = Message_PositionUpdate;
};

template <>
struct MessageTraits<roq::fbs::FundsUpdate> {
  static const Message enum_value = Message_FundsUpdate;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUANTITY = 4,
    VT_PRICE = 6,
    VT_TRADE_ID = 8,
    VT_GATEWAY_TRADE_ID = 10,
    VT_EXTERNAL_TRADE_ID = 12
  };
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  double price() const { return GetField<double>(VT_PRICE, 0.0); }
  uint32_t trade_id() const { return GetField<uint32_t>(VT_TRADE_ID, 0); }
  uint32_t gateway_trade_id() const { return GetField<uint32_t>(VT_GATEWAY_TRADE_ID, 0); }
  const flatbuffers::String *external_trade_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_TRADE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_QUANTITY) &&
           VerifyField<double>(verifier, VT_PRICE) && VerifyField<uint32_t>(verifier, VT_TRADE_ID) &&
           VerifyField<uint32_t>(verifier, VT_GATEWAY_TRADE_ID) && VerifyOffset(verifier, VT_EXTERNAL_TRADE_ID) &&
           verifier.VerifyString(external_trade_id()) && verifier.EndTable();
  }
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quantity(double quantity) { fbb_.AddElement<double>(Fill::VT_QUANTITY, quantity, 0.0); }
  void add_price(double price) { fbb_.AddElement<double>(Fill::VT_PRICE, price, 0.0); }
  void add_trade_id(uint32_t trade_id) { fbb_.AddElement<uint32_t>(Fill::VT_TRADE_ID, trade_id, 0); }
  void add_gateway_trade_id(uint32_t gateway_trade_id) {
    fbb_.AddElement<uint32_t>(Fill::VT_GATEWAY_TRADE_ID, gateway_trade_id, 0);
  }
  void add_external_trade_id(flatbuffers::Offset<flatbuffers::String> external_trade_id) {
    fbb_.AddOffset(Fill::VT_EXTERNAL_TRADE_ID, external_trade_id);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    double quantity = 0.0,
    double price = 0.0,
    uint32_t trade_id = 0,
    uint32_t gateway_trade_id = 0,
    flatbuffers::Offset<flatbuffers::String> external_trade_id = 0) {
  FillBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_external_trade_id(external_trade_id);
  builder_.add_gateway_trade_id(gateway_trade_id);
  builder_.add_trade_id(trade_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double quantity = 0.0,
    double price = 0.0,
    uint32_t trade_id = 0,
    uint32_t gateway_trade_id = 0,
    const char *external_trade_id = nullptr) {
  auto external_trade_id__ = external_trade_id ? _fbb.CreateString(external_trade_id) : 0;
  return roq::fbs::CreateFill(_fbb, quantity, price, trade_id, gateway_trade_id, external_trade_id__);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BID_PRICE = 4,
    VT_BID_QUANTITY = 6,
    VT_ASK_PRICE = 8,
    VT_ASK_QUANTITY = 10
  };
  double bid_price() const { return GetField<double>(VT_BID_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double bid_quantity() const { return GetField<double>(VT_BID_QUANTITY, 0.0); }
  double ask_price() const { return GetField<double>(VT_ASK_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double ask_quantity() const { return GetField<double>(VT_ASK_QUANTITY, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_BID_PRICE) &&
           VerifyField<double>(verifier, VT_BID_QUANTITY) && VerifyField<double>(verifier, VT_ASK_PRICE) &&
           VerifyField<double>(verifier, VT_ASK_QUANTITY) && verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bid_price(double bid_price) {
    fbb_.AddElement<double>(Layer::VT_BID_PRICE, bid_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_bid_quantity(double bid_quantity) { fbb_.AddElement<double>(Layer::VT_BID_QUANTITY, bid_quantity, 0.0); }
  void add_ask_price(double ask_price) {
    fbb_.AddElement<double>(Layer::VT_ASK_PRICE, ask_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_ask_quantity(double ask_quantity) { fbb_.AddElement<double>(Layer::VT_ASK_QUANTITY, ask_quantity, 0.0); }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    double bid_price = std::numeric_limits<double>::quiet_NaN(),
    double bid_quantity = 0.0,
    double ask_price = std::numeric_limits<double>::quiet_NaN(),
    double ask_quantity = 0.0) {
  LayerBuilder builder_(_fbb);
  builder_.add_ask_quantity(ask_quantity);
  builder_.add_ask_price(ask_price);
  builder_.add_bid_quantity(bid_quantity);
  builder_.add_bid_price(bid_price);
  return builder_.Finish();
}

struct MBOUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBOUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRICE = 4,
    VT_REMAINING_QUANTITY = 6,
    VT_ACTION = 8,
    VT_PRIORITY = 10,
    VT_ORDER_ID = 12
  };
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double remaining_quantity() const { return GetField<double>(VT_REMAINING_QUANTITY, 0.0); }
  roq::fbs::OrderUpdateAction action() const {
    return static_cast<roq::fbs::OrderUpdateAction>(GetField<uint8_t>(VT_ACTION, 0));
  }
  uint32_t priority() const { return GetField<uint32_t>(VT_PRIORITY, 0); }
  const flatbuffers::String *order_id() const { return GetPointer<const flatbuffers::String *>(VT_ORDER_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_PRICE) &&
           VerifyField<double>(verifier, VT_REMAINING_QUANTITY) && VerifyField<uint8_t>(verifier, VT_ACTION) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY) && VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) && verifier.EndTable();
  }
};

struct MBOUpdateBuilder {
  typedef MBOUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBOUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_remaining_quantity(double remaining_quantity) {
    fbb_.AddElement<double>(MBOUpdate::VT_REMAINING_QUANTITY, remaining_quantity, 0.0);
  }
  void add_action(roq::fbs::OrderUpdateAction action) {
    fbb_.AddElement<uint8_t>(MBOUpdate::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_priority(uint32_t priority) { fbb_.AddElement<uint32_t>(MBOUpdate::VT_PRIORITY, priority, 0); }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(MBOUpdate::VT_ORDER_ID, order_id);
  }
  explicit MBOUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MBOUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBOUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = 0.0,
    roq::fbs::OrderUpdateAction action = roq::fbs::OrderUpdateAction_Undefined,
    uint32_t priority = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0) {
  MBOUpdateBuilder builder_(_fbb);
  builder_.add_remaining_quantity(remaining_quantity);
  builder_.add_price(price);
  builder_.add_order_id(order_id);
  builder_.add_priority(priority);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<MBOUpdate> CreateMBOUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = 0.0,
    roq::fbs::OrderUpdateAction action = roq::fbs::OrderUpdateAction_Undefined,
    uint32_t priority = 0,
    const char *order_id = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return roq::fbs::CreateMBOUpdate(_fbb, price, remaining_quantity, action, priority, order_id__);
}

struct MBPUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MBPUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PRICE = 4, VT_QUANTITY = 6 };
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_PRICE) &&
           VerifyField<double>(verifier, VT_QUANTITY) && verifier.EndTable();
  }
};

struct MBPUpdateBuilder {
  typedef MBPUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_price(double price) {
    fbb_.AddElement<double>(MBPUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) { fbb_.AddElement<double>(MBPUpdate::VT_QUANTITY, quantity, 0.0); }
  explicit MBPUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MBPUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MBPUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MBPUpdate> CreateMBPUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0) {
  MBPUpdateBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  return builder_.Finish();
}

struct Statistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6,
    VT_BEGIN_TIME_UTC = 8,
    VT_END_TIME_UTC = 10
  };
  roq::fbs::StatisticsType type() const { return static_cast<roq::fbs::StatisticsType>(GetField<uint8_t>(VT_TYPE, 0)); }
  double value() const { return GetField<double>(VT_VALUE, std::numeric_limits<double>::quiet_NaN()); }
  int64_t begin_time_utc() const { return GetField<int64_t>(VT_BEGIN_TIME_UTC, 0); }
  int64_t end_time_utc() const { return GetField<int64_t>(VT_END_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<double>(verifier, VT_VALUE) && VerifyField<int64_t>(verifier, VT_BEGIN_TIME_UTC) &&
           VerifyField<int64_t>(verifier, VT_END_TIME_UTC) && verifier.EndTable();
  }
};

struct StatisticsBuilder {
  typedef Statistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(roq::fbs::StatisticsType type) {
    fbb_.AddElement<uint8_t>(Statistics::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Statistics::VT_VALUE, value, std::numeric_limits<double>::quiet_NaN());
  }
  void add_begin_time_utc(int64_t begin_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_BEGIN_TIME_UTC, begin_time_utc, 0);
  }
  void add_end_time_utc(int64_t end_time_utc) {
    fbb_.AddElement<int64_t>(Statistics::VT_END_TIME_UTC, end_time_utc, 0);
  }
  explicit StatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Statistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Statistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Statistics> CreateStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::StatisticsType type = roq::fbs::StatisticsType_Undefined,
    double value = std::numeric_limits<double>::quiet_NaN(),
    int64_t begin_time_utc = 0,
    int64_t end_time_utc = 0) {
  StatisticsBuilder builder_(_fbb);
  builder_.add_end_time_utc(end_time_utc);
  builder_.add_begin_time_utc(begin_time_utc);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIDE = 4,
    VT_PRICE = 6,
    VT_QUANTITY = 8,
    VT_TRADE_ID = 10
  };
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double quantity() const { return GetField<double>(VT_QUANTITY, 0.0); }
  const flatbuffers::String *trade_id() const { return GetPointer<const flatbuffers::String *>(VT_TRADE_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_SIDE) &&
           VerifyField<double>(verifier, VT_PRICE) && VerifyField<double>(verifier, VT_QUANTITY) &&
           VerifyOffset(verifier, VT_TRADE_ID) && verifier.VerifyString(trade_id()) && verifier.EndTable();
  }
};

struct TradeBuilder {
  typedef Trade Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(Trade::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_price(double price) {
    fbb_.AddElement<double>(Trade::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_quantity(double quantity) { fbb_.AddElement<double>(Trade::VT_QUANTITY, quantity, 0.0); }
  void add_trade_id(flatbuffers::Offset<flatbuffers::String> trade_id) { fbb_.AddOffset(Trade::VT_TRADE_ID, trade_id); }
  explicit TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    flatbuffers::Offset<flatbuffers::String> trade_id = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_trade_id(trade_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trade> CreateTradeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double quantity = 0.0,
    const char *trade_id = nullptr) {
  auto trade_id__ = trade_id ? _fbb.CreateString(trade_id) : 0;
  return roq::fbs::CreateTrade(_fbb, side, price, quantity, trade_id__);
}

struct CancelAllOrders FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelAllOrdersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4 };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct CancelAllOrdersBuilder {
  typedef CancelAllOrders Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelAllOrders::VT_ACCOUNT, account);
  }
  explicit CancelAllOrdersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CancelAllOrders> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelAllOrders>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrders(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> account = 0) {
  CancelAllOrdersBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelAllOrders> CreateCancelAllOrdersDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateCancelAllOrders(_fbb, account__);
}

struct CancelOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CancelOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_ROUTING_ID = 8,
    VT_VERSION = 10,
    VT_CONDITIONAL_ON_VERSION = 12
  };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  uint8_t version() const { return GetField<uint8_t>(VT_VERSION, 0); }
  uint8_t conditional_on_version() const { return GetField<uint8_t>(VT_CONDITIONAL_ON_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_CONDITIONAL_ON_VERSION) && verifier.EndTable();
  }
};

struct CancelOrderBuilder {
  typedef CancelOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CancelOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(CancelOrder::VT_ORDER_ID, order_id, 0); }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CancelOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint8_t version) { fbb_.AddElement<uint8_t>(CancelOrder::VT_VERSION, version, 0); }
  void add_conditional_on_version(uint8_t conditional_on_version) {
    fbb_.AddElement<uint8_t>(CancelOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit CancelOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CancelOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CancelOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CancelOrder> CreateCancelOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint8_t version = 0,
    uint8_t conditional_on_version = 0) {
  CancelOrderBuilder builder_(_fbb);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CancelOrder> CreateCancelOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *routing_id = nullptr,
    uint8_t version = 0,
    uint8_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCancelOrder(_fbb, account__, order_id, routing_id__, version, conditional_on_version);
}

struct CreateOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_SIDE = 12,
    VT_POSITION_EFFECT = 14,
    VT_QUANTITY = 16,
    VT_MAX_SHOW_QUANTITY = 18,
    VT_ORDER_TYPE = 20,
    VT_TIME_IN_FORCE = 22,
    VT_EXECUTION_INSTRUCTION = 24,
    VT_ORDER_TEMPLATE = 26,
    VT_PRICE = 28,
    VT_STOP_PRICE = 30,
    VT_ROUTING_ID = 32
  };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  roq::fbs::ExecutionInstruction execution_instruction() const {
    return static_cast<roq::fbs::ExecutionInstruction>(GetField<uint8_t>(VT_EXECUTION_INSTRUCTION, 0));
  }
  const flatbuffers::String *order_template() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_TEMPLATE);
  }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double stop_price() const { return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT) &&
           VerifyField<double>(verifier, VT_QUANTITY) && VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY) &&
           VerifyField<uint8_t>(verifier, VT_ORDER_TYPE) && VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE) &&
           VerifyField<uint8_t>(verifier, VT_EXECUTION_INSTRUCTION) && VerifyOffset(verifier, VT_ORDER_TEMPLATE) &&
           verifier.VerifyString(order_template()) && VerifyField<double>(verifier, VT_PRICE) &&
           VerifyField<double>(verifier, VT_STOP_PRICE) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && verifier.EndTable();
  }
};

struct CreateOrderBuilder {
  typedef CreateOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(CreateOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(CreateOrder::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(CreateOrder::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(CreateOrder::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(CreateOrder::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(CreateOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(
        CreateOrder::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_execution_instruction(roq::fbs::ExecutionInstruction execution_instruction) {
    fbb_.AddElement<uint8_t>(CreateOrder::VT_EXECUTION_INSTRUCTION, static_cast<uint8_t>(execution_instruction), 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(CreateOrder::VT_ORDER_TEMPLATE, order_template);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(CreateOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(CreateOrder::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(CreateOrder::VT_ROUTING_ID, routing_id);
  }
  explicit CreateOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<CreateOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateOrder> CreateCreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    roq::fbs::ExecutionInstruction execution_instruction = roq::fbs::ExecutionInstruction_Undefined,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0) {
  CreateOrderBuilder builder_(_fbb);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_quantity(quantity);
  builder_.add_routing_id(routing_id);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_execution_instruction(execution_instruction);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateOrder> CreateCreateOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    roq::fbs::ExecutionInstruction execution_instruction = roq::fbs::ExecutionInstruction_Undefined,
    const char *order_template = nullptr,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    const char *routing_id = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateCreateOrder(
      _fbb,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      quantity,
      max_show_quantity,
      order_type,
      time_in_force,
      execution_instruction,
      order_template__,
      price,
      stop_price,
      routing_id__);
}

struct DownloadBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadBeginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4 };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           verifier.EndTable();
  }
};

struct DownloadBeginBuilder {
  typedef DownloadBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadBegin::VT_ACCOUNT, account);
  }
  explicit DownloadBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<DownloadBegin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBegin(
    flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::String> account = 0) {
  DownloadBeginBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<DownloadBegin> CreateDownloadBeginDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadBegin(_fbb, account__);
}

struct DownloadEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DownloadEndBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_ACCOUNT = 4, VT_MAX_ORDER_ID = 6 };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t max_order_id() const { return GetField<uint32_t>(VT_MAX_ORDER_ID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ORDER_ID) && verifier.EndTable();
  }
};

struct DownloadEndBuilder {
  typedef DownloadEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(DownloadEnd::VT_ACCOUNT, account);
  }
  void add_max_order_id(uint32_t max_order_id) {
    fbb_.AddElement<uint32_t>(DownloadEnd::VT_MAX_ORDER_ID, max_order_id, 0);
  }
  explicit DownloadEndBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<DownloadEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DownloadEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t max_order_id = 0) {
  DownloadEndBuilder builder_(_fbb);
  builder_.add_max_order_id(max_order_id);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<DownloadEnd> CreateDownloadEndDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *account = nullptr, uint32_t max_order_id = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateDownloadEnd(_fbb, account__, max_order_id);
}

struct ExternalLatency FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExternalLatencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_STREAM_ID = 4, VT_LATENCY = 6 };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  int64_t latency() const { return GetField<int64_t>(VT_LATENCY, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyField<int64_t>(verifier, VT_LATENCY) && verifier.EndTable();
  }
};

struct ExternalLatencyBuilder {
  typedef ExternalLatency Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(ExternalLatency::VT_STREAM_ID, stream_id, 0); }
  void add_latency(int64_t latency) { fbb_.AddElement<int64_t>(ExternalLatency::VT_LATENCY, latency, 0); }
  explicit ExternalLatencyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ExternalLatency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExternalLatency>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExternalLatency> CreateExternalLatency(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t stream_id = 0, int64_t latency = 0) {
  ExternalLatencyBuilder builder_(_fbb);
  builder_.add_latency(latency);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct FundsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FundsUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_CURRENCY = 8,
    VT_BALANCE = 10,
    VT_HOLD = 12,
    VT_EXTERNAL_ACCOUNT = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  const flatbuffers::String *currency() const { return GetPointer<const flatbuffers::String *>(VT_CURRENCY); }
  double balance() const { return GetField<double>(VT_BALANCE, std::numeric_limits<double>::quiet_NaN()); }
  double hold() const { return GetField<double>(VT_HOLD, std::numeric_limits<double>::quiet_NaN()); }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_CURRENCY) && verifier.VerifyString(currency()) &&
           VerifyField<double>(verifier, VT_BALANCE) && VerifyField<double>(verifier, VT_HOLD) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) && verifier.VerifyString(external_account()) &&
           verifier.EndTable();
  }
};

struct FundsUpdateBuilder {
  typedef FundsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(FundsUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(FundsUpdate::VT_ACCOUNT, account);
  }
  void add_currency(flatbuffers::Offset<flatbuffers::String> currency) {
    fbb_.AddOffset(FundsUpdate::VT_CURRENCY, currency);
  }
  void add_balance(double balance) {
    fbb_.AddElement<double>(FundsUpdate::VT_BALANCE, balance, std::numeric_limits<double>::quiet_NaN());
  }
  void add_hold(double hold) {
    fbb_.AddElement<double>(FundsUpdate::VT_HOLD, hold, std::numeric_limits<double>::quiet_NaN());
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(FundsUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  explicit FundsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<FundsUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FundsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> currency = 0,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> external_account = 0) {
  FundsUpdateBuilder builder_(_fbb);
  builder_.add_hold(hold);
  builder_.add_balance(balance);
  builder_.add_external_account(external_account);
  builder_.add_currency(currency);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<FundsUpdate> CreateFundsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    const char *currency = nullptr,
    double balance = std::numeric_limits<double>::quiet_NaN(),
    double hold = std::numeric_limits<double>::quiet_NaN(),
    const char *external_account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto currency__ = currency ? _fbb.CreateString(currency) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreateFundsUpdate(_fbb, stream_id, account__, currency__, balance, hold, external_account__);
}

struct GatewaySettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewaySettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUPPORTS = 4,
    VT_MBP_MAX_DEPTH = 6,
    VT_MBP_ALLOW_PRICE_INVERSION = 8,
    VT_MBP_ALLOW_FRACTIONAL_TICK_SIZE = 10,
    VT_MBP_ALLOW_REMOVE_NON_EXISTING = 12
  };
  uint64_t supports() const { return GetField<uint64_t>(VT_SUPPORTS, 0); }
  uint32_t mbp_max_depth() const { return GetField<uint32_t>(VT_MBP_MAX_DEPTH, 0); }
  bool mbp_allow_price_inversion() const { return GetField<uint8_t>(VT_MBP_ALLOW_PRICE_INVERSION, 0) != 0; }
  bool mbp_allow_fractional_tick_size() const { return GetField<uint8_t>(VT_MBP_ALLOW_FRACTIONAL_TICK_SIZE, 0) != 0; }
  bool mbp_allow_remove_non_existing() const { return GetField<uint8_t>(VT_MBP_ALLOW_REMOVE_NON_EXISTING, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_SUPPORTS) &&
           VerifyField<uint32_t>(verifier, VT_MBP_MAX_DEPTH) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_PRICE_INVERSION) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_FRACTIONAL_TICK_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_MBP_ALLOW_REMOVE_NON_EXISTING) && verifier.EndTable();
  }
};

struct GatewaySettingsBuilder {
  typedef GatewaySettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_supports(uint64_t supports) { fbb_.AddElement<uint64_t>(GatewaySettings::VT_SUPPORTS, supports, 0); }
  void add_mbp_max_depth(uint32_t mbp_max_depth) {
    fbb_.AddElement<uint32_t>(GatewaySettings::VT_MBP_MAX_DEPTH, mbp_max_depth, 0);
  }
  void add_mbp_allow_price_inversion(bool mbp_allow_price_inversion) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_MBP_ALLOW_PRICE_INVERSION, static_cast<uint8_t>(mbp_allow_price_inversion), 0);
  }
  void add_mbp_allow_fractional_tick_size(bool mbp_allow_fractional_tick_size) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_MBP_ALLOW_FRACTIONAL_TICK_SIZE, static_cast<uint8_t>(mbp_allow_fractional_tick_size), 0);
  }
  void add_mbp_allow_remove_non_existing(bool mbp_allow_remove_non_existing) {
    fbb_.AddElement<uint8_t>(
        GatewaySettings::VT_MBP_ALLOW_REMOVE_NON_EXISTING, static_cast<uint8_t>(mbp_allow_remove_non_existing), 0);
  }
  explicit GatewaySettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<GatewaySettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewaySettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewaySettings> CreateGatewaySettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t supports = 0,
    uint32_t mbp_max_depth = 0,
    bool mbp_allow_price_inversion = false,
    bool mbp_allow_fractional_tick_size = false,
    bool mbp_allow_remove_non_existing = false) {
  GatewaySettingsBuilder builder_(_fbb);
  builder_.add_supports(supports);
  builder_.add_mbp_max_depth(mbp_max_depth);
  builder_.add_mbp_allow_remove_non_existing(mbp_allow_remove_non_existing);
  builder_.add_mbp_allow_fractional_tick_size(mbp_allow_fractional_tick_size);
  builder_.add_mbp_allow_price_inversion(mbp_allow_price_inversion);
  return builder_.Finish();
}

struct GatewayStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatewayStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_SUPPORTED = 6,
    VT_AVAILABLE = 8,
    VT_UNAVAILABLE = 10
  };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint64_t supported() const { return GetField<uint64_t>(VT_SUPPORTED, 0); }
  uint64_t available() const { return GetField<uint64_t>(VT_AVAILABLE, 0); }
  uint64_t unavailable() const { return GetField<uint64_t>(VT_UNAVAILABLE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTED) && VerifyField<uint64_t>(verifier, VT_AVAILABLE) &&
           VerifyField<uint64_t>(verifier, VT_UNAVAILABLE) && verifier.EndTable();
  }
};

struct GatewayStatusBuilder {
  typedef GatewayStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(GatewayStatus::VT_ACCOUNT, account);
  }
  void add_supported(uint64_t supported) { fbb_.AddElement<uint64_t>(GatewayStatus::VT_SUPPORTED, supported, 0); }
  void add_available(uint64_t available) { fbb_.AddElement<uint64_t>(GatewayStatus::VT_AVAILABLE, available, 0); }
  void add_unavailable(uint64_t unavailable) {
    fbb_.AddElement<uint64_t>(GatewayStatus::VT_UNAVAILABLE, unavailable, 0);
  }
  explicit GatewayStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<GatewayStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatewayStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  GatewayStatusBuilder builder_(_fbb);
  builder_.add_unavailable(unavailable);
  builder_.add_available(available);
  builder_.add_supported(supported);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<GatewayStatus> CreateGatewayStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint64_t supported = 0,
    uint64_t available = 0,
    uint64_t unavailable = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateGatewayStatus(_fbb, account__, supported, available, unavailable);
}

struct MarketByOrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByOrderUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_SNAPSHOT = 14,
    VT_EXCHANGE_TIME_UTC = 16
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *bids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *>(VT_BIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *asks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *>(VT_ASKS);
  }
  bool snapshot() const { return GetField<uint8_t>(VT_SNAPSHOT, 0) != 0; }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) && verifier.VerifyVectorOfTables(bids()) && VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) && verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_SNAPSHOT) && VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC) &&
           verifier.EndTable();
  }
};

struct MarketByOrderUpdateBuilder {
  typedef MarketByOrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketByOrderUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks) {
    fbb_.AddOffset(MarketByOrderUpdate::VT_ASKS, asks);
  }
  void add_snapshot(bool snapshot) {
    fbb_.AddElement<uint8_t>(MarketByOrderUpdate::VT_SNAPSHOT, static_cast<uint8_t>(snapshot), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByOrderUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit MarketByOrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketByOrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByOrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBOUpdate>>> asks = 0,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  MarketByOrderUpdateBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_snapshot(snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketByOrderUpdate> CreateMarketByOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *bids = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBOUpdate>> *asks = nullptr,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBOUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByOrderUpdate(
      _fbb, stream_id, exchange__, symbol__, bids__, asks__, snapshot, exchange_time_utc);
}

struct MarketByPriceUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketByPriceUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_SNAPSHOT = 14,
    VT_EXCHANGE_TIME_UTC = 16
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *bids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *>(VT_BIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *asks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *>(VT_ASKS);
  }
  bool snapshot() const { return GetField<uint8_t>(VT_SNAPSHOT, 0) != 0; }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) && verifier.VerifyVectorOfTables(bids()) && VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) && verifier.VerifyVectorOfTables(asks()) &&
           VerifyField<uint8_t>(verifier, VT_SNAPSHOT) && VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC) &&
           verifier.EndTable();
  }
};

struct MarketByPriceUpdateBuilder {
  typedef MarketByPriceUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketByPriceUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_SYMBOL, symbol);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks) {
    fbb_.AddOffset(MarketByPriceUpdate::VT_ASKS, asks);
  }
  void add_snapshot(bool snapshot) {
    fbb_.AddElement<uint8_t>(MarketByPriceUpdate::VT_SNAPSHOT, static_cast<uint8_t>(snapshot), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(MarketByPriceUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit MarketByPriceUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketByPriceUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketByPriceUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::MBPUpdate>>> asks = 0,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  MarketByPriceUpdateBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_snapshot(snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketByPriceUpdate> CreateMarketByPriceUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *bids = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::MBPUpdate>> *asks = nullptr,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto bids__ = bids ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::MBPUpdate>>(*asks) : 0;
  return roq::fbs::CreateMarketByPriceUpdate(
      _fbb, stream_id, exchange__, symbol__, bids__, asks__, snapshot, exchange_time_utc);
}

struct MarketStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarketStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADING_STATUS = 10
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  roq::fbs::TradingStatus trading_status() const {
    return static_cast<roq::fbs::TradingStatus>(GetField<uint8_t>(VT_TRADING_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_TRADING_STATUS) && verifier.EndTable();
  }
};

struct MarketStatusBuilder {
  typedef MarketStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(MarketStatus::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(MarketStatus::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(MarketStatus::VT_SYMBOL, symbol); }
  void add_trading_status(roq::fbs::TradingStatus trading_status) {
    fbb_.AddElement<uint8_t>(MarketStatus::VT_TRADING_STATUS, static_cast<uint8_t>(trading_status), 0);
  }
  explicit MarketStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<MarketStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarketStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<MarketStatus> CreateMarketStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus_Undefined) {
  MarketStatusBuilder builder_(_fbb);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_trading_status(trading_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarketStatus> CreateMarketStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::TradingStatus trading_status = roq::fbs::TradingStatus_Undefined) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateMarketStatus(_fbb, stream_id, exchange__, symbol__, trading_status);
}

struct ModifyOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModifyOrderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNT = 4,
    VT_ORDER_ID = 6,
    VT_QUANTITY = 8,
    VT_PRICE = 10,
    VT_ROUTING_ID = 12,
    VT_VERSION = 14,
    VT_CONDITIONAL_ON_VERSION = 16
  };
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  uint8_t version() const { return GetField<uint8_t>(VT_VERSION, 0); }
  uint8_t conditional_on_version() const { return GetField<uint8_t>(VT_CONDITIONAL_ON_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyField<double>(verifier, VT_QUANTITY) &&
           VerifyField<double>(verifier, VT_PRICE) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_CONDITIONAL_ON_VERSION) && verifier.EndTable();
  }
};

struct ModifyOrderBuilder {
  typedef ModifyOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(ModifyOrder::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(ModifyOrder::VT_ORDER_ID, order_id, 0); }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(ModifyOrder::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_price(double price) {
    fbb_.AddElement<double>(ModifyOrder::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(ModifyOrder::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint8_t version) { fbb_.AddElement<uint8_t>(ModifyOrder::VT_VERSION, version, 0); }
  void add_conditional_on_version(uint8_t conditional_on_version) {
    fbb_.AddElement<uint8_t>(ModifyOrder::VT_CONDITIONAL_ON_VERSION, conditional_on_version, 0);
  }
  explicit ModifyOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ModifyOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModifyOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint8_t version = 0,
    uint8_t conditional_on_version = 0) {
  ModifyOrderBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_quantity(quantity);
  builder_.add_routing_id(routing_id);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_conditional_on_version(conditional_on_version);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ModifyOrder> CreateModifyOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    uint32_t order_id = 0,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double price = std::numeric_limits<double>::quiet_NaN(),
    const char *routing_id = nullptr,
    uint8_t version = 0,
    uint8_t conditional_on_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateModifyOrder(
      _fbb, account__, order_id, quantity, price, routing_id__, version, conditional_on_version);
}

struct OrderAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_TYPE = 10,
    VT_ORIGIN = 12,
    VT_STATUS = 14,
    VT_ERROR = 16,
    VT_TEXT = 18,
    VT_REQUEST_ID = 20,
    VT_EXTERNAL_ACCOUNT = 22,
    VT_EXTERNAL_ORDER_ID = 24,
    VT_ROUTING_ID = 26,
    VT_VERSION = 28
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  roq::fbs::RequestType type() const { return static_cast<roq::fbs::RequestType>(GetField<uint8_t>(VT_TYPE, 0)); }
  roq::fbs::Origin origin() const { return static_cast<roq::fbs::Origin>(GetField<uint8_t>(VT_ORIGIN, 0)); }
  roq::fbs::RequestStatus status() const {
    return static_cast<roq::fbs::RequestStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  roq::fbs::Error error() const { return static_cast<roq::fbs::Error>(GetField<uint8_t>(VT_ERROR, 0)); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  const flatbuffers::String *request_id() const { return GetPointer<const flatbuffers::String *>(VT_REQUEST_ID); }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  uint8_t version() const { return GetField<uint8_t>(VT_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ORIGIN) && VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_ERROR) && VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) && VerifyOffset(verifier, VT_REQUEST_ID) &&
           verifier.VerifyString(request_id()) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint8_t>(verifier, VT_VERSION) && verifier.EndTable();
  }
};

struct OrderAckBuilder {
  typedef OrderAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(OrderAck::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) { fbb_.AddOffset(OrderAck::VT_ACCOUNT, account); }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(OrderAck::VT_ORDER_ID, order_id, 0); }
  void add_type(roq::fbs::RequestType type) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_origin(roq::fbs::Origin origin) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ORIGIN, static_cast<uint8_t>(origin), 0);
  }
  void add_status(roq::fbs::RequestStatus status) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_error(roq::fbs::Error error) {
    fbb_.AddElement<uint8_t>(OrderAck::VT_ERROR, static_cast<uint8_t>(error), 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(OrderAck::VT_TEXT, text); }
  void add_request_id(flatbuffers::Offset<flatbuffers::String> request_id) {
    fbb_.AddOffset(OrderAck::VT_REQUEST_ID, request_id);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderAck::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderAck::VT_ROUTING_ID, routing_id);
  }
  void add_version(uint8_t version) { fbb_.AddElement<uint8_t>(OrderAck::VT_VERSION, version, 0); }
  explicit OrderAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<OrderAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderAck> CreateOrderAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    roq::fbs::RequestType type = roq::fbs::RequestType_Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus_Undefined,
    roq::fbs::Error error = roq::fbs::Error_Undefined,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> request_id = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint8_t version = 0) {
  OrderAckBuilder builder_(_fbb);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_request_id(request_id);
  builder_.add_text(text);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_version(version);
  builder_.add_error(error);
  builder_.add_status(status);
  builder_.add_origin(origin);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderAck> CreateOrderAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    roq::fbs::RequestType type = roq::fbs::RequestType_Undefined,
    roq::fbs::Origin origin = roq::fbs::Origin_Undefined,
    roq::fbs::RequestStatus status = roq::fbs::RequestStatus_Undefined,
    roq::fbs::Error error = roq::fbs::Error_Undefined,
    const char *text = nullptr,
    const char *request_id = nullptr,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    const char *routing_id = nullptr,
    uint8_t version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto request_id__ = request_id ? _fbb.CreateString(request_id) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateOrderAck(
      _fbb,
      stream_id,
      account__,
      order_id,
      type,
      origin,
      status,
      error,
      text__,
      request_id__,
      external_account__,
      external_order_id__,
      routing_id__,
      version);
}

struct OrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_QUANTITY = 18,
    VT_MAX_SHOW_QUANTITY = 20,
    VT_ORDER_TYPE = 22,
    VT_TIME_IN_FORCE = 24,
    VT_EXECUTION_INSTRUCTION = 26,
    VT_ORDER_TEMPLATE = 28,
    VT_CREATE_TIME_UTC = 30,
    VT_UPDATE_TIME_UTC = 32,
    VT_EXTERNAL_ACCOUNT = 34,
    VT_EXTERNAL_ORDER_ID = 36,
    VT_STATUS = 38,
    VT_PRICE = 40,
    VT_STOP_PRICE = 42,
    VT_REMAINING_QUANTITY = 44,
    VT_TRADED_QUANTITY = 46,
    VT_AVERAGE_TRADED_PRICE = 48,
    VT_LAST_TRADED_PRICE = 50,
    VT_LAST_TRADED_QUANTITY = 52,
    VT_LAST_LIQUIDITY = 54,
    VT_ROUTING_ID = 56,
    VT_MAX_REQUEST_VERSION = 58,
    VT_MAX_RESPONSE_VERSION = 60,
    VT_MAX_ACCEPTED_VERSION = 62
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  double quantity() const { return GetField<double>(VT_QUANTITY, std::numeric_limits<double>::quiet_NaN()); }
  double max_show_quantity() const {
    return GetField<double>(VT_MAX_SHOW_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::OrderType order_type() const {
    return static_cast<roq::fbs::OrderType>(GetField<uint8_t>(VT_ORDER_TYPE, 0));
  }
  roq::fbs::TimeInForce time_in_force() const {
    return static_cast<roq::fbs::TimeInForce>(GetField<uint8_t>(VT_TIME_IN_FORCE, 0));
  }
  roq::fbs::ExecutionInstruction execution_instruction() const {
    return static_cast<roq::fbs::ExecutionInstruction>(GetField<uint8_t>(VT_EXECUTION_INSTRUCTION, 0));
  }
  const flatbuffers::String *order_template() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_TEMPLATE);
  }
  int64_t create_time_utc() const { return GetField<int64_t>(VT_CREATE_TIME_UTC, 0); }
  int64_t update_time_utc() const { return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0); }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  roq::fbs::OrderStatus status() const { return static_cast<roq::fbs::OrderStatus>(GetField<uint8_t>(VT_STATUS, 0)); }
  double price() const { return GetField<double>(VT_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double stop_price() const { return GetField<double>(VT_STOP_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  double remaining_quantity() const {
    return GetField<double>(VT_REMAINING_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double traded_quantity() const {
    return GetField<double>(VT_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  double average_traded_price() const {
    return GetField<double>(VT_AVERAGE_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_price() const {
    return GetField<double>(VT_LAST_TRADED_PRICE, std::numeric_limits<double>::quiet_NaN());
  }
  double last_traded_quantity() const {
    return GetField<double>(VT_LAST_TRADED_QUANTITY, std::numeric_limits<double>::quiet_NaN());
  }
  roq::fbs::Liquidity last_liquidity() const {
    return static_cast<roq::fbs::Liquidity>(GetField<uint8_t>(VT_LAST_LIQUIDITY, 0));
  }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  uint8_t max_request_version() const { return GetField<uint8_t>(VT_MAX_REQUEST_VERSION, 0); }
  uint8_t max_response_version() const { return GetField<uint8_t>(VT_MAX_RESPONSE_VERSION, 0); }
  uint8_t max_accepted_version() const { return GetField<uint8_t>(VT_MAX_ACCEPTED_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT) &&
           VerifyField<double>(verifier, VT_QUANTITY) && VerifyField<double>(verifier, VT_MAX_SHOW_QUANTITY) &&
           VerifyField<uint8_t>(verifier, VT_ORDER_TYPE) && VerifyField<uint8_t>(verifier, VT_TIME_IN_FORCE) &&
           VerifyField<uint8_t>(verifier, VT_EXECUTION_INSTRUCTION) && VerifyOffset(verifier, VT_ORDER_TEMPLATE) &&
           verifier.VerifyString(order_template()) && VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC) &&
           VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) &&
           verifier.VerifyString(external_order_id()) && VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<double>(verifier, VT_PRICE) && VerifyField<double>(verifier, VT_STOP_PRICE) &&
           VerifyField<double>(verifier, VT_REMAINING_QUANTITY) && VerifyField<double>(verifier, VT_TRADED_QUANTITY) &&
           VerifyField<double>(verifier, VT_AVERAGE_TRADED_PRICE) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_PRICE) &&
           VerifyField<double>(verifier, VT_LAST_TRADED_QUANTITY) &&
           VerifyField<uint8_t>(verifier, VT_LAST_LIQUIDITY) && VerifyOffset(verifier, VT_ROUTING_ID) &&
           verifier.VerifyString(routing_id()) && VerifyField<uint8_t>(verifier, VT_MAX_REQUEST_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_MAX_RESPONSE_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_MAX_ACCEPTED_VERSION) && verifier.EndTable();
  }
};

struct OrderUpdateBuilder {
  typedef OrderUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(OrderUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(OrderUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(OrderUpdate::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(OrderUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(OrderUpdate::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(OrderUpdate::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_quantity(double quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_QUANTITY, quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_max_show_quantity(double max_show_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_MAX_SHOW_QUANTITY, max_show_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_order_type(roq::fbs::OrderType order_type) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_ORDER_TYPE, static_cast<uint8_t>(order_type), 0);
  }
  void add_time_in_force(roq::fbs::TimeInForce time_in_force) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_TIME_IN_FORCE, static_cast<uint8_t>(time_in_force), 0);
  }
  void add_execution_instruction(roq::fbs::ExecutionInstruction execution_instruction) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_EXECUTION_INSTRUCTION, static_cast<uint8_t>(execution_instruction), 0);
  }
  void add_order_template(flatbuffers::Offset<flatbuffers::String> order_template) {
    fbb_.AddOffset(OrderUpdate::VT_ORDER_TEMPLATE, order_template);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(OrderUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_status(roq::fbs::OrderStatus status) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(OrderUpdate::VT_PRICE, price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_stop_price(double stop_price) {
    fbb_.AddElement<double>(OrderUpdate::VT_STOP_PRICE, stop_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_remaining_quantity(double remaining_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_REMAINING_QUANTITY, remaining_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_traded_quantity(double traded_quantity) {
    fbb_.AddElement<double>(OrderUpdate::VT_TRADED_QUANTITY, traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_average_traded_price(double average_traded_price) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_AVERAGE_TRADED_PRICE, average_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_price(double last_traded_price) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_LAST_TRADED_PRICE, last_traded_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_traded_quantity(double last_traded_quantity) {
    fbb_.AddElement<double>(
        OrderUpdate::VT_LAST_TRADED_QUANTITY, last_traded_quantity, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_liquidity(roq::fbs::Liquidity last_liquidity) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_LAST_LIQUIDITY, static_cast<uint8_t>(last_liquidity), 0);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(OrderUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_max_request_version(uint8_t max_request_version) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_MAX_REQUEST_VERSION, max_request_version, 0);
  }
  void add_max_response_version(uint8_t max_response_version) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_MAX_RESPONSE_VERSION, max_response_version, 0);
  }
  void add_max_accepted_version(uint8_t max_accepted_version) {
    fbb_.AddElement<uint8_t>(OrderUpdate::VT_MAX_ACCEPTED_VERSION, max_accepted_version, 0);
  }
  explicit OrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<OrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    roq::fbs::ExecutionInstruction execution_instruction = roq::fbs::ExecutionInstruction_Undefined,
    flatbuffers::Offset<flatbuffers::String> order_template = 0,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity_Undefined,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    uint8_t max_request_version = 0,
    uint8_t max_response_version = 0,
    uint8_t max_accepted_version = 0) {
  OrderUpdateBuilder builder_(_fbb);
  builder_.add_last_traded_quantity(last_traded_quantity);
  builder_.add_last_traded_price(last_traded_price);
  builder_.add_average_traded_price(average_traded_price);
  builder_.add_traded_quantity(traded_quantity);
  builder_.add_remaining_quantity(remaining_quantity);
  builder_.add_stop_price(stop_price);
  builder_.add_price(price);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_max_show_quantity(max_show_quantity);
  builder_.add_quantity(quantity);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_order_template(order_template);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_max_accepted_version(max_accepted_version);
  builder_.add_max_response_version(max_response_version);
  builder_.add_max_request_version(max_request_version);
  builder_.add_last_liquidity(last_liquidity);
  builder_.add_status(status);
  builder_.add_execution_instruction(execution_instruction);
  builder_.add_time_in_force(time_in_force);
  builder_.add_order_type(order_type);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    double quantity = std::numeric_limits<double>::quiet_NaN(),
    double max_show_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OrderType order_type = roq::fbs::OrderType_Undefined,
    roq::fbs::TimeInForce time_in_force = roq::fbs::TimeInForce_Undefined,
    roq::fbs::ExecutionInstruction execution_instruction = roq::fbs::ExecutionInstruction_Undefined,
    const char *order_template = nullptr,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    roq::fbs::OrderStatus status = roq::fbs::OrderStatus_Undefined,
    double price = std::numeric_limits<double>::quiet_NaN(),
    double stop_price = std::numeric_limits<double>::quiet_NaN(),
    double remaining_quantity = std::numeric_limits<double>::quiet_NaN(),
    double traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    double average_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_price = std::numeric_limits<double>::quiet_NaN(),
    double last_traded_quantity = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::Liquidity last_liquidity = roq::fbs::Liquidity_Undefined,
    const char *routing_id = nullptr,
    uint8_t max_request_version = 0,
    uint8_t max_response_version = 0,
    uint8_t max_accepted_version = 0) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto order_template__ = order_template ? _fbb.CreateString(order_template) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  return roq::fbs::CreateOrderUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      quantity,
      max_show_quantity,
      order_type,
      time_in_force,
      execution_instruction,
      order_template__,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      status,
      price,
      stop_price,
      remaining_quantity,
      traded_quantity,
      average_traded_price,
      last_traded_price,
      last_traded_quantity,
      last_liquidity,
      routing_id__,
      max_request_version,
      max_response_version,
      max_accepted_version);
}

struct PositionUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PositionUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_EXCHANGE = 8,
    VT_SYMBOL = 10,
    VT_SIDE = 12,
    VT_POSITION = 14,
    VT_LAST_TRADE_ID = 16,
    VT_POSITION_COST = 18,
    VT_POSITION_YESTERDAY = 20,
    VT_POSITION_COST_YESTERDAY = 22,
    VT_EXTERNAL_ACCOUNT = 24
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  double position() const { return GetField<double>(VT_POSITION, std::numeric_limits<double>::quiet_NaN()); }
  uint32_t last_trade_id() const { return GetField<uint32_t>(VT_LAST_TRADE_ID, 0); }
  double position_cost() const { return GetField<double>(VT_POSITION_COST, std::numeric_limits<double>::quiet_NaN()); }
  double position_yesterday() const {
    return GetField<double>(VT_POSITION_YESTERDAY, std::numeric_limits<double>::quiet_NaN());
  }
  double position_cost_yesterday() const {
    return GetField<double>(VT_POSITION_COST_YESTERDAY, std::numeric_limits<double>::quiet_NaN());
  }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE) && VerifyField<double>(verifier, VT_POSITION) &&
           VerifyField<uint32_t>(verifier, VT_LAST_TRADE_ID) && VerifyField<double>(verifier, VT_POSITION_COST) &&
           VerifyField<double>(verifier, VT_POSITION_YESTERDAY) &&
           VerifyField<double>(verifier, VT_POSITION_COST_YESTERDAY) && VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) &&
           verifier.VerifyString(external_account()) && verifier.EndTable();
  }
};

struct PositionUpdateBuilder {
  typedef PositionUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(PositionUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(PositionUpdate::VT_ACCOUNT, account);
  }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(PositionUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(PositionUpdate::VT_SYMBOL, symbol);
  }
  void add_side(roq::fbs::Side side) {
    fbb_.AddElement<uint8_t>(PositionUpdate::VT_SIDE, static_cast<uint8_t>(side), 0);
  }
  void add_position(double position) {
    fbb_.AddElement<double>(PositionUpdate::VT_POSITION, position, std::numeric_limits<double>::quiet_NaN());
  }
  void add_last_trade_id(uint32_t last_trade_id) {
    fbb_.AddElement<uint32_t>(PositionUpdate::VT_LAST_TRADE_ID, last_trade_id, 0);
  }
  void add_position_cost(double position_cost) {
    fbb_.AddElement<double>(PositionUpdate::VT_POSITION_COST, position_cost, std::numeric_limits<double>::quiet_NaN());
  }
  void add_position_yesterday(double position_yesterday) {
    fbb_.AddElement<double>(
        PositionUpdate::VT_POSITION_YESTERDAY, position_yesterday, std::numeric_limits<double>::quiet_NaN());
  }
  void add_position_cost_yesterday(double position_cost_yesterday) {
    fbb_.AddElement<double>(
        PositionUpdate::VT_POSITION_COST_YESTERDAY, position_cost_yesterday, std::numeric_limits<double>::quiet_NaN());
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(PositionUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  explicit PositionUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<PositionUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PositionUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double position = std::numeric_limits<double>::quiet_NaN(),
    uint32_t last_trade_id = 0,
    double position_cost = std::numeric_limits<double>::quiet_NaN(),
    double position_yesterday = std::numeric_limits<double>::quiet_NaN(),
    double position_cost_yesterday = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> external_account = 0) {
  PositionUpdateBuilder builder_(_fbb);
  builder_.add_position_cost_yesterday(position_cost_yesterday);
  builder_.add_position_yesterday(position_yesterday);
  builder_.add_position_cost(position_cost);
  builder_.add_position(position);
  builder_.add_external_account(external_account);
  builder_.add_last_trade_id(last_trade_id);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<PositionUpdate> CreatePositionUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    double position = std::numeric_limits<double>::quiet_NaN(),
    uint32_t last_trade_id = 0,
    double position_cost = std::numeric_limits<double>::quiet_NaN(),
    double position_yesterday = std::numeric_limits<double>::quiet_NaN(),
    double position_cost_yesterday = std::numeric_limits<double>::quiet_NaN(),
    const char *external_account = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  return roq::fbs::CreatePositionUpdate(
      _fbb,
      stream_id,
      account__,
      exchange__,
      symbol__,
      side,
      position,
      last_trade_id,
      position_cost,
      position_yesterday,
      position_cost_yesterday,
      external_account__);
}

struct RateLimitUsage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RateLimitUsageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_STREAM_ID = 4, VT_ABOVE_HIGH_WATER_MARK = 6 };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  bool above_high_water_mark() const { return GetField<uint8_t>(VT_ABOVE_HIGH_WATER_MARK, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyField<uint8_t>(verifier, VT_ABOVE_HIGH_WATER_MARK) && verifier.EndTable();
  }
};

struct RateLimitUsageBuilder {
  typedef RateLimitUsage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(RateLimitUsage::VT_STREAM_ID, stream_id, 0); }
  void add_above_high_water_mark(bool above_high_water_mark) {
    fbb_.AddElement<uint8_t>(RateLimitUsage::VT_ABOVE_HIGH_WATER_MARK, static_cast<uint8_t>(above_high_water_mark), 0);
  }
  explicit RateLimitUsageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<RateLimitUsage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RateLimitUsage>(end);
    return o;
  }
};

inline flatbuffers::Offset<RateLimitUsage> CreateRateLimitUsage(
    flatbuffers::FlatBufferBuilder &_fbb, uint16_t stream_id = 0, bool above_high_water_mark = false) {
  RateLimitUsageBuilder builder_(_fbb);
  builder_.add_stream_id(stream_id);
  builder_.add_above_high_water_mark(above_high_water_mark);
  return builder_.Finish();
}

struct ReferenceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReferenceDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_DESCRIPTION = 10,
    VT_SECURITY_TYPE = 12,
    VT_CURRENCY = 14,
    VT_SETTLEMENT_CURRENCY = 16,
    VT_COMMISSION_CURRENCY = 18,
    VT_TICK_SIZE = 20,
    VT_MULTIPLIER = 22,
    VT_MIN_TRADE_VOL = 24,
    VT_OPTION_TYPE = 26,
    VT_STRIKE_CURRENCY = 28,
    VT_STRIKE_PRICE = 30,
    VT_UNDERLYING = 32,
    VT_TIME_ZONE = 34,
    VT_ISSUE_DATE = 36,
    VT_SETTLEMENT_DATE = 38,
    VT_EXPIRY_DATETIME = 40,
    VT_EXPIRY_DATETIME_UTC = 42
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const flatbuffers::String *description() const { return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION); }
  roq::fbs::SecurityType security_type() const {
    return static_cast<roq::fbs::SecurityType>(GetField<uint8_t>(VT_SECURITY_TYPE, 0));
  }
  const flatbuffers::String *currency() const { return GetPointer<const flatbuffers::String *>(VT_CURRENCY); }
  const flatbuffers::String *settlement_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_SETTLEMENT_CURRENCY);
  }
  const flatbuffers::String *commission_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMISSION_CURRENCY);
  }
  double tick_size() const { return GetField<double>(VT_TICK_SIZE, std::numeric_limits<double>::quiet_NaN()); }
  double multiplier() const { return GetField<double>(VT_MULTIPLIER, std::numeric_limits<double>::quiet_NaN()); }
  double min_trade_vol() const { return GetField<double>(VT_MIN_TRADE_VOL, std::numeric_limits<double>::quiet_NaN()); }
  roq::fbs::OptionType option_type() const {
    return static_cast<roq::fbs::OptionType>(GetField<uint8_t>(VT_OPTION_TYPE, 0));
  }
  const flatbuffers::String *strike_currency() const {
    return GetPointer<const flatbuffers::String *>(VT_STRIKE_CURRENCY);
  }
  double strike_price() const { return GetField<double>(VT_STRIKE_PRICE, std::numeric_limits<double>::quiet_NaN()); }
  const flatbuffers::String *underlying() const { return GetPointer<const flatbuffers::String *>(VT_UNDERLYING); }
  const flatbuffers::String *time_zone() const { return GetPointer<const flatbuffers::String *>(VT_TIME_ZONE); }
  int32_t issue_date() const { return GetField<int32_t>(VT_ISSUE_DATE, 0); }
  int32_t settlement_date() const { return GetField<int32_t>(VT_SETTLEMENT_DATE, 0); }
  int64_t expiry_datetime() const { return GetField<int64_t>(VT_EXPIRY_DATETIME, 0); }
  int64_t expiry_datetime_utc() const { return GetField<int64_t>(VT_EXPIRY_DATETIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) && verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_SECURITY_TYPE) && VerifyOffset(verifier, VT_CURRENCY) &&
           verifier.VerifyString(currency()) && VerifyOffset(verifier, VT_SETTLEMENT_CURRENCY) &&
           verifier.VerifyString(settlement_currency()) && VerifyOffset(verifier, VT_COMMISSION_CURRENCY) &&
           verifier.VerifyString(commission_currency()) && VerifyField<double>(verifier, VT_TICK_SIZE) &&
           VerifyField<double>(verifier, VT_MULTIPLIER) && VerifyField<double>(verifier, VT_MIN_TRADE_VOL) &&
           VerifyField<uint8_t>(verifier, VT_OPTION_TYPE) && VerifyOffset(verifier, VT_STRIKE_CURRENCY) &&
           verifier.VerifyString(strike_currency()) && VerifyField<double>(verifier, VT_STRIKE_PRICE) &&
           VerifyOffset(verifier, VT_UNDERLYING) && verifier.VerifyString(underlying()) &&
           VerifyOffset(verifier, VT_TIME_ZONE) && verifier.VerifyString(time_zone()) &&
           VerifyField<int32_t>(verifier, VT_ISSUE_DATE) && VerifyField<int32_t>(verifier, VT_SETTLEMENT_DATE) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME) &&
           VerifyField<int64_t>(verifier, VT_EXPIRY_DATETIME_UTC) && verifier.EndTable();
  }
};

struct ReferenceDataBuilder {
  typedef ReferenceData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(ReferenceData::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(ReferenceData::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(ReferenceData::VT_SYMBOL, symbol); }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(ReferenceData::VT_DESCRIPTION, description);
  }
  void add_security_type(roq::fbs::SecurityType security_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_SECURITY_TYPE, static_cast<uint8_t>(security_type), 0);
  }
  void add_currency(flatbuffers::Offset<flatbuffers::String> currency) {
    fbb_.AddOffset(ReferenceData::VT_CURRENCY, currency);
  }
  void add_settlement_currency(flatbuffers::Offset<flatbuffers::String> settlement_currency) {
    fbb_.AddOffset(ReferenceData::VT_SETTLEMENT_CURRENCY, settlement_currency);
  }
  void add_commission_currency(flatbuffers::Offset<flatbuffers::String> commission_currency) {
    fbb_.AddOffset(ReferenceData::VT_COMMISSION_CURRENCY, commission_currency);
  }
  void add_tick_size(double tick_size) {
    fbb_.AddElement<double>(ReferenceData::VT_TICK_SIZE, tick_size, std::numeric_limits<double>::quiet_NaN());
  }
  void add_multiplier(double multiplier) {
    fbb_.AddElement<double>(ReferenceData::VT_MULTIPLIER, multiplier, std::numeric_limits<double>::quiet_NaN());
  }
  void add_min_trade_vol(double min_trade_vol) {
    fbb_.AddElement<double>(ReferenceData::VT_MIN_TRADE_VOL, min_trade_vol, std::numeric_limits<double>::quiet_NaN());
  }
  void add_option_type(roq::fbs::OptionType option_type) {
    fbb_.AddElement<uint8_t>(ReferenceData::VT_OPTION_TYPE, static_cast<uint8_t>(option_type), 0);
  }
  void add_strike_currency(flatbuffers::Offset<flatbuffers::String> strike_currency) {
    fbb_.AddOffset(ReferenceData::VT_STRIKE_CURRENCY, strike_currency);
  }
  void add_strike_price(double strike_price) {
    fbb_.AddElement<double>(ReferenceData::VT_STRIKE_PRICE, strike_price, std::numeric_limits<double>::quiet_NaN());
  }
  void add_underlying(flatbuffers::Offset<flatbuffers::String> underlying) {
    fbb_.AddOffset(ReferenceData::VT_UNDERLYING, underlying);
  }
  void add_time_zone(flatbuffers::Offset<flatbuffers::String> time_zone) {
    fbb_.AddOffset(ReferenceData::VT_TIME_ZONE, time_zone);
  }
  void add_issue_date(int32_t issue_date) { fbb_.AddElement<int32_t>(ReferenceData::VT_ISSUE_DATE, issue_date, 0); }
  void add_settlement_date(int32_t settlement_date) {
    fbb_.AddElement<int32_t>(ReferenceData::VT_SETTLEMENT_DATE, settlement_date, 0);
  }
  void add_expiry_datetime(int64_t expiry_datetime) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME, expiry_datetime, 0);
  }
  void add_expiry_datetime_utc(int64_t expiry_datetime_utc) {
    fbb_.AddElement<int64_t>(ReferenceData::VT_EXPIRY_DATETIME_UTC, expiry_datetime_utc, 0);
  }
  explicit ReferenceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ReferenceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReferenceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReferenceData> CreateReferenceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType_Undefined,
    flatbuffers::Offset<flatbuffers::String> currency = 0,
    flatbuffers::Offset<flatbuffers::String> settlement_currency = 0,
    flatbuffers::Offset<flatbuffers::String> commission_currency = 0,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType_Undefined,
    flatbuffers::Offset<flatbuffers::String> strike_currency = 0,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    flatbuffers::Offset<flatbuffers::String> underlying = 0,
    flatbuffers::Offset<flatbuffers::String> time_zone = 0,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0) {
  ReferenceDataBuilder builder_(_fbb);
  builder_.add_expiry_datetime_utc(expiry_datetime_utc);
  builder_.add_expiry_datetime(expiry_datetime);
  builder_.add_strike_price(strike_price);
  builder_.add_min_trade_vol(min_trade_vol);
  builder_.add_multiplier(multiplier);
  builder_.add_tick_size(tick_size);
  builder_.add_settlement_date(settlement_date);
  builder_.add_issue_date(issue_date);
  builder_.add_time_zone(time_zone);
  builder_.add_underlying(underlying);
  builder_.add_strike_currency(strike_currency);
  builder_.add_commission_currency(commission_currency);
  builder_.add_settlement_currency(settlement_currency);
  builder_.add_currency(currency);
  builder_.add_description(description);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_option_type(option_type);
  builder_.add_security_type(security_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReferenceData> CreateReferenceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const char *description = nullptr,
    roq::fbs::SecurityType security_type = roq::fbs::SecurityType_Undefined,
    const char *currency = nullptr,
    const char *settlement_currency = nullptr,
    const char *commission_currency = nullptr,
    double tick_size = std::numeric_limits<double>::quiet_NaN(),
    double multiplier = std::numeric_limits<double>::quiet_NaN(),
    double min_trade_vol = std::numeric_limits<double>::quiet_NaN(),
    roq::fbs::OptionType option_type = roq::fbs::OptionType_Undefined,
    const char *strike_currency = nullptr,
    double strike_price = std::numeric_limits<double>::quiet_NaN(),
    const char *underlying = nullptr,
    const char *time_zone = nullptr,
    int32_t issue_date = 0,
    int32_t settlement_date = 0,
    int64_t expiry_datetime = 0,
    int64_t expiry_datetime_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto currency__ = currency ? _fbb.CreateString(currency) : 0;
  auto settlement_currency__ = settlement_currency ? _fbb.CreateString(settlement_currency) : 0;
  auto commission_currency__ = commission_currency ? _fbb.CreateString(commission_currency) : 0;
  auto strike_currency__ = strike_currency ? _fbb.CreateString(strike_currency) : 0;
  auto underlying__ = underlying ? _fbb.CreateString(underlying) : 0;
  auto time_zone__ = time_zone ? _fbb.CreateString(time_zone) : 0;
  return roq::fbs::CreateReferenceData(
      _fbb,
      stream_id,
      exchange__,
      symbol__,
      description__,
      security_type,
      currency__,
      settlement_currency__,
      commission_currency__,
      tick_size,
      multiplier,
      min_trade_vol,
      option_type,
      strike_currency__,
      strike_price,
      underlying__,
      time_zone__,
      issue_date,
      settlement_date,
      expiry_datetime,
      expiry_datetime_utc);
}

struct StatisticsUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_STATISTICS = 10,
    VT_SNAPSHOT = 12,
    VT_EXCHANGE_TIME_UTC = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> *statistics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>> *>(VT_STATISTICS);
  }
  bool snapshot() const { return GetField<uint8_t>(VT_SNAPSHOT, 0) != 0; }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_STATISTICS) && verifier.VerifyVector(statistics()) &&
           verifier.VerifyVectorOfTables(statistics()) && VerifyField<uint8_t>(verifier, VT_SNAPSHOT) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC) && verifier.EndTable();
  }
};

struct StatisticsUpdateBuilder {
  typedef StatisticsUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(StatisticsUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(StatisticsUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(StatisticsUpdate::VT_SYMBOL, symbol);
  }
  void add_statistics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics) {
    fbb_.AddOffset(StatisticsUpdate::VT_STATISTICS, statistics);
  }
  void add_snapshot(bool snapshot) {
    fbb_.AddElement<uint8_t>(StatisticsUpdate::VT_SNAPSHOT, static_cast<uint8_t>(snapshot), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(StatisticsUpdate::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit StatisticsUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<StatisticsUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatisticsUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Statistics>>> statistics = 0,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  StatisticsUpdateBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_statistics(statistics);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_snapshot(snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatisticsUpdate> CreateStatisticsUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Statistics>> *statistics = nullptr,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto statistics__ = statistics ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Statistics>>(*statistics) : 0;
  return roq::fbs::CreateStatisticsUpdate(
      _fbb, stream_id, exchange__, symbol__, statistics__, snapshot, exchange_time_utc);
}

struct StreamStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StreamStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_SUPPORTS = 8,
    VT_STATUS = 10,
    VT_TYPE = 12,
    VT_PRIORITY = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint64_t supports() const { return GetField<uint64_t>(VT_SUPPORTS, 0); }
  roq::fbs::ConnectionStatus status() const {
    return static_cast<roq::fbs::ConnectionStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  roq::fbs::StreamType type() const { return static_cast<roq::fbs::StreamType>(GetField<uint8_t>(VT_TYPE, 0)); }
  roq::fbs::Priority priority() const { return static_cast<roq::fbs::Priority>(GetField<uint32_t>(VT_PRIORITY, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint64_t>(verifier, VT_SUPPORTS) && VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) && VerifyField<uint32_t>(verifier, VT_PRIORITY) &&
           verifier.EndTable();
  }
};

struct StreamStatusBuilder {
  typedef StreamStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(StreamStatus::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(StreamStatus::VT_ACCOUNT, account);
  }
  void add_supports(uint64_t supports) { fbb_.AddElement<uint64_t>(StreamStatus::VT_SUPPORTS, supports, 0); }
  void add_status(roq::fbs::ConnectionStatus status) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_type(roq::fbs::StreamType type) {
    fbb_.AddElement<uint8_t>(StreamStatus::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_priority(roq::fbs::Priority priority) {
    fbb_.AddElement<uint32_t>(StreamStatus::VT_PRIORITY, static_cast<uint32_t>(priority), 0);
  }
  explicit StreamStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<StreamStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StreamStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<StreamStatus> CreateStreamStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus status = roq::fbs::ConnectionStatus_Undefined,
    roq::fbs::StreamType type = roq::fbs::StreamType_Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority_Undefined) {
  StreamStatusBuilder builder_(_fbb);
  builder_.add_supports(supports);
  builder_.add_priority(priority);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_type(type);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<StreamStatus> CreateStreamStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint64_t supports = 0,
    roq::fbs::ConnectionStatus status = roq::fbs::ConnectionStatus_Undefined,
    roq::fbs::StreamType type = roq::fbs::StreamType_Undefined,
    roq::fbs::Priority priority = roq::fbs::Priority_Undefined) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  return roq::fbs::CreateStreamStatus(_fbb, stream_id, account__, supports, status, type, priority);
}

struct TopOfBook FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopOfBookBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_LAYER = 10,
    VT_SNAPSHOT = 12,
    VT_EXCHANGE_TIME_UTC = 14
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const roq::fbs::Layer *layer() const { return GetPointer<const roq::fbs::Layer *>(VT_LAYER); }
  bool snapshot() const { return GetField<uint8_t>(VT_SNAPSHOT, 0) != 0; }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_LAYER) &&
           verifier.VerifyTable(layer()) && VerifyField<uint8_t>(verifier, VT_SNAPSHOT) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC) && verifier.EndTable();
  }
};

struct TopOfBookBuilder {
  typedef TopOfBook Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TopOfBook::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TopOfBook::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TopOfBook::VT_SYMBOL, symbol); }
  void add_layer(flatbuffers::Offset<roq::fbs::Layer> layer) { fbb_.AddOffset(TopOfBook::VT_LAYER, layer); }
  void add_snapshot(bool snapshot) {
    fbb_.AddElement<uint8_t>(TopOfBook::VT_SNAPSHOT, static_cast<uint8_t>(snapshot), 0);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TopOfBook::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit TopOfBookBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TopOfBook> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopOfBook>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopOfBook> CreateTopOfBook(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  TopOfBookBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_layer(layer);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  builder_.add_snapshot(snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopOfBook> CreateTopOfBookDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    flatbuffers::Offset<roq::fbs::Layer> layer = 0,
    bool snapshot = false,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return roq::fbs::CreateTopOfBook(_fbb, stream_id, exchange__, symbol__, layer, snapshot, exchange_time_utc);
}

struct TradeSummary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeSummaryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_EXCHANGE = 6,
    VT_SYMBOL = 8,
    VT_TRADES = 10,
    VT_EXCHANGE_TIME_UTC = 12
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> *trades() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>> *>(VT_TRADES);
  }
  int64_t exchange_time_utc() const { return GetField<int64_t>(VT_EXCHANGE_TIME_UTC, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_EXCHANGE) && verifier.VerifyString(exchange()) &&
           VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) && VerifyOffset(verifier, VT_TRADES) &&
           verifier.VerifyVector(trades()) && verifier.VerifyVectorOfTables(trades()) &&
           VerifyField<int64_t>(verifier, VT_EXCHANGE_TIME_UTC) && verifier.EndTable();
  }
};

struct TradeSummaryBuilder {
  typedef TradeSummary Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TradeSummary::VT_STREAM_ID, stream_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeSummary::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TradeSummary::VT_SYMBOL, symbol); }
  void add_trades(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades) {
    fbb_.AddOffset(TradeSummary::VT_TRADES, trades);
  }
  void add_exchange_time_utc(int64_t exchange_time_utc) {
    fbb_.AddElement<int64_t>(TradeSummary::VT_EXCHANGE_TIME_UTC, exchange_time_utc, 0);
  }
  explicit TradeSummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TradeSummary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeSummary>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeSummary> CreateTradeSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Trade>>> trades = 0,
    int64_t exchange_time_utc = 0) {
  TradeSummaryBuilder builder_(_fbb);
  builder_.add_exchange_time_utc(exchange_time_utc);
  builder_.add_trades(trades);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TradeSummary> CreateTradeSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Trade>> *trades = nullptr,
    int64_t exchange_time_utc = 0) {
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto trades__ = trades ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Trade>>(*trades) : 0;
  return roq::fbs::CreateTradeSummary(_fbb, stream_id, exchange__, symbol__, trades__, exchange_time_utc);
}

struct TradeUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TradeUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_ACCOUNT = 6,
    VT_ORDER_ID = 8,
    VT_EXCHANGE = 10,
    VT_SYMBOL = 12,
    VT_SIDE = 14,
    VT_POSITION_EFFECT = 16,
    VT_CREATE_TIME_UTC = 18,
    VT_UPDATE_TIME_UTC = 20,
    VT_EXTERNAL_ACCOUNT = 22,
    VT_EXTERNAL_ORDER_ID = 24,
    VT_ROUTING_ID = 26,
    VT_FILLS = 28
  };
  uint16_t stream_id() const { return GetField<uint16_t>(VT_STREAM_ID, 0); }
  const flatbuffers::String *account() const { return GetPointer<const flatbuffers::String *>(VT_ACCOUNT); }
  uint32_t order_id() const { return GetField<uint32_t>(VT_ORDER_ID, 0); }
  const flatbuffers::String *exchange() const { return GetPointer<const flatbuffers::String *>(VT_EXCHANGE); }
  const flatbuffers::String *symbol() const { return GetPointer<const flatbuffers::String *>(VT_SYMBOL); }
  roq::fbs::Side side() const { return static_cast<roq::fbs::Side>(GetField<uint8_t>(VT_SIDE, 0)); }
  roq::fbs::PositionEffect position_effect() const {
    return static_cast<roq::fbs::PositionEffect>(GetField<uint8_t>(VT_POSITION_EFFECT, 0));
  }
  int64_t create_time_utc() const { return GetField<int64_t>(VT_CREATE_TIME_UTC, 0); }
  int64_t update_time_utc() const { return GetField<int64_t>(VT_UPDATE_TIME_UTC, 0); }
  const flatbuffers::String *external_account() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ACCOUNT);
  }
  const flatbuffers::String *external_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXTERNAL_ORDER_ID);
  }
  const flatbuffers::String *routing_id() const { return GetPointer<const flatbuffers::String *>(VT_ROUTING_ID); }
  const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> *fills() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>> *>(VT_FILLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_STREAM_ID) &&
           VerifyOffset(verifier, VT_ACCOUNT) && verifier.VerifyString(account()) &&
           VerifyField<uint32_t>(verifier, VT_ORDER_ID) && VerifyOffset(verifier, VT_EXCHANGE) &&
           verifier.VerifyString(exchange()) && VerifyOffset(verifier, VT_SYMBOL) && verifier.VerifyString(symbol()) &&
           VerifyField<uint8_t>(verifier, VT_SIDE) && VerifyField<uint8_t>(verifier, VT_POSITION_EFFECT) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIME_UTC) && VerifyField<int64_t>(verifier, VT_UPDATE_TIME_UTC) &&
           VerifyOffset(verifier, VT_EXTERNAL_ACCOUNT) && verifier.VerifyString(external_account()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ORDER_ID) && verifier.VerifyString(external_order_id()) &&
           VerifyOffset(verifier, VT_ROUTING_ID) && verifier.VerifyString(routing_id()) &&
           VerifyOffset(verifier, VT_FILLS) && verifier.VerifyVector(fills()) &&
           verifier.VerifyVectorOfTables(fills()) && verifier.EndTable();
  }
};

struct TradeUpdateBuilder {
  typedef TradeUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stream_id(uint16_t stream_id) { fbb_.AddElement<uint16_t>(TradeUpdate::VT_STREAM_ID, stream_id, 0); }
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(TradeUpdate::VT_ACCOUNT, account);
  }
  void add_order_id(uint32_t order_id) { fbb_.AddElement<uint32_t>(TradeUpdate::VT_ORDER_ID, order_id, 0); }
  void add_exchange(flatbuffers::Offset<flatbuffers::String> exchange) {
    fbb_.AddOffset(TradeUpdate::VT_EXCHANGE, exchange);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) { fbb_.AddOffset(TradeUpdate::VT_SYMBOL, symbol); }
  void add_side(roq::fbs::Side side) { fbb_.AddElement<uint8_t>(TradeUpdate::VT_SIDE, static_cast<uint8_t>(side), 0); }
  void add_position_effect(roq::fbs::PositionEffect position_effect) {
    fbb_.AddElement<uint8_t>(TradeUpdate::VT_POSITION_EFFECT, static_cast<uint8_t>(position_effect), 0);
  }
  void add_create_time_utc(int64_t create_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_update_time_utc(int64_t update_time_utc) {
    fbb_.AddElement<int64_t>(TradeUpdate::VT_UPDATE_TIME_UTC, update_time_utc, 0);
  }
  void add_external_account(flatbuffers::Offset<flatbuffers::String> external_account) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ACCOUNT, external_account);
  }
  void add_external_order_id(flatbuffers::Offset<flatbuffers::String> external_order_id) {
    fbb_.AddOffset(TradeUpdate::VT_EXTERNAL_ORDER_ID, external_order_id);
  }
  void add_routing_id(flatbuffers::Offset<flatbuffers::String> routing_id) {
    fbb_.AddOffset(TradeUpdate::VT_ROUTING_ID, routing_id);
  }
  void add_fills(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills) {
    fbb_.AddOffset(TradeUpdate::VT_FILLS, fills);
  }
  explicit TradeUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<TradeUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TradeUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    uint32_t order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange = 0,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    flatbuffers::Offset<flatbuffers::String> external_account = 0,
    flatbuffers::Offset<flatbuffers::String> external_order_id = 0,
    flatbuffers::Offset<flatbuffers::String> routing_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<roq::fbs::Fill>>> fills = 0) {
  TradeUpdateBuilder builder_(_fbb);
  builder_.add_update_time_utc(update_time_utc);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_fills(fills);
  builder_.add_routing_id(routing_id);
  builder_.add_external_order_id(external_order_id);
  builder_.add_external_account(external_account);
  builder_.add_symbol(symbol);
  builder_.add_exchange(exchange);
  builder_.add_order_id(order_id);
  builder_.add_account(account);
  builder_.add_stream_id(stream_id);
  builder_.add_position_effect(position_effect);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<TradeUpdate> CreateTradeUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stream_id = 0,
    const char *account = nullptr,
    uint32_t order_id = 0,
    const char *exchange = nullptr,
    const char *symbol = nullptr,
    roq::fbs::Side side = roq::fbs::Side_Undefined,
    roq::fbs::PositionEffect position_effect = roq::fbs::PositionEffect_Undefined,
    int64_t create_time_utc = 0,
    int64_t update_time_utc = 0,
    const char *external_account = nullptr,
    const char *external_order_id = nullptr,
    const char *routing_id = nullptr,
    const std::vector<flatbuffers::Offset<roq::fbs::Fill>> *fills = nullptr) {
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto exchange__ = exchange ? _fbb.CreateString(exchange) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto external_account__ = external_account ? _fbb.CreateString(external_account) : 0;
  auto external_order_id__ = external_order_id ? _fbb.CreateString(external_order_id) : 0;
  auto routing_id__ = routing_id ? _fbb.CreateString(routing_id) : 0;
  auto fills__ = fills ? _fbb.CreateVector<flatbuffers::Offset<roq::fbs::Fill>>(*fills) : 0;
  return roq::fbs::CreateTradeUpdate(
      _fbb,
      stream_id,
      account__,
      order_id,
      exchange__,
      symbol__,
      side,
      position_effect,
      create_time_utc,
      update_time_utc,
      external_account__,
      external_order_id__,
      routing_id__,
      fills__);
}

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_UUID = 12,
    VT_LOGIN = 14,
    VT_PASSWORD = 16
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  const flatbuffers::String *application() const { return GetPointer<const flatbuffers::String *>(VT_APPLICATION); }
  const flatbuffers::String *hostname() const { return GetPointer<const flatbuffers::String *>(VT_HOSTNAME); }
  uint32_t pid() const { return GetField<uint32_t>(VT_PID, 0); }
  const flatbuffers::String *uuid() const { return GetPointer<const flatbuffers::String *>(VT_UUID); }
  const flatbuffers::String *login() const { return GetPointer<const flatbuffers::String *>(VT_LOGIN); }
  const flatbuffers::String *password() const { return GetPointer<const flatbuffers::String *>(VT_PASSWORD); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_APPLICATION) && verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) && verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID) && VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) && VerifyOffset(verifier, VT_LOGIN) && verifier.VerifyString(login()) &&
           VerifyOffset(verifier, VT_PASSWORD) && verifier.VerifyString(password()) && verifier.EndTable();
  }
};

struct HandshakeBuilder {
  typedef Handshake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(Handshake::VT_VERSION, version, 0); }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(Handshake::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(Handshake::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) { fbb_.AddElement<uint32_t>(Handshake::VT_PID, pid, 0); }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) { fbb_.AddOffset(Handshake::VT_UUID, uuid); }
  void add_login(flatbuffers::Offset<flatbuffers::String> login) { fbb_.AddOffset(Handshake::VT_LOGIN, login); }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Handshake::VT_PASSWORD, password);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Handshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> login = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_login(login);
  builder_.add_uuid(uuid);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const char *application = nullptr,
    const char *hostname = nullptr,
    uint32_t pid = 0,
    const char *uuid = nullptr,
    const char *login = nullptr,
    const char *password = nullptr) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto login__ = login ? _fbb.CreateString(login) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return roq::fbs::CreateHandshake(_fbb, version, application__, hostname__, pid, uuid__, login__, password__);
}

struct HandshakeAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_APPLICATION = 6,
    VT_HOSTNAME = 8,
    VT_PID = 10,
    VT_FAILURE = 12,
    VT_FAILURE_REASON = 14,
    VT_UUID = 16,
    VT_NAME = 18,
    VT_USER_ID = 20
  };
  uint32_t version() const { return GetField<uint32_t>(VT_VERSION, 0); }
  const flatbuffers::String *application() const { return GetPointer<const flatbuffers::String *>(VT_APPLICATION); }
  const flatbuffers::String *hostname() const { return GetPointer<const flatbuffers::String *>(VT_HOSTNAME); }
  uint32_t pid() const { return GetField<uint32_t>(VT_PID, 0); }
  bool failure() const { return GetField<uint8_t>(VT_FAILURE, 0) != 0; }
  const flatbuffers::String *failure_reason() const {
    return GetPointer<const flatbuffers::String *>(VT_FAILURE_REASON);
  }
  const flatbuffers::String *uuid() const { return GetPointer<const flatbuffers::String *>(VT_UUID); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  uint8_t user_id() const { return GetField<uint8_t>(VT_USER_ID, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_APPLICATION) && verifier.VerifyString(application()) &&
           VerifyOffset(verifier, VT_HOSTNAME) && verifier.VerifyString(hostname()) &&
           VerifyField<uint32_t>(verifier, VT_PID) && VerifyField<uint8_t>(verifier, VT_FAILURE) &&
           VerifyOffset(verifier, VT_FAILURE_REASON) && verifier.VerifyString(failure_reason()) &&
           VerifyOffset(verifier, VT_UUID) && verifier.VerifyString(uuid()) && VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) && VerifyField<uint8_t>(verifier, VT_USER_ID) && verifier.EndTable();
  }
};

struct HandshakeAckBuilder {
  typedef HandshakeAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) { fbb_.AddElement<uint32_t>(HandshakeAck::VT_VERSION, version, 0); }
  void add_application(flatbuffers::Offset<flatbuffers::String> application) {
    fbb_.AddOffset(HandshakeAck::VT_APPLICATION, application);
  }
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(HandshakeAck::VT_HOSTNAME, hostname);
  }
  void add_pid(uint32_t pid) { fbb_.AddElement<uint32_t>(HandshakeAck::VT_PID, pid, 0); }
  void add_failure(bool failure) {
    fbb_.AddElement<uint8_t>(HandshakeAck::VT_FAILURE, static_cast<uint8_t>(failure), 0);
  }
  void add_failure_reason(flatbuffers::Offset<flatbuffers::String> failure_reason) {
    fbb_.AddOffset(HandshakeAck::VT_FAILURE_REASON, failure_reason);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) { fbb_.AddOffset(HandshakeAck::VT_UUID, uuid); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(HandshakeAck::VT_NAME, name); }
  void add_user_id(uint8_t user_id) { fbb_.AddElement<uint8_t>(HandshakeAck::VT_USER_ID, user_id, 0); }
  explicit HandshakeAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<HandshakeAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> application = 0,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    uint32_t pid = 0,
    bool failure = false,
    flatbuffers::Offset<flatbuffers::String> failure_reason = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t user_id = 0) {
  HandshakeAckBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  builder_.add_failure_reason(failure_reason);
  builder_.add_pid(pid);
  builder_.add_hostname(hostname);
  builder_.add_application(application);
  builder_.add_version(version);
  builder_.add_user_id(user_id);
  builder_.add_failure(failure);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const char *application = nullptr,
    const char *hostname = nullptr,
    uint32_t pid = 0,
    bool failure = false,
    const char *failure_reason = nullptr,
    const char *uuid = nullptr,
    const char *name = nullptr,
    uint8_t user_id = 0) {
  auto application__ = application ? _fbb.CreateString(application) : 0;
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto failure_reason__ = failure_reason ? _fbb.CreateString(failure_reason) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return roq::fbs::CreateHandshakeAck(
      _fbb, version, application__, hostname__, pid, failure, failure_reason__, uuid__, name__, user_id);
}

struct Subscribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscribeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct SubscribeBuilder {
  typedef Subscribe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubscribeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Subscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Subscribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Subscribe> CreateSubscribe(flatbuffers::FlatBufferBuilder &_fbb) {
  SubscribeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchBegin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchBeginBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct BatchBeginBuilder {
  typedef BatchBegin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchBeginBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<BatchBegin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchBegin>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchBegin> CreateBatchBegin(flatbuffers::FlatBufferBuilder &_fbb) {
  BatchBeginBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchEndBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const { return VerifyTableStart(verifier) && verifier.EndTable(); }
};

struct BatchEndBuilder {
  typedef BatchEnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchEndBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<BatchEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchEnd> CreateBatchEnd(flatbuffers::FlatBufferBuilder &_fbb) {
  BatchEndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SourceInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQNO = 4,
    VT_SEND_TIME_UTC = 6,
    VT_CREATE_TIME_UTC = 8,
    VT_SEND_TIME = 10,
    VT_CREATE_TIME = 12
  };
  uint64_t seqno() const { return GetField<uint64_t>(VT_SEQNO, 0); }
  uint64_t send_time_utc() const { return GetField<uint64_t>(VT_SEND_TIME_UTC, 0); }
  uint64_t create_time_utc() const { return GetField<uint64_t>(VT_CREATE_TIME_UTC, 0); }
  uint64_t send_time() const { return GetField<uint64_t>(VT_SEND_TIME, 0); }
  uint64_t create_time() const { return GetField<uint64_t>(VT_CREATE_TIME, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_SEQNO) &&
           VerifyField<uint64_t>(verifier, VT_SEND_TIME_UTC) && VerifyField<uint64_t>(verifier, VT_CREATE_TIME_UTC) &&
           VerifyField<uint64_t>(verifier, VT_SEND_TIME) && VerifyField<uint64_t>(verifier, VT_CREATE_TIME) &&
           verifier.EndTable();
  }
};

struct SourceInfoBuilder {
  typedef SourceInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqno(uint64_t seqno) { fbb_.AddElement<uint64_t>(SourceInfo::VT_SEQNO, seqno, 0); }
  void add_send_time_utc(uint64_t send_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME_UTC, send_time_utc, 0);
  }
  void add_create_time_utc(uint64_t create_time_utc) {
    fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME_UTC, create_time_utc, 0);
  }
  void add_send_time(uint64_t send_time) { fbb_.AddElement<uint64_t>(SourceInfo::VT_SEND_TIME, send_time, 0); }
  void add_create_time(uint64_t create_time) { fbb_.AddElement<uint64_t>(SourceInfo::VT_CREATE_TIME, create_time, 0); }
  explicit SourceInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<SourceInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceInfo> CreateSourceInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t seqno = 0,
    uint64_t send_time_utc = 0,
    uint64_t create_time_utc = 0,
    uint64_t send_time = 0,
    uint64_t create_time = 0) {
  SourceInfoBuilder builder_(_fbb);
  builder_.add_create_time(create_time);
  builder_.add_send_time(send_time);
  builder_.add_create_time_utc(create_time_utc);
  builder_.add_send_time_utc(send_time_utc);
  builder_.add_seqno(seqno);
  return builder_.Finish();
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_INFO = 4,
    VT_MESSAGE_TYPE = 6,
    VT_MESSAGE = 8
  };
  const roq::fbs::SourceInfo *source_info() const { return GetPointer<const roq::fbs::SourceInfo *>(VT_SOURCE_INFO); }
  roq::fbs::Message message_type() const {
    return static_cast<roq::fbs::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const { return GetPointer<const void *>(VT_MESSAGE); }
  template <typename T>
  const T *message_as() const;
  const roq::fbs::Handshake *message_as_Handshake() const {
    return message_type() == roq::fbs::Message_Handshake ? static_cast<const roq::fbs::Handshake *>(message())
                                                         : nullptr;
  }
  const roq::fbs::HandshakeAck *message_as_HandshakeAck() const {
    return message_type() == roq::fbs::Message_HandshakeAck ? static_cast<const roq::fbs::HandshakeAck *>(message())
                                                            : nullptr;
  }
  const roq::fbs::Subscribe *message_as_Subscribe() const {
    return message_type() == roq::fbs::Message_Subscribe ? static_cast<const roq::fbs::Subscribe *>(message())
                                                         : nullptr;
  }
  const roq::fbs::BatchBegin *message_as_BatchBegin() const {
    return message_type() == roq::fbs::Message_BatchBegin ? static_cast<const roq::fbs::BatchBegin *>(message())
                                                          : nullptr;
  }
  const roq::fbs::BatchEnd *message_as_BatchEnd() const {
    return message_type() == roq::fbs::Message_BatchEnd ? static_cast<const roq::fbs::BatchEnd *>(message()) : nullptr;
  }
  const roq::fbs::DownloadBegin *message_as_DownloadBegin() const {
    return message_type() == roq::fbs::Message_DownloadBegin ? static_cast<const roq::fbs::DownloadBegin *>(message())
                                                             : nullptr;
  }
  const roq::fbs::DownloadEnd *message_as_DownloadEnd() const {
    return message_type() == roq::fbs::Message_DownloadEnd ? static_cast<const roq::fbs::DownloadEnd *>(message())
                                                           : nullptr;
  }
  const roq::fbs::GatewaySettings *message_as_GatewaySettings() const {
    return message_type() == roq::fbs::Message_GatewaySettings
               ? static_cast<const roq::fbs::GatewaySettings *>(message())
               : nullptr;
  }
  const roq::fbs::StreamStatus *message_as_StreamStatus() const {
    return message_type() == roq::fbs::Message_StreamStatus ? static_cast<const roq::fbs::StreamStatus *>(message())
                                                            : nullptr;
  }
  const roq::fbs::ExternalLatency *message_as_ExternalLatency() const {
    return message_type() == roq::fbs::Message_ExternalLatency
               ? static_cast<const roq::fbs::ExternalLatency *>(message())
               : nullptr;
  }
  const roq::fbs::RateLimitUsage *message_as_RateLimitUsage() const {
    return message_type() == roq::fbs::Message_RateLimitUsage ? static_cast<const roq::fbs::RateLimitUsage *>(message())
                                                              : nullptr;
  }
  const roq::fbs::GatewayStatus *message_as_GatewayStatus() const {
    return message_type() == roq::fbs::Message_GatewayStatus ? static_cast<const roq::fbs::GatewayStatus *>(message())
                                                             : nullptr;
  }
  const roq::fbs::ReferenceData *message_as_ReferenceData() const {
    return message_type() == roq::fbs::Message_ReferenceData ? static_cast<const roq::fbs::ReferenceData *>(message())
                                                             : nullptr;
  }
  const roq::fbs::MarketStatus *message_as_MarketStatus() const {
    return message_type() == roq::fbs::Message_MarketStatus ? static_cast<const roq::fbs::MarketStatus *>(message())
                                                            : nullptr;
  }
  const roq::fbs::TopOfBook *message_as_TopOfBook() const {
    return message_type() == roq::fbs::Message_TopOfBook ? static_cast<const roq::fbs::TopOfBook *>(message())
                                                         : nullptr;
  }
  const roq::fbs::MarketByPriceUpdate *message_as_MarketByPriceUpdate() const {
    return message_type() == roq::fbs::Message_MarketByPriceUpdate
               ? static_cast<const roq::fbs::MarketByPriceUpdate *>(message())
               : nullptr;
  }
  const roq::fbs::MarketByOrderUpdate *message_as_MarketByOrderUpdate() const {
    return message_type() == roq::fbs::Message_MarketByOrderUpdate
               ? static_cast<const roq::fbs::MarketByOrderUpdate *>(message())
               : nullptr;
  }
  const roq::fbs::TradeSummary *message_as_TradeSummary() const {
    return message_type() == roq::fbs::Message_TradeSummary ? static_cast<const roq::fbs::TradeSummary *>(message())
                                                            : nullptr;
  }
  const roq::fbs::StatisticsUpdate *message_as_StatisticsUpdate() const {
    return message_type() == roq::fbs::Message_StatisticsUpdate
               ? static_cast<const roq::fbs::StatisticsUpdate *>(message())
               : nullptr;
  }
  const roq::fbs::CreateOrder *message_as_CreateOrder() const {
    return message_type() == roq::fbs::Message_CreateOrder ? static_cast<const roq::fbs::CreateOrder *>(message())
                                                           : nullptr;
  }
  const roq::fbs::ModifyOrder *message_as_ModifyOrder() const {
    return message_type() == roq::fbs::Message_ModifyOrder ? static_cast<const roq::fbs::ModifyOrder *>(message())
                                                           : nullptr;
  }
  const roq::fbs::CancelOrder *message_as_CancelOrder() const {
    return message_type() == roq::fbs::Message_CancelOrder ? static_cast<const roq::fbs::CancelOrder *>(message())
                                                           : nullptr;
  }
  const roq::fbs::CancelAllOrders *message_as_CancelAllOrders() const {
    return message_type() == roq::fbs::Message_CancelAllOrders
               ? static_cast<const roq::fbs::CancelAllOrders *>(message())
               : nullptr;
  }
  const roq::fbs::OrderAck *message_as_OrderAck() const {
    return message_type() == roq::fbs::Message_OrderAck ? static_cast<const roq::fbs::OrderAck *>(message()) : nullptr;
  }
  const roq::fbs::OrderUpdate *message_as_OrderUpdate() const {
    return message_type() == roq::fbs::Message_OrderUpdate ? static_cast<const roq::fbs::OrderUpdate *>(message())
                                                           : nullptr;
  }
  const roq::fbs::TradeUpdate *message_as_TradeUpdate() const {
    return message_type() == roq::fbs::Message_TradeUpdate ? static_cast<const roq::fbs::TradeUpdate *>(message())
                                                           : nullptr;
  }
  const roq::fbs::PositionUpdate *message_as_PositionUpdate() const {
    return message_type() == roq::fbs::Message_PositionUpdate ? static_cast<const roq::fbs::PositionUpdate *>(message())
                                                              : nullptr;
  }
  const roq::fbs::FundsUpdate *message_as_FundsUpdate() const {
    return message_type() == roq::fbs::Message_FundsUpdate ? static_cast<const roq::fbs::FundsUpdate *>(message())
                                                           : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_SOURCE_INFO) &&
           verifier.VerifyTable(source_info()) && VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) && VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const roq::fbs::Handshake *Event::message_as<roq::fbs::Handshake>() const {
  return message_as_Handshake();
}

template <>
inline const roq::fbs::HandshakeAck *Event::message_as<roq::fbs::HandshakeAck>() const {
  return message_as_HandshakeAck();
}

template <>
inline const roq::fbs::Subscribe *Event::message_as<roq::fbs::Subscribe>() const {
  return message_as_Subscribe();
}

template <>
inline const roq::fbs::BatchBegin *Event::message_as<roq::fbs::BatchBegin>() const {
  return message_as_BatchBegin();
}

template <>
inline const roq::fbs::BatchEnd *Event::message_as<roq::fbs::BatchEnd>() const {
  return message_as_BatchEnd();
}

template <>
inline const roq::fbs::DownloadBegin *Event::message_as<roq::fbs::DownloadBegin>() const {
  return message_as_DownloadBegin();
}

template <>
inline const roq::fbs::DownloadEnd *Event::message_as<roq::fbs::DownloadEnd>() const {
  return message_as_DownloadEnd();
}

template <>
inline const roq::fbs::GatewaySettings *Event::message_as<roq::fbs::GatewaySettings>() const {
  return message_as_GatewaySettings();
}

template <>
inline const roq::fbs::StreamStatus *Event::message_as<roq::fbs::StreamStatus>() const {
  return message_as_StreamStatus();
}

template <>
inline const roq::fbs::ExternalLatency *Event::message_as<roq::fbs::ExternalLatency>() const {
  return message_as_ExternalLatency();
}

template <>
inline const roq::fbs::RateLimitUsage *Event::message_as<roq::fbs::RateLimitUsage>() const {
  return message_as_RateLimitUsage();
}

template <>
inline const roq::fbs::GatewayStatus *Event::message_as<roq::fbs::GatewayStatus>() const {
  return message_as_GatewayStatus();
}

template <>
inline const roq::fbs::ReferenceData *Event::message_as<roq::fbs::ReferenceData>() const {
  return message_as_ReferenceData();
}

template <>
inline const roq::fbs::MarketStatus *Event::message_as<roq::fbs::MarketStatus>() const {
  return message_as_MarketStatus();
}

template <>
inline const roq::fbs::TopOfBook *Event::message_as<roq::fbs::TopOfBook>() const {
  return message_as_TopOfBook();
}

template <>
inline const roq::fbs::MarketByPriceUpdate *Event::message_as<roq::fbs::MarketByPriceUpdate>() const {
  return message_as_MarketByPriceUpdate();
}

template <>
inline const roq::fbs::MarketByOrderUpdate *Event::message_as<roq::fbs::MarketByOrderUpdate>() const {
  return message_as_MarketByOrderUpdate();
}

template <>
inline const roq::fbs::TradeSummary *Event::message_as<roq::fbs::TradeSummary>() const {
  return message_as_TradeSummary();
}

template <>
inline const roq::fbs::StatisticsUpdate *Event::message_as<roq::fbs::StatisticsUpdate>() const {
  return message_as_StatisticsUpdate();
}

template <>
inline const roq::fbs::CreateOrder *Event::message_as<roq::fbs::CreateOrder>() const {
  return message_as_CreateOrder();
}

template <>
inline const roq::fbs::ModifyOrder *Event::message_as<roq::fbs::ModifyOrder>() const {
  return message_as_ModifyOrder();
}

template <>
inline const roq::fbs::CancelOrder *Event::message_as<roq::fbs::CancelOrder>() const {
  return message_as_CancelOrder();
}

template <>
inline const roq::fbs::CancelAllOrders *Event::message_as<roq::fbs::CancelAllOrders>() const {
  return message_as_CancelAllOrders();
}

template <>
inline const roq::fbs::OrderAck *Event::message_as<roq::fbs::OrderAck>() const {
  return message_as_OrderAck();
}

template <>
inline const roq::fbs::OrderUpdate *Event::message_as<roq::fbs::OrderUpdate>() const {
  return message_as_OrderUpdate();
}

template <>
inline const roq::fbs::TradeUpdate *Event::message_as<roq::fbs::TradeUpdate>() const {
  return message_as_TradeUpdate();
}

template <>
inline const roq::fbs::PositionUpdate *Event::message_as<roq::fbs::PositionUpdate>() const {
  return message_as_PositionUpdate();
}

template <>
inline const roq::fbs::FundsUpdate *Event::message_as<roq::fbs::FundsUpdate>() const {
  return message_as_FundsUpdate();
}

struct EventBuilder {
  typedef Event Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_info(flatbuffers::Offset<roq::fbs::SourceInfo> source_info) {
    fbb_.AddOffset(Event::VT_SOURCE_INFO, source_info);
  }
  void add_message_type(roq::fbs::Message message_type) {
    fbb_.AddElement<uint8_t>(Event::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) { fbb_.AddOffset(Event::VT_MESSAGE, message); }
  explicit EventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<roq::fbs::SourceInfo> source_info = 0,
    roq::fbs::Message message_type = roq::fbs::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_source_info(source_info);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Handshake: {
      auto ptr = reinterpret_cast<const roq::fbs::Handshake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_HandshakeAck: {
      auto ptr = reinterpret_cast<const roq::fbs::HandshakeAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Subscribe: {
      auto ptr = reinterpret_cast<const roq::fbs::Subscribe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_BatchBegin: {
      auto ptr = reinterpret_cast<const roq::fbs::BatchBegin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_BatchEnd: {
      auto ptr = reinterpret_cast<const roq::fbs::BatchEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DownloadBegin: {
      auto ptr = reinterpret_cast<const roq::fbs::DownloadBegin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_DownloadEnd: {
      auto ptr = reinterpret_cast<const roq::fbs::DownloadEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GatewaySettings: {
      auto ptr = reinterpret_cast<const roq::fbs::GatewaySettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StreamStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::StreamStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ExternalLatency: {
      auto ptr = reinterpret_cast<const roq::fbs::ExternalLatency *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RateLimitUsage: {
      auto ptr = reinterpret_cast<const roq::fbs::RateLimitUsage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GatewayStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::GatewayStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReferenceData: {
      auto ptr = reinterpret_cast<const roq::fbs::ReferenceData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketStatus: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TopOfBook: {
      auto ptr = reinterpret_cast<const roq::fbs::TopOfBook *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketByPriceUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketByPriceUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_MarketByOrderUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::MarketByOrderUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TradeSummary: {
      auto ptr = reinterpret_cast<const roq::fbs::TradeSummary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_StatisticsUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::StatisticsUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CreateOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::CreateOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ModifyOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::ModifyOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CancelOrder: {
      auto ptr = reinterpret_cast<const roq::fbs::CancelOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CancelAllOrders: {
      auto ptr = reinterpret_cast<const roq::fbs::CancelAllOrders *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_OrderAck: {
      auto ptr = reinterpret_cast<const roq::fbs::OrderAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_OrderUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::OrderUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_TradeUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::TradeUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_PositionUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::PositionUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_FundsUpdate: {
      auto ptr = reinterpret_cast<const roq::fbs::FundsUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default:
      return true;
  }
}

inline bool VerifyMessageVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(verifier, values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const roq::fbs::Event *GetEvent(const void *buf) {
  return flatbuffers::GetRoot<roq::fbs::Event>(buf);
}

inline const roq::fbs::Event *GetSizePrefixedEvent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<roq::fbs::Event>(buf);
}

inline bool VerifyEventBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<roq::fbs::Event>(nullptr);
}

inline bool VerifySizePrefixedEventBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<roq::fbs::Event>(nullptr);
}

inline void FinishEventBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<roq::fbs::Event> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace roq

#endif  // FLATBUFFERS_GENERATED_API_ROQ_FBS_H_
